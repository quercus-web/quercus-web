<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" ><channel><title>Automatizacija &#8211; Quercus Lab</title> <atom:link href="http://www.quercus-lab.com/category/automatizacija/feed/" rel="self" type="application/rss+xml" /><link>http://www.quercus-lab.com</link> <description>Blog o softverskom razvoju, elektronici ...</description> <lastBuildDate>Wed, 30 Oct 2013 08:40:37 +0000</lastBuildDate> <language>en-US</language> <sy:updatePeriod>hourly</sy:updatePeriod> <sy:updateFrequency>1</sy:updateFrequency> <generator>https://wordpress.org/?v=4.9.8</generator> <item><title>VB OPC klijent</title><link>http://www.quercus-lab.com/vb-opc-klijent/</link> <pubDate>Mon, 01 Oct 2012 18:06:51 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Automatizacija]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=889</guid> <description><![CDATA[&#160; Prva računala za kontrolu industrijskih procesa praktički i nisu imala nikakvu interakciju sa ljudima koji su nadzirali proizvodnju. Ako su i imali to su bile kontrolne ploče naslijeđene od ranijih relejnih sustava upravljanja. Razvojem informatičke  tehnologije monitori su postali sastavni dio i industrijskih postrojenja  te je nadzor i interakcija ljudi i strojeva postala mnogo [&#8230;]]]></description> <content:encoded><![CDATA[<p>&nbsp;</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/06/VB_klijent.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/06/VB_klijent.png" alt="" title="VB_klijent" class="size-full wp-image-892 alignleft" height="130" width="180" /></a>Prva računala za kontrolu industrijskih procesa praktički i nisu imala nikakvu interakciju sa ljudima koji su nadzirali proizvodnju. Ako su i imali to su bile kontrolne ploče naslijeđene od ranijih relejnih sustava upravljanja. Razvojem informatičke  tehnologije monitori su postali sastavni dio i industrijskih postrojenja  te je nadzor i interakcija ljudi i strojeva postala mnogo jednostavnija i efikasnija. Razvoj aplikacija u ovom segmentu automatizacijskih sustava dugo je bio moguć  samo sa specijalnim razvojnim alatima. Pojavom OPC tehnologije stvari su se bitno promjenile te se sada ovaj dio posla  može obaviti s gotovo bilo kojim programom i razvojnim okolinom opće (programske) namjene.  Ovdje ću pokušati objasniti razvoj malog programa pisanog u Visual Basicu 6 koji koristi OPC tehnologiju za komunikaciju s procesnim računalom i može poslužiti kao operatorsko sučelje (<a href="http://en.wikipedia.org/wiki/Human-machine_interface"><em>HMI</em></a>).</p><h4 style="text-align: left;">Visual Basic 6</h4><p>Basic (<a href="http://en.wikipedia.org/wiki/BASIC"><span style="font-size: x-small;" size="2"></span><em>Beginners All-Purpose Symbolic Instruction Code</em></a>) je programski jezik kojeg koriste, ili su koristili, najviše programera u povijesti računalstva. Visual Basic 6 je inaćica koja sadrži više stotina naredbi i funkcija te je integriran u razvojnu okolinu  (<em>IDE</em>) za brzi i pregledni razvoj aplikacija s grafičkim sučeljem. Osim  Visual Studija, Visual Basic 6 je sastavni dio i <em>Microsoft Office</em> paketa  gdje služi za automatizaciju Excela, Worda ili PowerPointa. Upravo ta inaćica nazvana VBA (<a href="http://en.wikipedia.org/wiki/Visual_Basic_for_Applications"><em>Visual Basic for Application</em></a>) je i skriptni jezik mnogih komercijalnih razvojnih okolina za razvoj SCADA i HMI aplikacija kao što su <em>WinCC</em>  (<em>Simatic</em>)   ili <em>FactoryTalk</em>  (<em>RockwelSoftware</em>). Ova činjenica te relativna jednostavnost učenja i primjene dobar su razlog da se pozabavite Visual Basicom  mada će vas mnogi profesionalni programeri gledati s prezirom. Iako ne možemo reći u potpunosti, VB6  je objektni programski jezik i za razvoj aplikacije koristimo objekte . Objektima možemo podešavati svojsta (<em>Properties</em>) i definirati akcije na  pojedine događaje (<em>Event</em>s). Isto tako objektima možemo definirati aktivnosti koje će izvršati i to se zovu metode (<em>Methode</em>). Razvojna okolina VB6 sastoji se od nekolko cijelina :</p><ul><li>u sredini zaslona je objekt koji se naziva forma<em> (Form</em>) i on predstavlja grafičko sučelje naše aplikacije. Na formu stavljamo ostale objekte grafičkog sučelja kao što su tipke (<em>Buttons</em>), natpisi (<em>Labels</em>), padajuči izbornici (<em>DropdownBoxs</em>), slike (<em>Images</em>) i tako dalje.  Isto tako u na tome mjestu može biti programski editor gdje pišemo programski kod. Klikom miša na pojedini objekt prelazimo iz grafičkog u tekstalni mod izrade aplikacije odnosno prelazimo u programski editor.</li><li>s lijeve strane zaslona  nalazi se traka s dostupnim objetima (<em>Toolbox</em>) koje možemo prebaciti na formu  jednostavnim potezanjem  mišom.</li><li>s desne strane uobićajeno je da se nalaze tablični preglednici svojstava i strukture našeg projekta. Kada kliknemo na pojedini objekt na  formu (selektiramo ga) u ovom pregledniku se automatski izlistavaju svojstva dotičnog objeka gdje ta  svojstva možemo i mijenjati.</li></ul><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/07/VB6_IDE.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/07/VB6_IDE.png" title="VB6_IDE" class="aligncenter size-full wp-image-921" height="400" width="640" /></a></p><p>Osim toga na vrhu zaslona nalazi se standarni izbornik (<em>Menu</em>) sa svim alatima potrebnim za manipulaciju s programskim elementima, kompaliranjem programa, traženjem pogrešaka i definiranjem opcija razvojne okoline. Na dnu zaslona se u pojedinim fazama  programiranja pojavljuju prozori s rezultatima kompajliranja i eventualnim pogreškama. Dakle ako niste nikada programirali u VB6 potrebno je malo detaljinije se upoznati s načinom  rada u njemu. Na interentu imate mnogo <a href="http://www.ic.ims.hr/vba/vba-kazalo.html">tutorijala</a> od početnih koraka do naprednih opcija pa se ja ovdje neću više baviti time.</p><h4>OPC server &#8211; simulator procesa</h4><p>Da bi zrada bilo koje HMI/SCADA aplikacije bila komforna, odnosno da se ne piše na slijepo, potrebno je imati i vezu prema sklopovskoj opremi (PLC-u). Kako je kanal komunikacije  prilkom pisanja ovakvih aplikacija korištenjem VB6  OPC server neophodno je imati i OPC server sposoban za komunikaciju prema ciljanom PLC-u. Da bi  vam demonstrirali primjer pisanja male HMI aplikcaije koje  vi možete modificirati i testirati napisan je poseban OPC server. Ovaj OPC server ne treba nikakvu slopovsku opremu nego u svom kodu mijenja vrijednosti tag varijabli. Ovakve simulatorske OPC server možete naći kod svih proizvođača OPC servera ali ono što ovaj server razlikuje od njih je to da on u potpunosti simulira mali stvarni proces. To znaći da vi ne morate ručno mijenjati vrijednosti OPC tagova (na strani simulatora) nego se OPC server ponaša kao da je spojen na PLC koji upravlja industrijskim procesom. Radi se o jednostavnom procesu punjenja i pražnjenja spremnika tekućine.</p><p>OPC server QuercusLab.ProcesSimulatorLite.1.0 sadrži sljedće OPC stavke:</p><table border="1"><tbody><tr><td style="text-align: center;"><strong>OPC stavka</strong></td><td style="text-align: center;"><strong>Tip varijable</strong></td><td style="text-align: center;"><strong>Opis</strong></td></tr><tr><td> Tank.AutomaticMode</td><td> VT_Bool (Boolean)</td><td> Mod rada simulatora procesa (ručno/automatski)</td></tr><tr><td> Tank.Level.Value</td><td> VT_I4 (Long Integer)</td><td> Trenutna razina tekućine u spremniku</td></tr><tr><td> Tank.Level.Preset</td><td> VT_I4 (Long Integer)</td><td> Zadana razina tekućine u spremniku</td></tr><tr><td> Tank.Level.Hysteresis</td><td> VT_R4 (FLoat)</td><td> Histereza uključivanja punjenja u postocima</td></tr><tr><td> Tank.SourcePump.ON</td><td> VT_Bool (Boolean)</td><td> Status dobavne pumpe</td></tr><tr><td> Tank.DrainValve.ON</td><td> VT_Bool (Boolean)</td><td> Status ventila za ispuštanje</td></tr></tbody></table><p>Punjenje spremnika ostvaruje se uključivanjem dobavne pumpe  <em>Tank.SourcePump.ON</em>  a pražnjenje uključivanjem ventila za ispuštanje <em>Tank.DrainValve.ON</em>. Razina u spremniku <em>Tank.Level.Value</em> se može kontrolirati  definiranjem stavke <em>Tank.AutomaticMode</em>. Ručni mod omogućava neovisnu kontrolu rada dobavne pumpe i ispusnog ventila. Automatski mod osigurava konstantnu zadanu razinu  <em>Tank.Level.Preset</em>  upravljanjem  radom dobavne pumpe. Dobavna pumpa se uključuje nakon što razina padne ispod zadane za vrijednost definiranog postotka <em>Tank.Level.Hystersis</em> a isključuje kada razina dostigne zadanu vrijednost. Mod rada nema utjecaja na ventil za ispuštanje i on se uvijek može uključivati i isključivati.</p><h4>Visual Baisc 6 HMI aplikacija</h4><p>Izgradnja OPC klijent HMI aplikacije korištenjem VB6 programskog jezika  se može razvrstati na dva osnovna načina:</p><ul><li>pisanje programa korištenjem  osnovnih univerzalnih objekta korisničkog sučelja</li><li>pisanje programa korištenjem specijaliziranih objekta namijenjenih radu sa OPC serverom</li></ul><p>Prvi način zahtjeva više posla jer je potrebno pisanje vlastitih rutina dohvata podataka s OPC servera korištenjem poziva specificiranim u DA Automatizacijskom sučelju. Brigu o dobivenim podacima također mora voditi programer te ih obrađivati i prosljeđivati univerzalnim objektima korisničkog sučelja ili baze podataka. Ovakav način uz svoje nedostatke ima i prednosti u vidu potpune kontrole nad aplikacijom i maksimalne prilagodljivosti klijent aplikacije zahtjevima korisnika. Drugi način oslobađa programera ovih poslova jer se o tome brinu odabrani specijalizirani objekti.  Zadatak programera je da odabere objekte koji će najbolje odgovarati zahtjevima OPC klijent aplikacije, implementira  ih u svoj projekt te ih parametrira. Današnja ponuda takvih objekata je dosta velika i ona uključuje kontrole vizualizacije procesa, obrade i prezentacije alarma, pripreme i implementacije recepata, generiranja izvještaja te kontrole baza podataka. Osnovna prednost ovakvog načina izgradnje OPC klijent aplikacije je brzina izrade i smanjena mogućnost skrivenih grešaka jer su korištene kontrole već prošle testiranje. Negativni aspekti su uniformnost aplikacija i dodatna sredstva za nabavku kontrola koja poskupljuju aplikaciju. Naravno da je moguće i kombinacija ova dva načina tako da se maksimalno iskoriste prednosti i eliminiraju  mane obiju načina</p><h4>Grafičko sučelje &#8211; HMI vizualizacija</h4><p>U ovoj OPC klijent HMI aplikaciji pokazati ćemo upravo taj kombinirani način. Aplikacija će se bazirati isključivo na vizualizaciji procesa i upravljanju osnovnim aktuatorima procesa radi jednostavnosti i boljeg razumijevanja početnicima. Shodno tome i elementi za njenu izgradnju su zaparavo grafički objekti vizualizacije. Kao primjer korištenja gotovih  objekta,koji mogu biti komercijalni ili besplatni,  imat ćemo jednostavne grafičke prekidače i lampice. Ovi objekti su zapravo ActiveX kontrole koje smo razvili isto tako korištenjem Visual Basica te su kompajlirani zasebno.  <a href="http://en.wikipedia.org/wiki/ActiveX">ActiveX</a>  objekt koje ćemo koristi nosi naziv <em>Mini_HMI.ocx</em> i sadrži kontrole <em>qlSwitc</em>h, <em>qlLam</em>p i<em> qlSwitchFaceplate</em>.</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/07/Mini_HMI_ActiveX.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/07/Mini_HMI_ActiveX.png" title="Mini_HMI_ActiveX" class="aligncenter size-full wp-image-927" height="158" width="382" /></a></p><p style="text-align: left;">Drugi način je kreiranje vlastiti kontrola unutar samog programskog koda koji se koriste isto kao i prije opisane komercijalne kontrole. Generiranje ovih kontrola je na način da se u projekt doda takozvani <em>UserControl</em> objekt. <em>UserControl</em> može sadržavati sve što i <em>Form</em> objekt tako da se više standardnih VB kontrola može implementirati u novu, vlastitu. Ponašanje ovakvog objekta unutar HMI aplikacije definirate u programskom kodu.  Programski kod korisničkih kontrola je,  kao i izvršni kod, integralni dio Visual Basic projekta. Programiranje ovih kontrola je , uz neke specifičnosti, identično kao i programiranje ostalih elementa VB6 projekta. Važno je napomenuti da se prilkom kreiranja  UserControl objekta vodi idejom da se on piše što je više moguće  univerzalno da bi se mogao upotrebiti više puta  unutar samog projekta ili na nekim drugim projektima. Dobro napisani UserControl se može izdvojiti iz projekta i iz njega se može kompajlirati ActiveX kontrola koju smo spomenuli prije.  U našoj HMI aplikaciji koristit ćemo UserControl objekt <em>qlTank</em> koji će vizualizirat sam spremnik. Korisnička kontrola se sastoji od dvije  <em>Label</em> kontrole te jedne <em>Shape</em> kontrole. Label kontrole služe za ispis naziva spremnika i ispisa razine tekućine u spremniku dok Shape kontrola predstavlja senzor razine. Sama dinamička vizualizacija razine u spremniku odrađena je korištenjem grafičkih API poziva. Ovaj način programiranja je malo složeniji i zahtjeva  bolje poznavanje programiranja ali omogućava efektivniju i složeniju vizualizaciju. Ako niste vični ovakvom načinu programiranja na raspolaganju su vam milijuni besplatnih <em>UserControl</em> objekta koje možete skinuti s interneta i koristiti prilikom razvoja  vlastite HMI aplikacije.</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/07/UserControl_qlTank.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/07/UserControl_qlTank.png" title="UserControl_qlTank" class="aligncenter size-full wp-image-929" height="476" width="640" /></a></p><p style="text-align: left;">Treći način je da ne koristite ništa od ovoga navedenog nego da svoju HMI aplikaciju gradite korištenjem standardnih kontrola koje dolaze uz VisualBasic 6 i pisanjem programskog koda u osnovnim procedurama.</p><p style="text-align: left;">Kreiranje grafičkog sučelja odnosno vizualizacije započinjete postavljanjem gore navedenih objekta na glavnu (u ovom slučaju i jedinu) formu aplikacije. Prilikom pokretanja VB6 automatski se generiranja jedan <em>Form</em> objekt koji je ujedno i glavni odnosno startni. Po potrebi možete dodavati još formi korištenjem menu komandi <em>Project.AddForm</em> te ih pozivati iz programskog koda u skladu s vašim idejama. Elemente  korisničkog sučelja jednostavno dovlačite iz trake s alatima i postavljate na formu. Prilikom postavljanja automatski se generiraju imena objekta i oni se pojavljuju u tablici na desnoj strani ekrana. Tamo im možete mijenjati nazive kao i većinu svojstava. U traci s alatima se nakon prvog pokretanja mogu naći samo standardne kontrole. U našem slučaju se koristimo s dodatnim kontrolama te ih moramo dodati u traku s alatima. ActiveX kontrole su datoteke s ekstenzijom <em>*.ocx</em> i uobičajno je da se nalaze u sistemskom folderu &#8230;<em>windows/system32  </em>ali će raditi s bilo koje lokacije ako se dobro registriraju. Dakle  nakon što ste kopirali ActiveX datoteku u željeni direktorij potrebno je kontrolu registrirati i to činite tako da odete na  <em>Windows StartButon/Run</em> te u Open upišete  <em>&#8220;regsrv32 &lt;puna putanja/naziv activex datoteke&gt;&#8221;</em>.  Nakon što ste uspješno registrirali ActiveX kontrolu možete ju dodati u traku s alatima tako što će te kliknuti (desni klik)  na traku s alatima i izbrati komandu <em>Components</em>. Na zaslonu će se pojaviti lista svih regsitriranih ActiveX kontrola te će te ju odabrati i kliknuti OK. U našem slučaju će te odabrati &#8220;Quercus Lab mini HMI Components&#8221; i nakon što ste kliknuli Ok gore opisane kontrole odnosno njihove ikone će se pojaviti u traci s alatima.</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/07/RegOcx.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/07/RegOcx.png" title="RegOcx" class="aligncenter size-full wp-image-931" height="332" width="470" /></a></p><p style="text-align: left;">UserControl  ikone se automatski pojavljuju u traci s alatima kada se dodaju u projekt. Dodati se mogu na dva načina. Prvi je da se iz menija aktivira komanda <em>Project/Add UserControl</em> i tada se dodaje korisnička kontrola bez koda. Dakle ovo će te raditi kada želite napraviti novu korisničku kontrolu. U slučaju da ju već imate, bilo iz prijašnjeg projekta ili ste ju skinuli s interneta, dodat će te ju na način da kliknete na <em>Project</em> drvo ( na desnoj strani zaslona) te aktivirate komandu <em>Add/User Control</em> te iz dijaloga <em>Add UserControl/Existing</em> izaberete  datoteku s programskim kodom kontrole.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/07/Add_UserControl.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/07/Add_UserControl.png" title="Add_UserControl" class="aligncenter size-full wp-image-945" height="328" width="604" /></a></p><h4 style="text-align: left;">Spajanja na OPC server</h4><p>Nakon što ste pripremili i kreirali svoje HMI grafičko sučelje možete priječi na pisanje koda za komunikaciju s procesnom opremom. Ovdje se pristup bitno razlikuje od rada na komercijalnim SCADA razvojnim alatima. Ako je kreiranje izgleda grafičkog sučelje bilo slično komunikacijski dio je morate odraditi isključivo pisanjem programskog koda. Još je nešto neophodno da napravite prije samog kodiranja a to je podešavanje komunikacijskog kanala. U VB 6 on može biti isključivo OPC server i moramo u projekt dodati ActivX objekt koji zna komunicirati s njim. Taj objekt se naziva <em> DA Automation Wraper</em>  i može se besplatno skinuti s web stranica OPC fondacije. Kao i kontrole i ovaj wraper se mora prvo registrirati u sustav po gore opisanoj proceduri a tek potom ga se može  dodati u reference projekta. Dodavanje se vrši izborom komande <em>Project/References</em> iz glavnog menija.</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/07/Reg_DAWraper.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/07/Reg_DAWraper.png" title="Reg_DAWraper" class="aligncenter size-full wp-image-937" height="310" width="469" /></a></p><p style="text-align: left;">Sada smo spremni za pisanje koda: Pisanje koda započinjemo u području deklaracija tako da deklariramo neophodne OPC objekte. Radi se o objektima tipa <i>OPCServer</i>, <i>OPCGroups</i> i <i>OPCGroup</i>. Objekte koji imaju događaje deklarirat ćemo s  ključnom riječju <i>WithEvents</i>  da bi mogli koristiti iste. Drugi dio deklaracija odnosi se na varijable u koje spremamo podatke. To će biti varijable tipa polje u koje ćemo spremati nazive tagova (<i>OPCItemIDs</i>), korisničke šifre tagova (<i>OPCItemsClientHandles</i>), serverske šifre (<i>ItemServerHandles</i>) te greške prilikom transakcija s OPC serverom (<i>ItemServerErrors</i>). Na kraju dodajemo ostale varijable koje će služiti u algoritmima prezentacije podataka.</p><div class="wp_syntax"><table><tr><td class="code"><pre class="vb" style="font-family:monospace;"><span style="color: #151B8D; font-weight: bold;">Dim</span> <span style="color: #8D38C9; font-weight: bold;">WithEvents</span> simOPCServer  <span style="color: #151B8D; font-weight: bold;">As</span> OPCServer
<span style="color: #151B8D; font-weight: bold;">Dim</span> simGroups <span style="color: #151B8D; font-weight: bold;">As</span> OPCGroups
<span style="color: #151B8D; font-weight: bold;">Dim</span> <span style="color: #8D38C9; font-weight: bold;">WithEvents</span> simOPCGroup <span style="color: #151B8D; font-weight: bold;">As</span> OPCGroup
<span style="color: #151B8D; font-weight: bold;">Dim</span> OPCItemCollection <span style="color: #151B8D; font-weight: bold;">As</span> OPCItems
&nbsp;
<span style="color: #151B8D; font-weight: bold;">Dim</span> OPCItemCount <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Integer</span>                         <span style="color: #008000;">' količina opc stavki
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> OPCItemIDs() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">String</span>                          <span style="color: #008000;">' polje identifikacijskih oznaka (naziva) stavki
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> OPCItemsClientHandles() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>                 <span style="color: #008000;">' polje šifri stavki definiranih od strane klijenta
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> ItemServerHandles() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>                     <span style="color: #008000;">' polje šifri stavki definiranih od strane servera
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> ItemServerErrors() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>                      <span style="color: #008000;">' polje za spremanje greški servera
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> RemoveItemServerErrors() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>                <span style="color: #008000;">'
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> WriteServerHandles() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>                    <span style="color: #008000;">' polje za upis stavki na opc server - serverska sifra
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> ItemsValue() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Variant</span>                         ' polje za vrijednosti stavki</pre></td></tr></table></div><p>Nakon što smo deklarirali neophodne varijable OPC objekte potrebno je na početku izvršavanja programa i kreirati ih. To  ćemo  napraviti u događaju <em>Form _Load</em>:</p><div class="wp_syntax"><table><tr><td class="code"><pre class="vb" style="font-family:monospace;"><span style="color: #E56717; font-weight: bold;">Private</span> <span style="color: #E56717; font-weight: bold;">Sub</span> Form_Load()
<span style="color: #008000;">' EVENT: kada se ucita form (prakticki na pocetku programa)
</span>
<span style="color: #151B8D; font-weight: bold;">Set</span> simOPCServer = <span style="color: #E56717; font-weight: bold;">New</span> OPCServer                                <span style="color: #008000;">' kreira se objekt OPCServer
</span><span style="color: #E56717; font-weight: bold;">Call</span> OPC_Connect(<span style="color: #800000;">&quot;QuercusLab.ProcesSimulatorLite.1.0&quot;</span>)          <span style="color: #008000;">' poziv potprograma spajanja na OPC server
</span><span style="color: #E56717; font-weight: bold;">Call</span> OPCValue_Init                                              <span style="color: #008000;">' poziv potprograma inicijalizacije vrijednosti procesa
</span>
<span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #E56717; font-weight: bold;">Sub</span></pre></td></tr></table></div><p>Za spajanje i prekid veze s OPC serverom pisat ćemo posebne procedure i onda ih pozivati po potrebi. Procedura za spajanje naziva se OPC_Connect a kao parametar prosljeđujemo naziv OPC servera.  Pozivom metode <em>simOPCServer</em><em>.Connect</em> spajamo se na isti. Slijedi kreiranje OPCGruop objekta te definiranje njegovih svojstava. Neophodno je kreirati bar jednu OPC grupu metodom <em> simGroups .Add(&#8220;Tank&#8221;)</em> te definirati vrijeme osvježavanja podataka svojstvom <em>simGroups.UpdateRate.</em>  Potom ćemo proglasiti grupu aktivnom s svojstvom <em>simGroups.DefaultGroupIsActive = True</em>. Želimo li zaprimati podatke svaki puta kada se promjene vrijednosti tagova definirati ćemo to svojstvom <em>simGroups.IsSubscribed = True</em>. Dodavanje tagova (u OPC terminologiji <em>Items</em>&#8211; stavki) započinjemo dimenzioniranjem polja u koja spremamo simboličke nazive i korisničke  šifre tagova.  Nazive spremamo u u polje <i>OPCItemIDs</i> a korisničke šifre u polje <i>OPCItemClientHandles</i>. Završetak dodavanje tagova je pozivanje metode<i> OPCItemCollection.OPCItems.AddItems</i>  a parametri koji su neophodni su broj stavki (broj članova definiranih polja), polje s nazivima stavki (<i>OPCItemsIDs</i>), polje s korisničkim šiframa (<em>OPCItem</em><i>ClientHandles)</i>, polje serverskih šifri (<i>ItemServerHandles)</i> te polje za eventualne greške prilikom transakcije (<i>ItemsServerErrors</i>). Polje serverski šifre je prazno polje koje dimenzionira server i u njega upisuje vlastite šifre naših tagova koje korespondiraju indeksom s korisničkim šiframa.</p><div class="wp_syntax"><table><tr><td class="code"><pre class="vb" style="font-family:monospace;"><span style="color: #E56717; font-weight: bold;">Private</span> <span style="color: #E56717; font-weight: bold;">Sub</span> OPC_Connect(<span style="color: #151B8D; font-weight: bold;">ByVal</span> OPC_ServerName <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">String</span>)
<span style="color: #008000;">' PODPROGRAM: SPAJANJE NA OPC SERVER
</span><span style="color: #008000;">' aktiviram OPCserver objekt , spajam se na njega i dodajem (prijavljujem) tagove
</span>
simOPCServer.Connect (OPC_ServerName)                   <span style="color: #008000;">' spajanje na OPC server
</span>
<span style="color: #151B8D; font-weight: bold;">Set</span> simGroups = simOPCServer.OPCGroups                  <span style="color: #008000;">' kreira se objekt OPCGroups
</span>simGroups.DefaultGroupIsActive = <span style="color: #00C2FF; font-weight: bold;">True</span>                   <span style="color: #008000;">' objekt aktivan
</span>simGroups.DefaultGroupDeadband = 0                      <span style="color: #008000;">' definicija &quot;mrtvog pojasa&quot; analognih stavki (globalno)
</span>
<span style="color: #151B8D; font-weight: bold;">Set</span> simOPCGroup = simGroups.Add(<span style="color: #800000;">&quot;Tank&quot;</span>)                 <span style="color: #008000;">' kreira se objekt OPCGroup s nazivom &quot;Tank&quot;
</span>simOPCGroup.UpdateRate = 300   <span style="color: #008000;">' milisekunda            ' period osvježavanja podataka  u milisekundama
</span>simOPCGroup.DeadBand = 0                                <span style="color: #008000;">' definicija &quot;mrtvog pojasa&quot; analognih stavki
</span>simOPCGroup.IsSubscribed = <span style="color: #00C2FF; font-weight: bold;">True</span>                         <span style="color: #008000;">' pretplate stavki aktivne
</span>
<span style="color: #151B8D; font-weight: bold;">Set</span> OPCItemCollection = simOPCGroup.OPCItems            <span style="color: #008000;">' kreira se objekt OPCItems
</span>OPCItemCollection.DefaultIsActive = <span style="color: #00C2FF; font-weight: bold;">True</span>                <span style="color: #008000;">' objekt aktivan
</span>
<span style="color: #008000;">' priprema  polja stavki za dodavanje na OPC server
</span>OPCItemCount = 6                                        <span style="color: #008000;">' broj stavki
</span><span style="color: #151B8D; font-weight: bold;">ReDim</span> OPCItemIDs(6)                                     <span style="color: #008000;">' dimenzioniranje polja naziva stavki
</span><span style="color: #151B8D; font-weight: bold;">ReDim</span> OPCItemsClientHandles(6)                          <span style="color: #008000;">' dimenzioniranje polja šifri stavki
</span><span style="color: #008000;">' definiranje stavki
</span>OPCItemsClientHandles(1) = 1: OPCItemIDs(1) = <span style="color: #800000;">&quot;Tank.Level.Value&quot;</span>         <span style="color: #008000;">'
</span>OPCItemsClientHandles(2) = 2: OPCItemIDs(2) = <span style="color: #800000;">&quot;Tank.Level.Preset&quot;</span>
OPCItemsClientHandles(3) = 3: OPCItemIDs(3) = <span style="color: #800000;">&quot;Tank.Level.Hysteresis&quot;</span>
OPCItemsClientHandles(4) = 4: OPCItemIDs(4) = <span style="color: #800000;">&quot;Tank.SourcePump.ON&quot;</span>
OPCItemsClientHandles(5) = 5: OPCItemIDs(5) = <span style="color: #800000;">&quot;Tank.DrainValve.ON&quot;</span>
OPCItemsClientHandles(6) = 6: OPCItemIDs(6) = <span style="color: #800000;">&quot;Tank.AutomaticMode&quot;</span>
&nbsp;
<span style="color: #008000;">' dodavanje stavki na server
</span><span style="color: #008000;">' OPCItemCount - broj stavki  koje se  dodaju
</span><span style="color: #008000;">' ItemsIDs - polje s nazivima tagova
</span><span style="color: #008000;">' OPCItemsClientHandles - polje s siframa stavki definirani od strane klijenta
</span><span style="color: #008000;">' ItemServerHandles - polje u koje ce OPC server upisati (vratiti) serverske sifre stavki
</span><span style="color: #008000;">' (ove sifre ce se koristiti prilikom upisa vrijednosti tagova na OPC server)
</span><span style="color: #008000;">' ItemServerErrors - polje u koje ce server upisati eventualne greske prilkom ove transakcije
</span>OPCItemCollection.AddItems OPCItemCount, OPCItemIDs, OPCItemsClientHandles, ItemServerHandles, ItemServerErrors
&nbsp;
<span style="color: #008000;">' ako je nesto poslo krivo ispisujem gresku i zaustavlja aplikaciju
</span><span style="color: #8D38C9; font-weight: bold;">For</span> i = <span style="color: #151B8D; font-weight: bold;">LBound</span>(ItemServerErrors) <span style="color: #8D38C9; font-weight: bold;">To</span> <span style="color: #151B8D; font-weight: bold;">UBound</span>(ItemServerErrors)
    <span style="color: #8D38C9; font-weight: bold;">If</span> ItemServerErrors(i) &amp;lt;&amp;gt; 0 <span style="color: #8D38C9; font-weight: bold;">Then</span>
        MsgBox <span style="color: #800000;">&quot;Greška prilkom dodavanja stavki na OPC server!&quot;</span> &amp;amp; OPCItemIDs(i), vbOKOnly, <span style="color: #800000;">&quot;Error&quot;</span>
        Unload Me
        <span style="color: #151B8D; font-weight: bold;">Stop</span>
    <span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #8D38C9; font-weight: bold;">If</span>
<span style="color: #8D38C9; font-weight: bold;">Next</span>
<span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #E56717; font-weight: bold;">Sub</span></pre></td></tr></table></div><h4>Primanje i slanje podataka</h4><p>Zahvaljujući tome što smo se prilikom spajanja pretplatili (<em>.IsSusctibed=True</em>) na podatke ne trebamo provjeravati stanje vrijednosti tagova. OPC server će svaki put kada se vrijednost bilo kojega taga promjeni generirati događaj <em>DataChange</em> i proslijediti nam nove vrijednosti. Prosljeđuje se broj stavki <em>NumItems</em> (praktički broj elementa polja podataka), polje s šiframa stavki <em>ClientHandles</em>, polje s vrijednostima tagova <em>ItemValues</em>, polje s kvalitetom veze <em>Qualities</em>, polje s vremenom očitanja <em>TimeStamps</em> te oznake transakcije <em>TransactionID</em>. Na nama je zadatak  da prođemo kroz polje korisnički šifri, dekodiramo tagove te vrijednosti istih ispišemo u kontrole na našem ekranu. To uobičajno činimo koristeći se <em>Case</em> petljom za dekodiranje i <em>For&#8230;Next</em> petljom za provjeru svih članova polja.</p><div class="wp_syntax"><table><tr><td class="code"><pre class="vb" style="font-family:monospace;"><span style="color: #E56717; font-weight: bold;">Private</span> <span style="color: #E56717; font-weight: bold;">Sub</span> simOPCGroup_DataChange(<span style="color: #151B8D; font-weight: bold;">ByVal</span> TransactionID <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>, <span style="color: #151B8D; font-weight: bold;">ByVal</span> NumItems <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>, ClientHandles() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>, ItemValues() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Variant</span>, Qualities() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>, TimeStamps() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Date</span>)
<span style="color: #008000;">' EVENT: kada se promjeni stanje &quot;pretplacenih&quot; tagova OPC server generira ovaj event i salje vrijednosti tih tagova
</span><span style="color: #008000;">' NumItems - broj (kolicina) tagova
</span><span style="color: #008000;">' ClinetHandles() - korisnicke sifre tagova
</span><span style="color: #008000;">' ItemsValue() - vrijednosti tagova
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> i <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Integer</span>
&nbsp;
<span style="color: #008000;">' obrada svih tagova
</span><span style="color: #8D38C9; font-weight: bold;">For</span> i = 1 <span style="color: #8D38C9; font-weight: bold;">To</span> NumItems
    <span style="color: #008000;">'Debug.Print ClientHandles(i)
</span>    <span style="color: #008000;">'Debug.Print
</span>    <span style="color: #8D38C9; font-weight: bold;">Select</span> <span style="color: #8D38C9; font-weight: bold;">Case</span> ClientHandles(i)
    <span style="color: #8D38C9; font-weight: bold;">Case</span> 1
        Me.tnkMain.Value = ItemValues(i)
        <span style="color: #8D38C9; font-weight: bold;">If</span> Me.tnkMain.Maxlevel = <span style="color: #00C2FF; font-weight: bold;">True</span> <span style="color: #8D38C9; font-weight: bold;">Or</span> Me.tnkMain.MinLevel = <span style="color: #00C2FF; font-weight: bold;">True</span> <span style="color: #8D38C9; font-weight: bold;">Then</span>
            Me.lmpAlarm.Value = <span style="color: #00C2FF; font-weight: bold;">True</span>
            <span style="color: #8D38C9; font-weight: bold;">If</span> Me.tnkMain.Maxlevel = <span style="color: #00C2FF; font-weight: bold;">True</span> <span style="color: #8D38C9; font-weight: bold;">Then</span> Me.labAlarmText.Caption = <span style="color: #800000;">&quot;Razina iznad dozvoljene&quot;</span>
            <span style="color: #8D38C9; font-weight: bold;">If</span> Me.tnkMain.MinLevel = <span style="color: #00C2FF; font-weight: bold;">True</span> <span style="color: #8D38C9; font-weight: bold;">Then</span> Me.labAlarmText.Caption = <span style="color: #800000;">&quot;Razina ispod dozvoljene&quot;</span>
        <span style="color: #8D38C9; font-weight: bold;">Else</span>
            Me.lmpAlarm.Value = <span style="color: #00C2FF; font-weight: bold;">False</span>: Me.labAlarmText.Caption = <span style="color: #800000;">&quot;&quot;</span>
        <span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #8D38C9; font-weight: bold;">If</span>
    <span style="color: #8D38C9; font-weight: bold;">Case</span> 2
        Me.txtlevelPreset.Text = Str(ItemValues(i))
    <span style="color: #8D38C9; font-weight: bold;">Case</span> 3
        Me.txtHystersis.Text = Str(ItemValues(i))
    <span style="color: #8D38C9; font-weight: bold;">Case</span> 4
        Me.lmpSourcePump.Value = ItemValues(i)
        <span style="color: #E56717; font-weight: bold;">Call</span> SourcePipeAnimation(ItemValues(i))
    <span style="color: #8D38C9; font-weight: bold;">Case</span> 5
        Me.lmpDrainValve.Value = ItemValues(i)
        <span style="color: #E56717; font-weight: bold;">Call</span> DrainPipeAnimation(ItemValues(i))
    <span style="color: #8D38C9; font-weight: bold;">Case</span> 6
        Me.swfAutomatic.LampValue = ItemValues(i)
    <span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #8D38C9; font-weight: bold;">Select</span>
<span style="color: #8D38C9; font-weight: bold;">Next</span> i
&nbsp;
<span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #E56717; font-weight: bold;">Sub</span></pre></td></tr></table></div><p>Želimo li promjeniti vrijednost neke stavke na raspolaganju su nam funkcije za sinkroni i asinkroni  upis. Sinkroni upis ćemo napravit funkcijom <em>SyncWrite</em> dok su nam parametri: broj stavki koje upisujemo , polje s serverskim šiframa, polje s vrijednostima stavki i polje za eventualne greške prilikom ove operacije. Ovdje valja primjetiti da se kao parametar koriste serverske a ne korisničke šifre stavki. Serverske šifre su upravo one koje nam je OPC server vratio prilkom dodavanja naši korisničkih šifri. U našem primjeru na početku programa u OPC server zapisujemo inicijalna stanja nekih stavki da bi nam simulator počeo raditi  a to radimo u proceduri <em>OPCValue_Init</em>.</p><div class="wp_syntax"><table><tr><td class="code"><pre class="vb" style="font-family:monospace;"><span style="color: #E56717; font-weight: bold;">Private</span> <span style="color: #E56717; font-weight: bold;">Sub</span> OPCValue_Init()
<span style="color: #008000;">' PODPROGRAM : POCETNE POSTAVKE
</span><span style="color: #008000;">' upisujem u OPC server zadanu vrijednost
</span>
<span style="color: #151B8D; font-weight: bold;">ReDim</span> WriteServerHandles(3): <span style="color: #151B8D; font-weight: bold;">ReDim</span> ItemsValue(3)
WriteServerHandles(1) = ItemServerHandles(2): ItemsValue(1) = 1900                          <span style="color: #008000;">' &quot;Tank.LevelPreset&quot; = 1900
</span>WriteServerHandles(2) = ItemServerHandles(3): ItemsValue(2) = 80                            <span style="color: #008000;">' &quot;Tank.LevelHysteresis&quot; = 80
</span>WriteServerHandles(3) = ItemServerHandles(6): ItemsValue(3) = Me.swfAutomatic.SwitchValue   <span style="color: #008000;">' &quot;Tank.AutomaticMode&quot; = stanje prekidaca MAN-AUTO
</span><span style="color: #008000;">' sinkrono zapisivanje vrijednosti
</span><span style="color: #008000;">' 3 - broj stavki
</span><span style="color: #008000;">' WriteServerHandles - polje s siframa definiranim od servera
</span><span style="color: #008000;">' ItemsValue - polje se definiranim novim vrijednostima
</span><span style="color: #008000;">' ItemServerErrors - polje s greškama prilkom zapisivanja
</span>simOPCGroup.SyncWrite 3, WriteServerHandles, ItemsValue, ItemServerErrors
<span style="color: #008000;">' obrada greske
</span><span style="color: #8D38C9; font-weight: bold;">For</span> i = <span style="color: #151B8D; font-weight: bold;">LBound</span>(ItemServerErrors) <span style="color: #8D38C9; font-weight: bold;">To</span> <span style="color: #151B8D; font-weight: bold;">UBound</span>(ItemServerErrors)
    <span style="color: #8D38C9; font-weight: bold;">If</span> ItemServerErrors(i) &amp;lt;&amp;gt; 0 <span style="color: #8D38C9; font-weight: bold;">Then</span>
        MsgBox <span style="color: #800000;">&quot;Greška prilkom dodavanja stavki na OPC server!&quot;</span>, vbOKOnly, <span style="color: #800000;">&quot;Error&quot;</span>
    <span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #8D38C9; font-weight: bold;">If</span>
<span style="color: #8D38C9; font-weight: bold;">Next</span>
<span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #E56717; font-weight: bold;">Sub</span></pre></td></tr></table></div><p>Na kraju rada  neophodno je da se uredno odjavimo s OPC servera. Ovdje ćemo to ućiniti u događaju Form_Unload. Brisanje stavki  radimo metodom <em>simOPCGroup.OPCItems.Remove</em> a grupe <em>simGroups.Remove</em>. Na kraju oslobodimo memoriju brisanjem objekta koje smo koristili.</p><div class="wp_syntax"><table><tr><td class="code"><pre class="vb" style="font-family:monospace;"><span style="color: #E56717; font-weight: bold;">Private</span> <span style="color: #E56717; font-weight: bold;">Sub</span> Form_Unload(Cancel <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Integer</span>)
<span style="color: #008000;">' EVENT: prije nego se program završi
</span>
<span style="color: #151B8D; font-weight: bold;">Dim</span> RemoveItemServerErrors() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>
<span style="color: #008000;">' brišemo naše prijavljenje stavke sa servera
</span><span style="color: #008000;">' 6 - broj stavki koje brišemo (sve!)
</span><span style="color: #008000;">' ItemServerHandles - polje serverskih šifri koje brisemo
</span><span style="color: #008000;">' RemoveItemServerErrors - polje s greskama kod brisanja
</span>simOPCGroup.OPCItems.Remove 6, ItemServerHandles, RemoveItemServerErrors
<span style="color: #008000;">' brišemo korištenu grupu
</span><span style="color: #008000;">' brišemo korištene objekte za grupu
</span>simGroups.Remove (<span style="color: #800000;">&quot;Tank&quot;</span>)
<span style="color: #151B8D; font-weight: bold;">Set</span> simOPCGroup = <span style="color: #00C2FF; font-weight: bold;">Nothing</span>
<span style="color: #151B8D; font-weight: bold;">Set</span> simGroups = <span style="color: #00C2FF; font-weight: bold;">Nothing</span>
<span style="color: #008000;">' odspajamo se sa server
</span><span style="color: #008000;">' brišemo objekt za server
</span>simOPCServer.Disconnect
<span style="color: #151B8D; font-weight: bold;">Set</span> simOPCServer = <span style="color: #00C2FF; font-weight: bold;">Nothing</span>
<span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #E56717; font-weight: bold;">Sub</span></pre></td></tr></table></div><p>Ovo će biti dovoljno za osnovnu komunikaciju vaše HMI aplikacije i procesnog računala a dalje je na vama da ju nadogradite s željenom, odnosno potrebnom, funkcionalnošću koristeći se standardnim i dodatnim VB6 rutinama.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/09/VB_OPCClient_Screen1.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/09/VB_OPCClient_Screen1.png" title="VB_OPCClient_Screen" class="aligncenter size-full wp-image-1003" height="382" width="640" /></a></p><h4>Preuzimanje</h4><p>Ovdje su opisane samo one programske rutine koje se tiću OPC servera dok  rad sa VB objektima možete vidjeti u programskom kodu. Sve potrebno, uključujući i OPC Srever ProcesSimulatorLite.1.0, da pokušate napraviti vlastiti VB6 OPC klijent ili samo da vidite kako se to radi   možete skinuti ovdje: <a href="/wp-content/uploads/2012/09/vb6clientsetup.exe">VB6ClientSetup.exe</a></p><p>Za pokretanje OPC servera ProcesSimulatorLite.1.0 potrebno je imati instaliran NET Framework3.5 kojega možete skinuti sa službenih Microsoftovih stranica: <a href="http://www.microsoft.com/en-us/download/confirmation.aspx?id=21">dotNetFx35setup.exe</a></p><p>Ako nemate instaliran Visual Basic 6 razvojni  paket za pokretanje iskompajliranog primjera bit će vam potreban VB6 Runtime koji možete skinuti ovdje: <a href="http://download.microsoft.com/download/vb60pro/install/6/Win98Me/EN-US/VBRun60.exe">VBRun60.exe</a></p> ]]></content:encoded> </item> <item><title>OPC Data Access server</title><link>http://www.quercus-lab.com/opc-data-acces-server/</link> <pubDate>Thu, 26 Apr 2012 05:35:42 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Automatizacija]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=795</guid> <description><![CDATA[OPC Data Access server je najvažnija i najkorištenija OPC  specifikacija do sada. Smatra se da je oko 99% implementacija OPC tehnologije upravo ovo sučelje.  OPC DA server  omogućava razmjenu informacija u realnom vremenu  između uređaja u polju (procesu) kao što su PLC, DCS ili PAC, sustava za kontrolu  i nadzor  kao što su HMI, SCADA [&#8230;]]]></description> <content:encoded><![CDATA[<p>OPC <a href="http://www.quercus-lab.com/wp-content/uploads/2012/03/OPC_DA_logo.png"><img class="size-full wp-image-845 alignleft" title="OPC_DA_logo" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/03/OPC_DA_logo.png" width="180" height="130" /></a>Data Access server je najvažnija i najkorištenija OPC  specifikacija do sada. Smatra se da je oko 99% implementacija OPC tehnologije upravo ovo sučelje.  OPC DA server  omogućava razmjenu informacija u realnom vremenu  između uređaja u polju (procesu) kao što su PLC, DCS ili PAC, sustava za kontrolu  i nadzor  kao što su <a href="http://en.wikipedia.org/wiki/HMI">HMI</a>, <a href="http://en.wikipedia.org/wiki/SCADA">SCADA</a> ili operatorski paneli. Dodatna funkcionalnost je mogućnost razmjene informacija između samih sustava automatizacije različitih proizvođača.   Arhitektura OPC DA Servera  je <a href="http://en.wikipedia.org/wiki/Client%E2%80%93server_model">klijent-server model</a>  gdje  OPC Server komponenta koja osigurava sučelje ka OPC objektima i upravlja sa njima. OPC klijent aplikacija komunicira sa OPC poslužiteljem preko spomenutih sučelja.</p><h4>OPC DA sučelje (interface)</h4><p>OPC tehnologija se temelji na  Microsoft OLE (<i>ActiveX)</i> tehnologiji i komunikacijskim modelima COM (<a href="http://en.wikipedia.org/wiki/Component_Object_Model"><i>Component Object Model</i></a>) i DCOM (<a href="http://en.wikipedia.org/wiki/Distributed_Component_Object_Model"><i>Distributed Component Object Model</i></a>). OPC sadrži standardni set sučelja, svojstva i metoda koje se koriste u aplikacijama kontrola procesa i automatizacije. OLE/COM tehnologije definiraju se kako individualne programske komponente koje mogu međudjelovati i dijeliti podatke.</p><p>OPC specifikacije sadrže dva seta sučelja:</p><ol><li>Prilagođeno  sučelje (<i>Custom Interface</i>)</li><li>Automatizacijsko sučelje (<i>Automation Interface</i>)</li></ol><p>OPC poslužitelji moraju implementirati prilagođeno sučelje i opcijski  mogu implementirati automatizacijska  sučelja.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_Interface.png"><img class="aligncenter" title="OPC_Interface" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_Interface.png" width="656" height="289" /></a></p><p>U neki m slučajevima OPC Foundation  osigurava omotnicu (<em>wrap</em><em>per</em>) za standardno automatizacijsko sučelje . Ovaj <em>wrapperDLL</em> može biti korišten za bilo koji specifični proizvođački  (<em>Vendor</em>) poslužitelj.  Općenito, OPC klijent programi koji se kreiraju koristeći skriptno bazirane programske jezike će koristiti automatizacijsko sučelje. Klijent programi koji su kreirani u C++ će lakše koristiti prilagođeno sučelje za postizanje najbolje performanse.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/03/OPC_wraperDLL.png"><img class="aligncenter size-full wp-image-868" title="OPC_wraperDLL" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/03/OPC_wraperDLL.png" width="629" height="278" /></a></p><p>Ono što ovaj standard želi definirati je zajednički način na koji aplikacije u oblasti upravljanja i vođenja procesa mogu pristupiti podacima o procesu. Automatizacijsko sučelje treba osigurati istu funkcionalnost kao i prilagođeno (<i>Custom</i>) sučelje, ali na način koji je blizak trendovima u načinu programiranja  u automatizaciji. Osnovni cilj dizajna sučelja je da radi kao omotnica (<i>wrapper</i>) za <i>OPC DataAcces Custom Interface</i> te da osigurava pogodan mehanizam funkcionalnosti. Klijent koji koristi <i>OPC Data Automation</i> sučelje koristi wrapper DLL kao sponu ka <i>OPC Data Custom Interface</i> serveru. Na ovaj način bilo koja aplikacija koja ima <em>OLE Automation Interface</em> funkcionalnost (<i>VBA,VB.Net, Delphi,  Excel</i>) ima mogućnost pristupa lokalnom OPC serveru  a preko wraper-a udaljenom <i>OPC Custom Interface</i> serveru.</p><h4><b>OPC DA Server  model<br /> </b></h4><p><i>OPCServer</i> objekt je osnovna instanca OPC poslužitelja. Korisnik mora kreirati <i>OPCServer</i> objekt  prije nego se mogu dobiti reference za druge objekte. Sadrži <i>OPCGroups</i> kolekciju i kreira <i>OPCBrowser</i> objekte.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/03/opc_DA_model.png"><img class="aligncenter size-full wp-image-865" title="opc_DA_model" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/03/opc_DA_model.png" width="622" height="303" /></a></p><h4></h4><h4>OPCServer objekt</h4><p><i>OPCServer</i> objekt osigurava  korisniku pristupi (za čitanje i pisanje) ili komunikaciju sa skupom izvora podataka. Tipovi izvora koji su na raspolaganju su funkcija implementacije poslužitelja. OPC Automation klijent se povezuje sa OPC Automation serverom koji komunicira sa izvorom podataka (odnosno sa DA Serverima), putem funkcionalnosti koju osiguravaju automatizacijski objekti koji su opisani u ovom standardu. <i>OPCServer</i> osigurava jedan <i>OPCGroups</i> objekt za Automation kolekciju da bi održavao sakupljanje <i>OPCGroup</i> objekata. Korisnik pristupa poslužitelju izvršavajući <i>OPCServer.Connect</i> metodu birajući jedan od dostupnih OPC poslužitelja čiju listu može dobiti pomoću <i>OPCServer.GetOPCServers</i> metode. Nakon uspješnog pristupa dostupna su mu podaci o karakteristici, statusu i postavkama izabranog poslužitelja kao što su verzija poslužitelja, proizvođač, ime poslužitelja i slično. Od događaja dostupan je samo jedan, <i>OPCServer.ServerShutDown</i>, koji obavještava da poslužitelj nije više dostupan.</p><h4> OPC Browser objekt</h4><p>Objekt  koji  izlistava  (brows-a)  imena  stavki  (items)  u  konfiguraciji  poslužitelja.  Postoji  samo  jedna  instanca  <em>OPCBrowser </em> objekta  za  instancu  <em>OPCServer</em>  objekta.  Ako  server  ne  podržava  izlistavanje  <em>CreateBrowser</em>  metoda <em>OPCServer</em>  objekta  neće  kreirati  ovaj  objekt.    Korisnik  su  dostupna  eventualna  hijerarhijska  organizacija  stavki  pomoću  <em>OPCBrowser.ShowBranches</em>  i  <em>OPCBrowser.ShowLeafs</em>  metoda  kao  i  navigacija  kroz  istu  metodama <em>OPCBrowser.MoveToRoot</em>, <em>OPCBrowser.MoveUp</em>, <em>OPCBrowser.MoveDown</em> i <em>OPCBrowser.MoveTo</em> metodama</p><h4>OPCGroups i OPCGroup objekt</h4><p><i>OPCGroups</i> objekt je automatizacijska kolekcija koja sadrži sve<i> OPCGroup</i> objekte. Ovaj objekt klijent kreirao unutar opsega <i>OPCServera</i> sa kojim se automatizacijska  aplikacija povezala putem <i>OPCServer.Connect</i> metode. Osigurava korisniku dodavanje, modificiranje i upravljanje s kolekcijom <i>OPCGrup</i> objekta. <i><br /> </i></p><p><i>OPCGroup</i> objekt je instanca <i>OPCGroups</i> objekta. Namjena ovog objekta je održavanje informaciju o stanju i osiguranje mehanizma kreiranja servisa akvizicije podataka za <i>OPCItem Collection</i> objekta koji <i>OPCGroup</i> objekt referencira. Korisnik dodaje novu grupu u kolekciju metodom <i>OPCGruop.Add</i>. Nakon  toga može svojstvom <i>OPCGroup.IsActive</i> kontrolirati status dostupnih podataka unutar grupe. Pomoću  svojstva <i>OPCGroup.IsSubscribed</i> se korisnik preplaćuje na asinkrono primanje podatak kada se promjeni vrijednost odabranih stavki na poslužitelju. Promjena vrijednosti inicira aktiviranje <i>OPCGroup.DataChange</i> događaja te se servisiranjem istog zaprimaju vrijednosti promijenjenih podataka. Definiranjem svojstva <i>OPCGropu.UpdataRate</i> kontrolira se period sinkrone razmjene (<i>Read/Write</i>) odabranih podataka u milisekundama. Razmjena se ostvaruje <i>OPCGroup.SincWrite</i> i <i>OPCGroup.SincRead</i> metodama. Asinkrona razmjena podataka moguća je metodama <i>OPCGroup.AsincRead</i>, <i>OPCGroup.AsincWrite</i> te     <i>OPCGroup.AsincRefresh</i> metodama. Završetkom asinkrone razmjene podataka generiraju se događaji <i>OPCGroupe.AsincReadComplete</i> i <i>OPCGroup.AsincWriteComplete</i>.</p><h4>OPCItems i OPCItem objekt</h4><p><i>OPCItems</i> je  kolekcija koja sadrži sve <i>OPCItem</i> objekte koje  klijent kreira unutar opsega <i>OPCServer-a</i>, i odgovarajućeg <i>OPCGroup</i> objekta koji je automatizacijska aplikacija kreirala.<i> OPCItem</i> je Automation objekt koji održava definiciju stavki (<i>Item-a</i>), trenutnu vrijednost, statusnu informaciju i posljednje vrijeme ažuriranja (<i>Update</i>).</p><h4>OPC DA tipovi podataka</h4><p>Kao što je spomenuto u početki OPC koristi COM a osnovni tip podataka u njemu je <a href="http://en.wikipedia.org/wiki/Variant_type">Variant</a>. Variant je tip  podataka duljine 16 byte koji u sebi može sadržavati većinu ostalih   tipova. Prva dva byta su cijelobrojni podaci koji definiraju tip podataka koji su pohranjeni od 7 do 15 byte.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/04/OPC_DA_variant.png"><img class="aligncenter size-full wp-image-882" title="OPC_DA_variant" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/04/OPC_DA_variant.png" width="557" height="81" /></a></p><p>Svi OPC serveri podržavaju slijedeće tipove Variant podataka:</p><table border="1"><tbody><tr><td style="text-align: center;">Tip</td><td style="text-align: center;">Podaci u bytovima 8 do 15</td><td style="text-align: center;">Opis vrijednosti koji VARIANT vrača</td></tr><tr><td> VT_I1</td><td> 1-byte signed integer</td><td> Cijelobrojna vrijednost  duljine 1 byta</td></tr><tr><td> VT_I2</td><td> 2-byte signed integer</td><td> Cijelobrojna vrijednost  duljine 2 byta</td></tr><tr><td> VT_I4</td><td> 4-byte signed integer</td><td> Cijelobrojna vrijednost  duljine 4 byta</td></tr><tr><td> VT_UI1</td><td> 1-byte unsigned integer</td><td> Pozitivna cijelobrojna vrijednost duljine 1 byta</td></tr><tr><td> VT_UI2</td><td> 2-byte unsigned integer</td><td> Pozitivna cijelobrojna vrijednost duljine 2 byta</td></tr><tr><td> VT_UI4</td><td> 4-byte unsigned integer</td><td> Pozitivna cijelobrojna vrijednost duljine 4 byta</td></tr><tr><td> VT_R4</td><td> 4-byte IEEE floating-point number</td><td> Realna vrijednost  duljine 4 byta</td></tr><tr><td> VT_R8</td><td> 8-byte IEEE floating-point number</td><td> Realna vrijednost  duljine 8 byta</td></tr><tr><td> VT_CY</td><td> CURRENCY type</td><td> Novčana vrijednostima s decimalnim zarezom</td></tr><tr><td> VT_DATE</td><td> DATE type</td><td> Datum i vrijeme</td></tr><tr><td> VT_BSTR</td><td> BSTR type</td><td> String koji počinje s oznakom duljine a završava s  null karakterom</td></tr><tr><td> VT_BOOL</td><td> VARIANT_BOOL type</td><td> Logička vrijednost TRUE ili FALSE</td></tr></tbody></table><p>&nbsp;</p> ]]></content:encoded> </item> <item><title>OPC tehnologija</title><link>http://www.quercus-lab.com/opc-tehnologija/</link> <pubDate>Sat, 25 Feb 2012 16:21:45 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Automatizacija]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=418</guid> <description><![CDATA[Dosadašnji sustavi automatizacije podrazumijevali su komunikacije između uređaja na razini automatizacije u polju i nadzornih sustava koji su se temeljili na komunikacijskim protokolima svojstvenim sklopovlju uređaja koje povezuju. Takav način povezivanja zahtijevao je isporuku ili izradu specifičnih komunikacijskih programskih sučelja (software driver-a) za svaki uređaj u sustavu. Zbog toga je krajnji kupac kupovao skup sustav [&#8230;]]]></description> <content:encoded><![CDATA[<p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/Opc_logo.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/01/Opc_logo.png" alt="" title="Opc_logo" class="alignleft size-full wp-image-574" height="135" width="180" /></a>Dosadašnji sustavi automatizacije podrazumijevali su komunikacije između uređaja na razini automatizacije u polju i nadzornih sustava koji su se temeljili na komunikacijskim protokolima svojstvenim sklopovlju uređaja koje povezuju. Takav način povezivanja zahtijevao je isporuku ili izradu specifičnih komunikacijskih programskih sučelja (<em>software driver-a</em>) za svaki uređaj u sustavu. Zbog toga je krajnji kupac kupovao skup sustav čije je održavanje i eventualno proširenja bilo komplicirano i skupo. Rješenje se ogledavalo u razvoju standardnog sučelja koji će omogućiti jednostavnu primjenu (<em>plug &amp; play</em>) te jednostavno održavanje i buduće proširenje. Takav standard trebao je biti prikladan i za jednostavne i za složene sustave koji bi se gradili na osnovu  otvorene i unificirane komunikacije od osnovne razine automatizacije do složenih informacijskih  sustava.  Rješenje je ponuđeno kao novi koncept baziran na OPC tehnologiji što  skraćenica (<em>OLE for Process Control</em>) koja označava Microsoft tehnologiju <a href="http://en.wikipedia.org/wiki/OLE">OLE </a>(<em>Object Linking and Embedding</em>) primijenjenu u kontroli procesa. Iz toga slijedi kompatibilnost OPC tehnologije sa MS Windows aplikacijama i činjenica da je moguće izraditi veoma prikladne i cijenom povoljni male aplikacije vizualizacije bazirane na Microsoftovoj tehnologiji</p><h4>Arhitektura informacijskog sustava u procesnoj industriji</h4><p>Uvođenjem inteligentnih uređaja u postrojenjima kao dijelova sistema vođenja nadzora i upravljanja pojavljuje se obilje informacija, o uređajima ali i o postrojenju, koji nisu prije bili raspoloživi. Ove informacije osiguravaju podatke o stanju uređaja, njegovim konfiguracijskim parametrima te okruženju u kojem se uređaj nalazi. Spomenute informacije  se trebaju prikazati korisniku na konzistentan način. Brigu nad njima preuzimaju procesna računala (PLC-i) koristeći suvremene industrijske računalne mreže kao podatkovne magistrale na razini postrojenja (polja). Instaliranje distribuiranih sistema upravljanja (DCS) i<a href="http://en.wikipedia.org/wiki/SCADA"> SCADA</a> sustava sa zadaćom  da nadziru upravljanje   procesima čine ove podatke raspoložive i u elektronskoj formi, za razliku od ranijih sustava kada su mnogi od njih bili ručno prikupljani i zapisivani. Zahtjev za kontrolom financijskih aspekata proizvodnih procesa ostvaruje se integracijom ovih prikupljenih informacija iz procesa u poslovne sustave. Držeći se ovih smjernica pri  razvoju informacijskih sustava  u procesnoj industriji dolazimo do tipične arhitekture sustava u kojoj uočavamo tri osnovne razine:</p><ol><li>Poslovni menedžment</li><li>Menadžment procesa</li><li>Menadžment u postrojenju (polju)</li></ol><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_Netwrok.png"><img class="aligncenter size-full wp-image-459" title="OPC_Netwrok" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_Netwrok.png" alt="" height="480" width="640" /></a></p><h4>OPC – novi koncept sustava automatizacije</h4><p>Dosadašnji sustavi automatizacije podrazumijevali su komunikacije između uređaja na razini automatizacije u polju i nadzornih sustava koji su se temeljili na komunikacijskim protokolima koji su bili svojstveni sklopovlju uređaja koje povezujemo. Takav način povezivanja zahtijevao je isporuku ili izradu komunikacijskih programskih sučelja (<em>software driver-a</em>) za svaki uređaj u sustavu. Ta programska sučelja isporučivala su se u sklopu SCADA sustava samo za poznatije uređaje (PLC, mjerni uređaji, itd.). Često se događalo da potrebe povezivanja nekih specifičnih, a često vrlo važnih, uređaja u sustav predstavlja tešku a nekad i nepremostivu poteškoću. U tom slučaju koristili su se takozvani konverteri protokola koji su često bili skuplji od samih uređaja. Te i slične poteškoće poskupljivale su složenije sustave, te tako pridonijele opće priznatom mišljenju da se složenija sustavi automatizacije ekonomski ne isplate.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_SCADA_Classic.png"><img class="aligncenter size-full wp-image-438" title="OPC_SCADA_Classic" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_SCADA_Classic.png" alt="" height="242" width="599" /></a></p><p>Cijene integracija različitih podsustava znatno su rasle zbog činjenice da je za svaki uređaj bilo potrebno izrađivati posebno programsko sučelje. Statistike govore da je za programski razvoj tipične nadzorno – kontrolne aplikacije bilo potrebno utrošiti za pisanje programskog sučelja oko 25-30% inženjerskog razvojnog vremena. Integratori sustava trošili su veoma mnogo razvojnog vremena za takve poslove te je konačna cijena sustava bila skupa kao i održavanje budući da je zahtijevalo specijalistička znanja. Rezultat tog  je bio da je krajnji kupac kupovao skup sustav čije je održavanje i eventualno proširenja bilo isto tako komplicirano i skupo. Rješenje se ogledavalo u razvoju standardnog sučelja koji će omogućiti jednostavnu primjenu (<em>plug &amp; play</em>) te jednostavno održavanje i buduće proširenje. Takav standard trebao je da bude prikladan i za jednostavne i složene sustave koji bi se gradili na osnovu  otvorene i jednostavne komunikacije od osnovne razine automatizacije do složenih informacijskih <a href="http://en.wikipedia.org/wiki/Management_information_system">MIS </a>sustava (<em>Management Information System</em>).</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_SCADA_Modern1.png"><img class="aligncenter size-full wp-image-461" title="OPC_SCADA_Modern1" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_SCADA_Modern1.png" alt="" height="307" width="636" /></a></p><p>Rješenje je ponuđeno kao novi koncept baziran na OPC tehnologiji. Na priloženim slikama prikazana je razlika novog koncepta OPC strukture (Sl. 2a) i stare komunikacijske strukture (Sl. 2b). Terminologija OPC izvodi se kao  skraćenica (<em>OLE for Process Control</em>) koja označava Microsoft tehnologiju OLE (<em>Object Linking and Embedding</em>) primijenjenu u kontroli procesa. Iz toga slijedi kompatibilnost OPC tehnologije sa MS Windows aplikacijama i činjenica da je moguće izraditi veoma prikladne i cijenom povoljni male aplikacije vizualizacije koje kao podlogu (<em>OPC Client</em>) koriste npr. neku od komponenata MS Office paketa (npr. Excel). Tijekom protekle decenije OPC je postao industrijski standard kojeg razvijaju najuglednije svjetske kompanije sa područja automatizacije u suradnji sa tvrtkom Microsoft. U tom smislu osnovana je neprofitabilna zaklada OPC Foundation koja okuplja preko 150 članova, pretežno svjetski poznatih razvojnih ustanova i tvrtki. OPC tehnologija se temelji na već spomenutom Microsoft OLE (<em>ActiveX)</em> tehnologiji i komunikacijskim modelima COM (<a href="http://en.wikipedia.org/wiki/Component_Object_Model"><em>Component Object Model</em></a>) i DCOM (<a href="http://en.wikipedia.org/wiki/Distributed_Component_Object_Model"><em>Distributed Component Object Model</em></a>). OPC sadrži standardni set sučelja, svojstva i metoda koje se koriste u aplikacijama kontrola procesa i automatizacije. OLE/COM tehnologije definiraju se kako individualne programske komponente koje mogu međudjelovati i dijeliti podatke.</p><h3 style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_SCADA_Modern2.png"><img class="aligncenter size-full wp-image-462" title="OPC_SCADA_Modern2" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_SCADA_Modern2.png" alt="" height="304" width="634" /></a>OPC specifikacije i smjernice razvoja</h3><p>OPC specifikacije definiraju skup sučelja (<em>Interface</em>) koji se lako implementiraju primjenom objektno orijentiranog programiranja i omogućava laku manipulaciju tim objektima. Softver pomoću koga korisnik upravlja procesom  (<a href="http://en.wikipedia.org/wiki/Human-machine_interface"><em>Human-Machine Interface</em></a>), upravljački softver ili softver za akviziciju podataka (<em>SCADA</em>) može obrađivati ili prikupljati podatke sa različitih računara u mreži. Specifikacije definiraju standardne mehanizme za pristupanje podacima na serveru po nazivima. Projektanti koji razvijaju hardver i softver mogu jednostavno razmjenjivati informacije pomoću širokog spektra sistemskih aplikacija, u koje se ubrajaju distribuirana kontrola sistema (<em>DCS</em>), SCADA sustavi, procesna računala PLC (<em>Programmable Logical Controler</em>) kao i razni inteligentni uređaji, povezani preko računarske mreže.</p><p>Prva verzija OPC standarda V1.0 je objavljena u kolovozu 1996. godine. Tijekom  1997. godine vršene su korekcije na standardu a krajem 1998. godine se pojavila verzija V2.0 sa značajnim izmjenama. Standard je podržan od strane najvećih svjetskih kompanija koje se bave izradom PLC-a i softvera za vizualizaciju procesa. OPC je baziran na tehnologijama OLE, ActiveX, COM  i DCOM i dostupan je na 32-bitnom operativnom sistemu Microsoft Windows. Pomoću DCOM tehnologije mogu  se razmjenjivati podaci (objekti) i sa drugim operativnim sistemima kao što su <a href="http://en.wikipedia.org/wiki/Unix">Unix</a> ili<a href="http://en.wikipedia.org/wiki/Linux"> Linux</a>. Do danas je izdano desetak OPC specifikacija od kojih možemo izdvojiti tri osnovne:</p><ol start="1"><li><strong>OPC Data Access</strong> (<em>OPC DA</em>) – Koristi se za razmjenu podataka između servera i procesne opreme u realnom vremenu. <em> OPC Data Access</em> je  najvažnija specifikacija i sučelje  koje je najviše implementiranu u svim primjenama OPC tehnologije danas. Ono omogućava čitanje i pisanje varijabli procesa u realnom vremenu.<br /> <strong>OPC Complex Data, OPC Batch, and OPC Data eXchange (DX)</strong> su ekstenzije <em>OPC DA</em> servera za poboljšanu funkcionalnost. <em>Complex Data</em>  definira način pristupa kompleksno strukturiranim varijablama procesa dok <em> OPC Batch</em>  je specifikacija namijenjena klijentima kod slijednih (batch) procesa (S88). <em>OPC Data eXchange</em>  (<em>DX</em>)  specifikacija definira način razmjene podataka između DA servera  kada je klijent definiran unutar servera.</li><li><strong>OPC Alarms &amp; Events</strong> (<em>OPC A&amp;E</em>) – Omogućava  pozive alarma i događaja na zahtjev za razliku od kontinuiranog protoka podataka <em>OPC DA</em> servera.  To uključuje obradu alarma, aktivnosti operatora, informacijske poruka i poruke o praćenju procesa. Pri tome se pod pojmom  Alarms  i Events  smatraju jednokratne poruke o stanju procesa i nedozvoljenim promjenama unutar njega.</li><li><strong>OPC Historical Data Access </strong><em>(OPC HDA)</em><strong> – </strong>Za razliku od <em>OPC DA</em> servera koji omogućava praćenje procesa u realnom vremenu <em>OPC HDA</em> te podatke sprema i čuva. Koristeći se <em>OPC HDA</em> serverom SCADA sustavi se transformiraju iz jednostavnog (<em>data logging</em>) sustava u kompleksne alate za praćenje i analizu procesa u bilo koje vrijeme.</li></ol><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/02/OPC_Specifitation.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/02/OPC_Specifitation.png" title="OPC_Specifitation" class="aligncenter size-full wp-image-839" height="250" width="636" /></a></p><p>Od ostalih  <strong>OPC XML-DA</strong>  je prva OPC specifikacija koja nije bila vezana uz određenu programsku platformu kod koje je DCOM/COM komunikacija zamijenjena s <a href="http://en.wikipedia.org/wiki/SOAP">HTTP/SOAP</a> protokolima i tehnologijom web-servisa. <strong>OPC Security</strong> definira kontrole pristupa serveru  da bi se zaštitile važne  informacije i onemogućilo neovlašteno mijenjanje parametara procesa. <strong>OPC Commands</strong> definira mehanizme za pozivanje metode ili za izvršavanje programa putem OPC. Ova specifikacija nikada nije objavljen  budući da je završena  nakon što je započet rad na <strong>OPC Unified Architecture</strong> ali je sadržaj i funkcionalnost u potpunosti je uklopljen u UA.</p><p><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/opc_UALogo.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/01/opc_UALogo.png" alt="" title="opc_UALogo" class="aligncenter size-full wp-image-817" height="205" width="240" /></a></p><p>Slijedeća generacija OPC specifikacija trebala je napustiti koncept ograničene Microsoft Windows platforme a OPC Foundation bi trebala osigurati portabilnost na ostale operativne sustave. Ova specifikacija nazvana <strong><em>OPC Unified</em></strong> (<em>OPC UA</em>) podržava skalabilnost kompletnog protokola što omogućava implementaciju na  embeded platforme za razliku od dosadašnje DCOM platforme koja troši razmjerno puno memorijskih resursa . Sadašnje specifikacije <em>DA, A&amp;E i HDA</em> servera zahtijevaju zasebno memorijsko prostore adresiranje dok ih <em>UA</em> specifikacija ujedinjuje što pojednostavljuje programske pozive. Sigurnost današnji servera je vrlo mala jer komunikacija zahtjeva otvoren port 135. <em> OPC Unified</em> arhitektura predviđa sigurnosni sustav baziran na <a href="http://en.wikipedia.org/wiki/W3C_Markup_Validation_Service">W3C</a> specifikacijama koji uključuju autorizaciju korisnika, razmjenu digitalnih certifikata i opcionalnu enkripciju poruka.</p><p>Performanse danas korištenih servera  uvelike su ograničene performansama <em>DCOM</em> sučelja dok novi standard predviđa mnogo bolje jer definira dvije transportne opcije:</p><ul><li><strong>Web bazirani protokol</strong> SOAP (XML kodirana razmjena podataka preko HTTP) kojije u osnovi tekstualan što daje mogućnost lagane integracije u razne sustave ali je i do nekoliko puta sporiji od DCOM prijenosa</li></ul><ul><li><strong>UA binarni protokol</strong> (binarno kodirana razmjena podataka preko TCP/IP) čija brzinaje usporediva, pa čak i brža od DCOM karakteristika</li></ul><p>Osim ovoga nova OPC UA specifikacija donosi bolje rezultate na polju robusnosti aplikacija, redundancije podataka, te mogućnosti upotrebe  kompleksnih i strukturiranih podataka.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> ]]></content:encoded> </item> <item><title>Interbus-S industrijska mreža</title><link>http://www.quercus-lab.com/interbus-s-industrijska-mreza/</link> <comments>http://www.quercus-lab.com/interbus-s-industrijska-mreza/#respond</comments> <pubDate>Thu, 08 Dec 2011 11:50:16 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Automatizacija]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=324</guid> <description><![CDATA[Upotreba računala za upravljanje je najvažnija značajka suvremenih upravljačkih sustava u procesnoj industriji. Računala se povezuju neposredno na proces a međusobno se povezuju u mrežu računala. U početku primjene računala za upravljanje, kada su računala bila vrlo skupa,  upravljanje se je zasnovalo na upotrebi jednog velikog središnjeg  računala, no  razvojem tehnologije poluvodičkih elemenata  cijena računala [&#8230;]]]></description> <content:encoded><![CDATA[<p><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus.png" title="Interbus" class="size-full wp-image-482 alignleft" width="180" height="130" /></a>Upotreba računala za upravljanje je najvažnija značajka suvremenih upravljačkih sustava u procesnoj industriji. Računala se povezuju neposredno na proces a međusobno se povezuju u mrežu računala. U početku primjene računala za upravljanje, kada su računala bila vrlo skupa,  upravljanje se je zasnovalo na upotrebi jednog velikog središnjeg  računala, no  razvojem tehnologije poluvodičkih elemenata  cijena računala postaje sve manje značajna i istovremeno  snaga malih računala  omogućuje primjenu velikog broja računala za upravljanje proizvodnje u nekom pogonu ili cijeloj tvornici. Svaki industrijski pogon se sastoji od velikog  broja procesnih jedinica koje se mogu upravljati računalom, tako da se vrlo često veliki broj računala u industrijskom pogonu međusobno povezuje u višerazinsku strukturu računalnu mreže. Na prvoj računalnoj razini nalaze se računala za neposredno upravljanje pojedenim procesima.  Ova računala imaju zadaće upravljanja slijedom operacija i regulaciju pojedinih procesnih veličina. Informacije s razine neposredne proizvodnje prenose se na višu razinu. Na ovoj razini se obavljaju složeni  zadaci upravljanje kao što je  optimiranje proizvodnih planova. Takova računala podržavaju distribuirane baze podataka o tekućoj  proizvodnji kao i tehničku dokumentaciju o procesnim jedinicama. Na najvišoj razini se nalazi središnje ili glavno računalo  koje ima najveću procesnu moć obrade informacija. Za razmjenu informacija u ovako organiziranim računalnim sustavima razvili su se specifične računalne mreže koja su prilagođene određenoj razini komunikacije i fizičkim uslovima koji  vladaju u pojedinim područjima. Kao primjer tako organiziranog sustava prikazana je  mrežna struktura tiskarskog postrojenja u kojoj je primijenjen moderan pristup automatizaciji i mrežnoj tehnologiji.</p><h4 style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/PrintingMaschineNetwork.png"><img class="aligncenter size-full wp-image-325" title="PrintingMaschineNetwork" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/PrintingMaschineNetwork.png" alt="" width="604" height="390" /></a></h4><h4 style="text-align: left;">Princip rada Interbus-S mreže</h4><p style="text-align: left;">Interbus-S senzorsko-aktorska mreža je digitalni serijski komunikacijski sustav za prijenos podataka između kontrolnog sustava i raznoraznih senzora i aktora. Interbus-S je koncipiran kao serijski podatkovni prsten koji radi isključivo u realnom vremenu u okviru master/slave metode kontrole prijenosa a strukturiran je kao pozadinski posmični registar.  Svaki  član mreže (<em>slave</em>) sa svojim registrima dio je tog prstenastog posmičnog registra.  Interbus master u mrežnom modulu  čini centralni dio Interbus sustava koji kontrolira  čitav sustav te omogućava da su ulazno-izlazni podaci dostupni slici procesa. Tijekom jednog mrežnog ciklusa serijski se isporučuju izlazni podaci  članovima mreže ali se istovremeno od njih  zaprimaju ulazni podaci. Na kraju ciklusa svi izlazni podaci su distribuirani  a ulazni upisani u ulaznu mapu slike procesa. Koristeći prstenastu strukturu moguće je ostvariti  istovremenu predaju i zaprimanje podataka (<em>full dupleks</em>) a predvidljivo vrijeme pristupa  za  sve članove mreže je zajamčeno.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_cycle.png"><img class="aligncenter size-full wp-image-394" title="Interbus_cycle" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_cycle.png" alt="" width="555" height="413" /></a></p><h4 style="text-align: left;">Interbus-S mrežna toplogija</h4><p style="text-align: left;">Topologija ove mreže je prsten koji sve  članove mreže integrira u jedinstven transportnu  putanju. Dodatna karakteristika Interbus-S mreže je prijenos podataka u oba smjera za sve članove. Fizički izgled mreže je radi toga  linijska ili razgranate struktura s pojedinačnim  ograncima.  Spajanje na mrežu ostvaruje se mnogostrukim serijskim spojevima tako da svaki član svojim ulazom zaprima podatke od prethodnog  člana te ga odašilje prema slijedećem. U tom kontekstu linije se označavaju kao  DO (<em>DataOut</em>) linija ako je tok podataka od  nadređenog (mastera) te kao DI (<em>DataIn</em>) ako je tok podataka ka nadređenom.  Analizirajući realnu  strukturu mreže mogu se izvući slijedeće prednosti:</p><ul><li>Adresiranje članova mreže pomoću kodnih prekidača nije potrebno jer je fizičkim položajem svaki član jasno određen u mreži.</li><li>Nisu potrebni skupi pojačivači signala jer se signal u svakom članu mreže regenerira.</li><li>Omogućen je istovremeni prijam i odašiljanje podataka što karakterizira prijenos kao <em>full dupleks.</em></li><li>Point to point struktura omogućava zamjenu transportnih medija (svjetlovoda  naprimjer) u bilo kome dijelu mreže ako je to potrebno s obzirom na smetnje u tom dijelu.</li><li>Omogućena je implementacija rutina samodijagnostike svakog člana mreže.</li></ul><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_topolgy.png"><img class="aligncenter size-full wp-image-409" title="Interbus_topolgy" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_topolgy.png" alt="" width="464" height="582" /></a></p><p>Ovako opisana topologija omogućava spajanje najviše 512 mrežnih  članova dok je ukupna količina podataka 4098 bita što je uobičajena ulazno-izlazna mapa većine procesnih računala. U fizičkoj strukturi Interbus-S industrijske mreže razlikujemo dvije vrste mrežnih segmenata. Jedan od tih segmenata nazivamo   <em>Remote bus</em> i on predstavlja vezu između  mrežnih  čvorova koji ne nose informaciju nego omogućavaju daljnje grananje strukture . Na svaki mrežni čvor nastavlja se segment koji se naziva <em>Local bus</em> i koji spaja ulazno-izlazne mrežne članove u prsten. Maksimalna duljina  <em>Remote bus</em>-a odnosno udaljenost između dva  <em>Remote bus</em> mrežna  adaptera (<em>BA–BusAdapter</em>) je 400 metara dok je ukupna duljina mreže limitirana na 13 km.  Udaljenost između dva mrežna člana unutar <em>Local Bus</em>-a je 20 metara.</p><h4>OSI model Interbus-S protokola</h4><p>Interbus-S protokol baziran je na OSI referentni model ali zbog gore navedenih specifičnosti  koristi samo 1,2 i 7 sloj .  Ostale funkcije od 3 do 6 sloja implementirane su u 7 (aplikacijskom) sloju. Koristeći fizički sloj  signali se odašilju standardnom brzinom od 500 kbps koristeći NRZ  (<em>non-return to zero</em>) metodu. Podatkovni sloj se brine za integritete podataka i  upravlja  cikličkim prijenosom podatka koristeći   <em>summation frame method</em>.  Ovaj sloj prosljeđuje  podatke aplikacijskom sloju preko dva različita podatkovna kanala:</p><ul><li>Podatkovni kanal procesa (<em>Process Data Channel</em>) je primarni kanal Interbus-S mreže i  koristi se za prijenos procesnih informacija koje se obrađuju skupom senzora i aktuatora.</li><li>Parametarski kanal (<em>Parameter Channel</em>) omogućava cikličku razmjenu parametarskih  podataka između složenijih  članova uključenih u mrežu. Ovaj kanal zahtjeva veći komunikacijski paket i koristi servise bazirane na master-slave strukturi.</li></ul><p><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_OSI.png"><img class="aligncenter size-full wp-image-387" title="Interbus_OSI" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_OSI.png" alt="" width="521" height="275" /></a></p><p>Svaki Interbus-S mrežni član sadrži procesni kanal dok je parametarski dodan kao mogućnost  (opcija). Ovakva hibridna struktura protokola koja koristi dvije neovisne kanala podataka omogućava u istoj mreži implementaciju složenih (inteligentnih) mrežnih  članova i  jednostavnih senzora i aktora. Osim toga u svakom sloju se tijekom rada mreže izvršavaju dijagnostičke rutine o kjima se brine rutina koji se naziva<em> Network Menegment  (upravljanje mrežom)</em> .</p><h4>Summation Frame Protokol</h4><p>Interbus-S je jedina industrijska mreža koja koristi <em>summation frame method</em>  pomoću kojeg se razmjenjuje podaci između nadređenog i podređenih  članova mreže u  samo jednom komunikacijskom ciklusu i to simultano u oba smjera (<em>full duplex</em>).  Ova metoda omogućuje  predviđeno trajanje komunikacijskog ciklusa što mu daje prednost  u procesima koji se kontroliraju u realnom vremenu. U   <em>summation</em> okviru, koji se sastoji od  zaglavlja (<em>haeder</em>), povratne riječi (<em>loop-back word</em>), podataka i kontrolne sekvence, podaci za sve članove mreže su grupirani u jedan podatkovni blok.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_sumframe.png"><img class="aligncenter size-full wp-image-382" title="Interbus_sumframe" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_sumframe.png" alt="" width="582" height="180" /></a></p><p>Razmjena podataka koristeći ovaj protokol izvršava se u s slijedećim sekvencama:</p><ol><li>Svi mrežni članovi se resetiraju te se identifikacijski kodovi  dotičnog člana učitava u posmični registar.</li><li>Nadređeni član  inicira početak identifikacijskog ciklusa u kome se metodom posmaka transportiraju identifikacijski kodovi svih trenutno prisutnih članova zajedno sa količinom podataka koji pojedinačno obrađuju.</li><li>Završetkom ID-ciklusa nadređeni ažurira trenutnu topologiju mreže i uspoređuje je sa  zahtijevanom konfiguracijom te ako nema greške spreman je za početak podatkovnog ciklusa.</li><li>U slučaju greške slijedeći identifikacijskim ciklusom moguće je rekonfigurirati mrežu te ponovo startati podatkovni ciklus.</li><li>Pokreće se podatkovni ciklus koji se ciklički izvršava sve dok se CRC metodama ne utvrdi greška u prijenosu podataka što uzrokuje ponavljanje opisane sekvence.</li></ol><h4>Procesni podatkovni kanal</h4><p>Procesni podaci su oni koji neposredno opisuju kontrolirani proces i predstavljaju u realnom vremenu stanja izvršnih i senzorskih uređaja koji sudjeluju u procesu. Kompleksnost tih podataka gledana sa stanovišta pojedinačnih mrežnih  članova nije velika i kreče se od nekoliko bitova do d nekoliko bytova. Ova karakteristika omogućava umrežavanje u Interbus-S mrežu velikog broja mrežnih članova sa karakterističnom širinom podataka od 8 do 16 bita(1 word). Nakon što je utvrdio konfiguraciju mreže nadređeni može početi sa prijenosom podataka između procesnog računala i ulazno-izlaznih uređaja. Podatkovni ciklus uključujeposmak podatkovnih blokova prema podređenim članovima mreže i to po, u identifikacijskom ciklusu,  utvrđenom redoslijedu i količini podataka. Kada podatkovni blok dospije do mrežnog  člana provjerava se pripada li taj podatak tom  članu. Ako je odgovor potvrdan mrežni  član prihvaća dobavljene podatke u svoj izlazni registar te iz svog ulaznog registra prosljeđuje u posmični  registar. Na ovaj način se nakon punog posmaka posmičnog registra razmjeni cjelovita slika procesa .</p><h4>Parametarski podatkovni kanal</h4><p>Parametarski podatkovni kanal koristi se da bi neovisni proizvođači razmjenjivali kompleksne  podatke za svoje uređaje unutar Interbus-S mreže. Za razliku od procesnih podataka koji se  prenose ciklički parametarski podaci se razmjenjuj samo na zahtjev određenog mrežnog  člana. Kompleksnost tih podataka je u mnogome veća od procesnih i uobičajeno iznosi od 10  do 100 baytova. Tipični Interbus-S uređaji koji koriste  parametarski podatkovni kanal su  frekvencijski i tiristorski motorni pretvarači, servo-pozicioneri te operatorski i upravljački  paneli. Implementacija parametarskog podatkovnog kanala u  <em>summation frame</em>  zahtjeva  razdavanje kompleksnih parametarskih poruka na više dijelova. Tako razdvojeni parametri se potom prenose zajedno sa procesnim podacima unutar podatkovnog ciklusa i na taj se način  proširuje podatkovni blok  <em>summation frame</em>.   Komunikacija koja koristi parametarski podatkovni kanal bazira se na klijent/server modelu:</p><ol><li>Mrežni  član koji želi komunicirati šalje zahtjev (<em>request</em>) i on u komunikacijskom  odnosu predstavlja klijenta.</li><li>Interbus master prenosi  zahtjev  na ciljani podređeni  član koji reagira odgovorom  (response) i on predstavlja server.</li><li>Ovaj se  odgovor prenosi do člana koji je inicirao komunikaciju i na taj način mu se  poručuje da može početi sa slanjem parametara.</li><li>Slijedi  razmjena parametara koristeći Interbus-S nadređeni uređaj kao posrednika u komunikaciji.</li></ol><p>Parametarski podatkovni kanal može se koristiti i  za razmjenu podataka između nadređenih  (slave) članova mreže i između nadređenog i podređenog člana (što je češći slučaj).</p><h4>Konektori i kablovi</h4><p>Interbus-S standard (IEC 61158) se bazira na RS-485 standardu kao električnoj specifikaciji za prijenos podataka  u <em>Remote bus</em> segmentu mreže.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_RS422.png"><img class="aligncenter size-full wp-image-398" title="Interbus_RS422" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_RS422.png" alt="" width="601" height="145" /></a></p><p style="text-align: left;">Raspored priključaka standardnog ožičenja Interbus-S mreže  s DB-9 konektorima:</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_DB9.png"><img class="aligncenter size-full wp-image-402" title="Interbus_DB9" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_DB9.png" alt="" width="586" height="182" /></a></p><p style="text-align: left;">Raspored priključaka standardnog ožičenja Interbus-S mreže  s IP 65 konektorima:</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_IP65.png"><img class="aligncenter size-full wp-image-404" title="Interbus_IP65" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_IP65.png" alt="" width="553" height="173" /></a></p><p style="text-align: left;">Raspored spajanja Interbus-S mreže  s terminalskim priključnicama:</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_Term.png"><img class="aligncenter size-full wp-image-406" title="Interbus_Term" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_Term.png" alt="" width="439" height="267" /></a></p><h4>Interbus-S ASICs</h4><p>ASICs (<em>Application  Specific  Integrated  Circuit</em>) je integrirani krug za primjenu u točno  definiranoj aplikaciji za razliku od integriranih krugova opće namjene. Razvojem ASICs  čipova pojednostavljen je i ubrzan razvoj krajnjih uređaja posebno u otvorenim industrijskim  mrežama kao što je Interbus-S. Isto tako pojednostavljeno je razumijevanje i implementacija  mrežnog protokola kod krajnjeg korisnika. Korisnicima Interbu-S mreže dostupna su dva ASICs čipa:</p><ul><li><em>Slave  SuPI</em> – implementacija podređenog mrežnog člana  Interbus-S mreže s ulazno-izlaznim funkcijama</li><li><em>Master  IPMS</em>  &#8211; sučelje između Interbus-S mreže s jedne strane i mikroprocesorskog   upravljanja s druge</li></ul> ]]></content:encoded> <wfw:commentRss>http://www.quercus-lab.com/interbus-s-industrijska-mreza/feed/</wfw:commentRss> <slash:comments>0</slash:comments> </item> <item><title>SoftPLC</title><link>http://www.quercus-lab.com/softplc/</link> <comments>http://www.quercus-lab.com/softplc/#respond</comments> <pubDate>Mon, 21 Nov 2011 11:15:48 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Automatizacija]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=228</guid> <description><![CDATA[Od početka razvoja PC kompatibilne tehnologije bilo je pokušaja korištenja iste za kontrolu procesne opreme. Glavni problem u razvoju tih aplikacija bilo je to što PC nije bio razvijan kao sustav za rad u stvarnom vremenu (real time).  Tek pretvaranje standardnih operativnih sustava (dos, windows, linux) u realtime operativne sustave stekli su se uvjeti za [&#8230;]]]></description> <content:encoded><![CDATA[<p><a href="http://www.quercus-lab.com/wp-content/uploads/2011/11/SoftPLC.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2011/11/SoftPLC.png" alt="" title="SoftPLC" class="alignleft size-full wp-image-485" height="130" width="180" /></a>Od početka razvoja PC kompatibilne tehnologije bilo je pokušaja korištenja iste za kontrolu procesne opreme. Glavni problem u razvoju tih aplikacija bilo je to što PC nije bio razvijan kao sustav za rad u stvarnom vremenu (<em>real time).  </em>Tek pretvaranje standardnih operativnih sustava (dos, windows, linux) u <em>realtime</em> operativne sustave stekli su se uvjeti za efikasno korištenje PC računala kao procesnih računala. I nakon toga programiranje takvih računala  u sustavima automatizacije bilo je teško jer inženjeri automatizacije, u pravilu, nisu bili obučeni za klasično programiranje u asembleru ili višim programskim jezicima  dok su vrsni programeri imali problema s poznavanjem industrijskih procesa. Stvaranje efikasnog tima bilo je vrlo teško i skupo stoga su kompanije koje su se bave razvojem takvih sustava odlučile definirati standarde koji su bitno pojednostavili primjeni PC bazirane opreme u sustavima automatizacije. Rezultat te inicijative je IEC63131 standard koji definira smjernice za programiranje  suvremenih PLC uređaja a koji je najbolje podržan u takozvanim SofPLC sustavima.<br /> SoftPLC sustavi su softverski proizvodi pomoću kojih standardne hardverske (intel, motorola, arm)  i softverske platforme (windows, linux) pretvaramo u moćna procesna računala.  Programiranje takvih računala je prilagođeno standardima programiranja običajnih PLC i PAC računala.</p><h4>ProConOS soft-PLC</h4><p>ProConOS (<em><strong>Pro</strong>gammable </em><strong><em>Con</em></strong><em>troller </em><strong><em>O</em></strong><em>perating </em><strong><em>S</em></strong><em>ystem</em>) je programsko bazirani PLC sustav koji osigurava PLC specificiran servis na standardnim ili specijalnim hardverskim platformama. To uključuje učitavanje i procesiranje PLC programa kao i mogućnost testiranje i ispravljanja programa (<em>debug)</em> pri pokretanju i održavanju strojeva i postrojenja upravljanih procesnim računalom. Druga definicija za ProConOS je da je on visoko učinkoviti <em>PLC runtime</em> sustav za kompleksne upravljačke aplikacije. Dizajniran je specijalno za IEC61131 normu i sadrži cijeli niz IEC61131 značajki. Dakle da bi ste dobili upotrebljivo procesno računalo trebate prvo izabrati neku stanadardnu sklopovsku opremu  (hardware) podesnu za automatizaciju vašeg procesa ili napraviti svoju baziranu na podržanim procesorima. Na takav hardver instaliarate neki od podržanih <em>realtime</em> operativni sustav. Sada je vaše računalo spremno za instaliranje softPLC-a ProConOS.  Nakon svega toga imate procesno računalo spremno za programiranje vašeg sustava automatizacije na manje ili više uobičajeni način programiranja PLC-a. PorConOS se isporučuje se s IEC61131 programskom razvojnom okolinom <em>KW Multiprog</em> koja omogućuje lagano programiranje u SFC, LD, STL ili IL programskim jezicima.</p><p><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/ProconOS_web.png"><img class="aligncenter size-full wp-image-238" title="ProconOS_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/ProconOS_web.png" alt="" height="305" width="591" /></a></p><p>Jedna od bitnih razlika programiranja podržanih od IEC 61131 norme , u odnosu na standarne PLC-e,  je mogućnost vremenskog upravljanja izvršavanjem pojednih programskih zadataka <em>(taskova</em>). Za razliku od kontinuiranog izvršavanja vašeg programskog koda  IEC 61131 standard  opisuje različite modele raspoređivanja vremena rada programskih taskova<em></em>:</p><ul><li><em>Default task</em> , svaki <em>resource</em> sadržava jedan default task koji ima najniži prioritete. Taj task nije vremenski raspoređen.</li><li><em>Cyclice task</em> koji se izvršava periodično u određenim vremenskim intervalima</li><li>System task poziva operacijski sustav PLC-a ako je došlo do promjena stanja PLC-a ili nekakve greške.<strong><em> </em></strong></li><li><em>Event or interrupt tasks</em>  se aktivira na određeni definirani događa ili stanje</li></ul><p style="text-align: left;">Svaki task ima određeni prioritete. U sustavima s takozvanim raspoređivanja sa preuzimanjem (<em>preemptivnim scheduling) </em>, koji je implementiran u softPLC-u ProConOS-u, task koji ima niži prioritete prekida se odmah kada se aktivira task s višim prioritetom za razliku od <em>none-preemptivnim</em> sustavima gdje nije moguć prekid trenutnog taska od strane taska s višim prioritetom.<br /> <a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/ProConOs_PreemptiveScheduling_web.png"><img class="aligncenter size-full wp-image-240" title="ProConOs_PreemptiveScheduling_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/ProConOs_PreemptiveScheduling_web.png" alt="" height="301" width="633" /></a></p><p>Radna memorija ProConOS-a podjeljana je  na slijedeće dijelove:</p><ul><li>PLC program – aktualni izvršni korisnički program</li><li>Međuspremnik (buffer) za interne aktualne podatke</li><li>Procesna memorija koja sadrži sliku procesa a razlikuje:<ul><li>I –  ulazne podatke</li><li>Q – izlazne podatke</li><li>M – memorijske varijable</li><li>RM – <em>retentivne </em>memorijske varijable</li></ul></li><li>memorija za takozvani <em>bootproject</em></li><li>memorija za kompresirani project (kompletan)</li></ul><p>Shodno kompatibilnošću s IEC smjernicama ProConOS podržava sve tipove varijabli definirane u standardu a samo programiranje zahtjeva simbolično adresiranje kako memorijskih tako i ulazno/izlaznih varijabli.</p><h4><strong>Razvojno okruženje KW Multiprog</strong></h4><p>Za programiranje PLC-a i PAC-a koji podržavaju standard IEC61131 postoji nekoliko razvojnih  okolina a jedno od njih je i KW Multiprog. Multiprog je 32-bitna PC aplikacija sa intuitivnim sučeljem i sustavom za pomoć napravljenim po uzoru na razvojna okruženje za programiranju u ostalim modernim programskim jezicima opće namjene. Podržava gotovo se smjernice IEC61131 standarda. Podržani su programski jezici LD, IL, ST, FBD i SCF te njihovo slobodno miješanje u zajedničkom projekt radi primjene najefikasnijeg načina programiranja zahtijevanog algoritma. Administracija projekta te reprezentacija pojedinih elementa projekta i njihova terminologija je po IEC smjernicama. Kompajleri za pojedine hardverske platforme su modularni. Podržana je instalacija, puštanje u pogon te testiranje koristeći ugrađene alate kao što su osciloskopski prikaz statusa i simulator. Korisničko sučelje striktno podržava Windows standarde upravljanja objektima kao i dodatne elemente kao što su čarobnjaci i sustav za pomoć baziran na HTML standardu.</p><p>Upravljane projektom u Multiprogu je jednostavno i oslanja se na <em>Windows Explorer</em> strukturu u obliku drva baziranu na  IEC61131 softverskom modelu. Pisanja programa moguće je svi 5 programskih jezika definirani EEC61131 standardom a to su:</p><ul><li>• <em>Instruction List</em> (IL)</li><li>• <em>Structured Text</em> (ST)</li><li>• <em>Function Block Diagram</em> (FBD)</li><li>• <em>Ladder Diagram</em> (LD)</li><li>• <em>Sequential Function Chart</em> (SFC)</li></ul><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/KW_Multiprog.png"><img class="aligncenter size-full wp-image-247" title="KW_Multiprog" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/KW_Multiprog.png" alt="" height="384" width="614" /></a></p><p>Kao što je i nabrojano neki od ovih programskih jezika se programiraju u tekstualnom a neki u grafičkom editoru. Tekstualni editor automatski ispisuje ključne riječi programskih jezika u određenim bojama u ovisnosti o sintaksi a podržano je i automatsko kompletiranje imena korištenih varijabli i strukturnih elementa funkcijski blokova. Grafički editor omogućava slobodno manipuliranje funkcijski blokovima, automatsko povezivanje pojedinih elementa te naknadno ubacivanje ili brisanje bez gubitka strukture. Pojedini programski elementi se ispisuje, kao i kod tekstualnog editora, u posebnim bojama   radi što jasnije strukture programa. Na istom radnom prostoru (<em>worksheetu</em>) moguće je miješati sva tri programska jezika: LD, FBD i SFC. Klikom miša na određeno mjesto u grafičkom okruženje moguće je prebaciti se u tekstualni editor i nastavka pisanja programa željenim programskim jezikom. Dodatne dijagnostičke funkcije skraćuju vrijeme puštanja u pogon i testiranja korištenih algoritama u realnom vremenu a to su:</p><ul><li>Logički analizator (<em>Logic Analyzer</em>)<br /> <a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/Multiprog_LogicAnalyzer_web.png"><img class="aligncenter size-full wp-image-253" title="Multiprog_LogicAnalyzer_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/Multiprog_LogicAnalyzer_web.png" alt="" height="339" width="566" /></a></li><li>Sustav recepata (<em>Recipes</em>)</li><li>Prekidne točke u programu (<em>Breakpoints</em>)</li><li>Pregled  memorijskih lokacija (<em>Address debug</em>)</li><li>Izvršavanje programa korak po korak (<em>Single step</em>)</li><li>Prepisivanje vrijednosti u programu ( <em>Overwriting and forcing</em>)<a href="http://www.quercus-lab.com/wp-content/uploads/2011/11/Multiprog_Debug_web.png"><img class="aligncenter size-full wp-image-274" title="Multiprog_Debug_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/11/Multiprog_Debug_web.png" alt="" height="388" width="614" /></a></li><li>Izmjene programa  u samom PLC-u (<em>Online changes</em>)</li><li>Simulacija programa (<em>PLC simulation</em>)<a href="http://www.quercus-lab.com/wp-content/uploads/2011/11/Multiprog_Download_web.png"><img class="aligncenter size-full wp-image-275" title="Multiprog_Download_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/11/Multiprog_Download_web.png" alt="" height="369" width="608" /></a></li></ul><p>&nbsp;</p> ]]></content:encoded> <wfw:commentRss>http://www.quercus-lab.com/softplc/feed/</wfw:commentRss> <slash:comments>0</slash:comments> </item> <item><title>IEC 61131 standard  i SFC</title><link>http://www.quercus-lab.com/iec61131-standard-i-sfc/</link> <comments>http://www.quercus-lab.com/iec61131-standard-i-sfc/#respond</comments> <pubDate>Fri, 21 Oct 2011 12:23:12 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Automatizacija]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=126</guid> <description><![CDATA[Današnja industrijska postrojenja uglavnom su upravljanja procesnim računalima koje se nazivaju Programljivi Logički Kontroleri ili skraćeno PLC-i.  Više od 25 godina nakon uvođenja prvi PLC-a, na ovom tržištu još uvijek nije bilo  međunarodnog standard sličanom onom za PC računala do definiranja IEC 61131 standarda. Mnogi proizvođači koriste svoj dijalekt  uvriježenih programskih jezika a napisani softver [&#8230;]]]></description> <content:encoded><![CDATA[<p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/IEC61131-3.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2011/10/IEC61131-3.png" alt="" title="IEC61131-3" class="alignleft size-full wp-image-487" height="130" width="180" /></a>Današnja industrijska postrojenja uglavnom su upravljanja procesnim računalima koje se nazivaju <em>Programljivi Logički Kontroleri</em> ili skraćeno PLC-i.  Više od 25 godina nakon uvođenja prvi PLC-a, na ovom tržištu još uvijek nije bilo  međunarodnog standard sličanom onom za PC računala do definiranja IEC 61131 standarda. Mnogi proizvođači koriste svoj dijalekt  uvriježenih programskih jezika a napisani softver se koristi samo na tim kontrolerima.  Time je implementacije sklopovske opreme različitih proizvođača u jedinstven sustav upravljanja vrlo složen posao, a samim tim, i vrlo skup.  Stoga je za mnoge neshvatljivo da je trebalo više od 25 godina da se stvore zahtjevi za zajedničku programsku platformu kao što je standard IEC 61131-3.  Prije pojave IEC61131-3 standarda teorijski nije bilo moguće koristiti program napisan za određeni PLC na nekom drugom PLC-u (portanje). Nažalost veliki stupanj prenosivosti (portabilnosti) softvera bit će teško ostvariti i sada  jer standard samo definira specifikacije a od proizvođača se traži da on sam napravi spisak podržanih karakteristika.</p><h4>Osnove standarda</h4><p>Nekoliko većih kompanija  koje se bave razvojem prenosivog (portabilnog) softverom  za programiranje SoftPLC-a su formirali PLCopen Trade Association. PLCOpen je svjetska <em>vendor i product</em>  neovisna udruga koja  podržava IEC61131-3 normu. Osnovana je 1992 u Nizozemskoj a danas ima svoje urede u Kanadi i Japanu. Organizacija  informira korisnike i programere o standardu preko internetske stranice  <a href="http://www.plcopen.org/">www.plcopen.org</a>, besplatnim kvartalnim novostima te organizira konferencije po sajmovima.   PLCOpen definira tri različita <em>compliance classes </em>o prenosivosti kontrolnog sustava softvera<em>. </em></p><ol><li>Bazna razina (<em>Base Level</em> ) definira samo jezgru standarda (<em>core kerna</em>l) pa, iako je ograničena,  moguće je razvijati aplikacije na temelju nje. Ona ustvari samo pokazuje opredijeljenost proizvođača k standardu.</li><li>Razina  prenosivost (<em>Portability Level</em> ) sadrži veliki skup značajki, uključujući korisnički definiranih funkcija i funkcija bloka. Ova razina zahtijeva da sustav ima opciju <em>izvoz / uvoz</em>  za jednostavnu razmjenu programskog koda između sustava različitih proizvođača</li><li>Najviša razina, potpuna usklađenost  (<em>Full Compliance)</em>, nudi razmjenu potpune aplikacije, uključujući i konfiguracijskih informacija, između različitih sustava kontrole</li></ol><p>Po standardu  svi programi trebaju se rastaviti na funkcionalne elemente, programske organizacione jedinice (POU). Jedna POU sadrži funkcije, funkcijske blokove ili programe. Ako je moguče treba izvršavati  pojedine dijelove aplikacijskog programa razlčitom dinamikom u smislu da  sustav treba podržavati individualne vremenske intervale za različite POU (<em>Time</em> <em>Scheduling)</em></p><h4>Programski jezici</h4><p>Pisanja programa treba biti moguće u svim programskim jezicima koje definiran IEC61131 norma a to su:</p><ul><li> <em>Instruction List</em> (IL)- lista instrukcija grupiranih u korake programa koja uvelike podsječa na programiranje u asembleru</li><li> <em>Structured Text</em> (ST) – struktuirani tekst je standardni programski jezik više razine nalik na Pascal</li><li> <em>Function Block Diagram</em> (FBD) – funkcijski blok dijagram izgledom podsjeća na električne sheme digitalnih sklopova</li><li> <em>Ladder Diagram</em> (LD) – Ljestvičasti dijagram koji je prvi program za programiranje u sustavima automatizacije a izgledom oponaša električne sheme spajanja</li><li> <em>Sequential Function Chart</em> (SFC) – sekvencijalni funkcijski dijagram izgledom podsjeća na dijagrame  tijeka a posebno je prihvatljiv za brzo i pregledno programiranje sekvencijalnih procesa</li></ul><p>&nbsp;</p><h4>Sekvencijalni funkcijski diagram &#8211; SFC</h4><p>Jedan od zahtjeva standarda je da složena sekvencijalna događanja treba razložiti na događaje (<em>events</em>) s konciznim grafičkim jezikom a to se postiže upravo s SFC-om. U biti SFC nije programski jezik nego prezentacijski okvir sekvencijalne strukture koji objedinjuje programske algoritme napisane u ostalim jezicima.  SFC programski jezik razlikuje dvije osnovna elementa grafikona a to su korak  (<em>step</em>) i prijelaz ili tranzicija (<em>transition</em>). Koraci se predstavljaju četverokutima a povezani su okomitim linijama koje označavaju vremenski tijek. Svaki korak ima jedinstveni naziv a povezuje se (asocira) s jednom ili više akcija. Akcija može biti jednostavna binarna naredba ili , što je češći slučaj, poziv funkcije ili POU. POU može ravnopravno biti pisana u jednom od ostala 4 normirana programska jezika. Prijelaz iz jednog u drugi korak moguć je kad je ispunjen uslov prijelaza koji se  grafički prezentira kao vodoravna linija. To je  binarna varijabla koja se automatski generira a na nju je moguće   djelovati u bilo kojem dijelu programa.</p><p>Primjer jednog jednostavnog SFC programa imamo na slici. Program započinje inicijalnim korakom <em>S0</em> uz koji nij asocirana nikakva akcija.Izvršavanje programa iz koraka u korak uslovljeno je prijelazima <em>Tr1, Tr2, Tr3, Tr4 i Tr5</em>.  Zadovoljavajući  ove uslove aktiviraju se redom korak <em>S0</em> do <em>S4</em>.  Kada je aktivan korak<em> S1</em> on izvršava binarnu komandu  SET nad varijablom Var1. Slijedći korak <em>S2</em> poziva programsku organizacionu jedinicu  POU1 koja se izvršava samo dok je taj korak aktivan. Nakon prelaska na korak <em>S3</em> resetira se varijabla Var1 i ako je uslov <em>Tr3</em> ispunjen aktivira  se korak  <em>S4</em>. Ovaj korak poziva program POU2 ali s odgodom od 10 vremenskih jedinica. Konačno, ispunjavanjem uslova <em>Tr5</em> zatvara se petlja a izvršavanje tijeka programa se vrača na početak.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Base.png"><img class="aligncenter size-full wp-image-201" title="SFC_Base" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Base.png" alt="" height="360" width="318" /></a></p><h4>Kvalifikacije za akciju</h4><p>Izvršavanje pojednačnog koraka poziva se akcija koje je asocirana uz njega a karakteristika akcije definira se  kvalifikacijama akcije (<em>Action Qualifiers</em>). To su  slovčane oznake koje definiraju način aktiviranja i trajanja  asociranog programskog segmeta ili POU.</p><ul><li style="text-align: left;"><strong>N</strong> (<em>Non-Stored</em>)<br /> Akcija se izvršavao onoliko dugo koliko traje korak (<em>step</em>).<br /> <a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionN_web.png"><img class="aligncenter size-full wp-image-158" title="SFC_ActionN_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionN_web.png" alt="" height="177" width="480" /></a></li><li style="text-align: left;"><strong>S</strong> (<em>Set</em>)<br /> Akcija se pokreče početkom koraka koji je asociran sa <strong>S</strong> a prekida se početkom koraka koji je asociran s <strong>R</strong><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionN_V3.png">.<br /> </a><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionS_web.png"><img class="aligncenter size-full wp-image-164" title="SFC_ActionS_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionS_web.png" alt="" height="177" width="480" /></a></li><li style="text-align: left;"><strong>R </strong>(<em>Overiding Reset</em>)<br /> Akcije koje su pokrenute s <strong>S, SD, DS,</strong>  i<strong> SL</strong> prekidaju se početkom koraka asociranom s <strong>R.</strong></li><li style="text-align: left;"><strong>L </strong>(<em>Time Limited</em>)<br /> Akcija se pokreče početkom koraka asociranim  s <strong>L</strong> a trajanje je limitirano parametrom T čija vrijednost  mora biti manji od trajanja samog koraka.<br /> <a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionL_web.png"><img class="aligncenter size-full wp-image-167" title="SFC_ActionL_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionL_web.png" alt="" height="177" width="480" /></a></li><li style="text-align: left;"><strong>D </strong>(<em>Time Delayed</em>)<br /> Akcija se pokreče nakon isteka definiranog vremena T (odgoda uklapanja) a traje do kraja trajanja koraka.<br /> <a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionD_web.png"><img class="aligncenter size-full wp-image-168" title="SFC_ActionD_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionD_web.png" alt="" height="177" width="480" /></a></li><li style="text-align: left;"><strong>P </strong>(<em>Pulse</em>)<br /> Akcija traje samo jedan scan ciklus unutar trajanja koraka.<br /> <a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionP_web.png"><img class="aligncenter size-full wp-image-170" title="SFC_ActionP_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionP_web.png" alt="" height="177" width="480" /></a></li><li style="text-align: left;"><strong>SD </strong>(<em>Stored &amp; Time Delayed</em>)<br /> Akcija se pokreče nakon isteka vremena T od početka koraka s kojim je asocirana a traje do početka koraka asociranog  s <strong>R</strong><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionN_V3.png">.<br /> </a><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionSD_web.png"><img class="aligncenter size-full wp-image-173" title="SFC_ActionSD_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionSD_web.png" alt="" height="177" width="480" /></a></li><li style="text-align: left;"><strong>SL</strong>(<em>Stored &amp; Time Limited</em>)<br /> Akcija se pokreče početkom koraka, trajanje joj je definirano parametrom T koji može biti veći od trajanja koraka.  Akcija se može prekinuti početkom koraka koji je asociran s <strong>R</strong></p><h4><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionSL_web.png"><img class="aligncenter size-full wp-image-166" title="SFC_ActionSL_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionSL_web.png" alt="" height="177" width="480" /></a></h4></li></ul><h4>Grananja tijeka</h4><p>Standardni tijek izvršavanja SFC programa je jednostruka petlja ali ona ne može zadovoljiti sve potrebe procesnih algoritama. Često nam je potrebno da se istovremeno izvršavaju nekoliko programskih akcija ili da se neke od njih uslovno pokreču.  U tim slučajevima koristimo grananje tijeka u SFC dijagramu a postoje dva osnovana tipa grananja: <strong><em></em></strong></p><ul><li><strong><em>Uslovno grananje</em></strong> kod kojega se prijelaz na slijedeći korak ostvaruje kada se ispune uslovi paralelno postavljenih prijelaza. Na slici  je jedan primjer uslovnog grananja kojega ću pokušati pojasniti. Nakon inicijalnog koraka <em>S0</em> i zadovoljenja uslova <em>Tr1</em> prelazi se na korak <em>S1</em>. Iz toga koraka je moguće prijeći na korake <em>S2</em> i <em>S3</em> i to na način da se ostvare uslovi <em>Tr2 ili Tr3</em>. Ovi uslovu su obično komplementarni odnosno možemo reči da je to programska struktura <em>IF THEN ELSE</em> . Dakle ako je uspunjen uslov <em>Tr2</em> prelazi se u granu <em>S2-S4</em> koja se potom izvršava. Ispunjenjem uslova <em>Tr6</em> ponovno se vračamo na glavni tijek. Ekvivalentna je priča i s granom <em>S2</em>. Postavlja se pitanje što će se dogoditi ako su nakon koraka <em>S1</em> oba uslova <em>Tr2 i Tr3</em> zadovoljena. U tom slučaju program se izvršava u obje grane ali je trajanje determinirano uslovima u grani dijagrama koja je <strong>NA LIJEVOJ</strong> strani.  U našem slučaju nakon koraka S1 izvršavati će  se koraci <em>S2-S4</em> te <em>S3</em> istovremeno ali u slučaju da se uslov <em>Tr5</em>  zadovolji  prije uslova <em>Tr6</em> program se neće prebaciti na glavni tijek. Isto tako kada se ostvare uslovi <em>Tr4</em> i <em>Tr6</em> bezuvjetno će se prekinut  izvršavanje koraka  <em> S3</em> i i izvršavanje će se vratiti na glavni tijek.</li></ul><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Divergence.png"><img class="aligncenter size-full wp-image-205" title="SFC_Divergence" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Divergence.png" alt="" height="444" width="397" /></a></p><ul><li><strong><em>Paralelno grananje</em></strong> kod kojega se bezuslovno ulazi u izvršavanje paralelnih grana dijagrama. U našem primjeru  nako zadovoljenja uslova <em>Tr2</em> prekida se izvršavanje koraka <em>S1</em> te se simultano započinje s izvršavanjem koraka <em>S2</em> i <em>S4</em> u lijevoj grani te koraka <em>S3</em> u desnoj grani. Kada obje grane dođu do kraja, u našem slučaju kada se izvršavanju koraci <em>S3</em> i <em>S4</em> ispituje se uslov <em>Tr4</em>. Kada se uslov zadovolji prekida se izvršavanje koraka <em>S3</em> i <em>S4</em>, započinje  izvršavanje koraka <em>S5</em> i program se vrača u glavni tijek.  <a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Divergence.png"><br /> </a></li></ul><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Paralele.png"><img class="aligncenter size-full wp-image-195" title="SFC_Paralele" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Paralele.png" alt="" height="416" width="404" /></a></p><p style="text-align: left;">Koristeći se ovdje navedenim pravilima i njihovim kombiniranjem možemo napraviti vrlo efikasni sekvencijalni dijagram  našega procesa. Zahvaljujući tome što koristimo grafičke elemente kojim definiramo  strukture našeg programa mi zapravo već u fazi programiranja procesnog algoritma gradimo rudimentarnu dokumentaciju koja nam olakšava testiranje programa u fazi puštanja u pogon . Isto tako dobro definiran dijagram omogućava efikasno razvijanje i nadogradnju našeg programa od strane drugih programera te razvoj programa u timovima.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Paralele.png"><br /> </a><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Paralele.png"><br /> </a></p><p>&nbsp;</p> ]]></content:encoded> <wfw:commentRss>http://www.quercus-lab.com/iec61131-standard-i-sfc/feed/</wfw:commentRss> <slash:comments>0</slash:comments> </item> </channel> </rss>