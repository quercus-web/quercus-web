<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" ><channel><title>Mikrokontroleri &#8211; Quercus Lab</title> <atom:link href="http://www.quercus-lab.com/category/mikrokontroleri/feed/" rel="self" type="application/rss+xml" /><link>http://www.quercus-lab.com</link> <description>Blog o softverskom razvoju, elektronici ...</description> <lastBuildDate>Wed, 30 Oct 2013 08:40:37 +0000</lastBuildDate> <language>en-US</language> <sy:updatePeriod>hourly</sy:updatePeriod> <sy:updateFrequency>1</sy:updateFrequency> <generator>https://wordpress.org/?v=4.9.8</generator> <item><title>Netduino &#8211; mikrokontroleri na objektni način</title><link>http://www.quercus-lab.com/netduino-mikrokontroleri-na-objektni-nacin/</link> <pubDate>Wed, 30 Jan 2013 08:45:32 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Mikrokontroleri]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=1024</guid> <description><![CDATA[Tjekom razvoja tehnologije kod programera je došlo do  uske specijalizacije područja interesa. Možemo govoriti o dvije osnovne grupe: prva grupu čine programeri aplikacija za osobna  računala  dok drugu  grupu predstavljaju programeri aplikacija koje se izvode na specijaliziranim uređajima nestandardiziranih platformi.  Programeri prve grupe rade  uglavnom na vrlo apstraktnoj razini programiranja dok oni drugi još uvijek [&#8230;]]]></description> <content:encoded><![CDATA[<p><a href="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_logo.png"><img class="alignleft size-full wp-image-1036" title="MicroFramework_logo" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_logo.png" width="180" height="130" /></a>Tjekom razvoja tehnologije kod programera je došlo do  uske specijalizacije područja interesa. Možemo govoriti o dvije osnovne grupe: prva grupu čine programeri aplikacija za osobna  računala  dok drugu  grupu predstavljaju programeri aplikacija koje se izvode na specijaliziranim uređajima nestandardiziranih platformi.  Programeri prve grupe rade  uglavnom na vrlo apstraktnoj razini programiranja dok oni drugi još uvijek moraju imati dobra znanja o hardverskim karakteristikama ciljane opreme. Razvoj telekomunikacija, ponajprije mobilnih uređaja, uvjetovao je potrebu približavanja ove dvije kategorije te je Microsoft odlučio svoje razvojne alate  unificirati za upotrebu u  oba segmenta. Nakon što je izdao reduciranu varijantu osnovnog .NET Frameworka koju je nazvao Compact Framework,  namijenjenu uglavnom  uređajima multimedijskih karakteristika,  pojavila se i inačica koja cilja na  uređaje u segmentu robotizacije i automatizacije pod nazivom Micro Framework. Širenje znanja o ovim programskim proizvodima potaknula je pojava sklopovske opreme za njihovu primjenu. Jedna takva , uslovno rečeno, platforma je  i Netduino. Netduino je modul otvorenog koda dizajniran na  Arduino konceptu koji je vrlo popularan u amaterskoj mikrokontrolerskoj zajednici. Osnovni princip ove filozofije je da za ulazak u svijet mikrokontrolera gotovo ne trebate alat. Dovoljno je da kupite modul uz koje dolaze osnovni set kablova i žica, stavite modul na stol do računala, pokrenete razvojnu aplikaciju, napišete kod i stisnete Run tipku i odmah vidite rezultata svoga rada.</p><h4>Što je Microsoft .NET Micro Framework</h4><p><a href="http://en.wikipedia.org/wiki/.NET_Micro_Framework"><em>Microsoft .NET Micro Framework</em></a> je mala i efikasna .NET <em>runtime</em> okolina za izvršavanje takozvanog upravljanog koda (<i>eng. <a href="http://en.wikipedia.org/wiki/Managed_code">menaged code</a></i>) na malim i resursima ograničenim računarskim platformama na kojima se ne može izvršavati operativni sustav<a href="http://en.wikipedia.org/wiki/Windows_CE"> Windows CE</a> i njegov <a href="http://en.wikipedia.org/wiki/.NET_Compact_Framework">.NET Compact Framework</a>.  .NET Micro Framework je sličan .NET Comapact Frameworku kao i punom <a href="http://en.wikipedia.org/wiki/.NET_Framework">.NET Frameworku</a> što znači da se aplikacije za njega mogu razvijati istim alatima i razvojnim okruženjima. Ovo je tek uvjetno točno jer  je razvoj mikrokontrolerskih aplikacija ovog trenutka moguć samo u <a href="http://en.wikipedia.org/wiki/Microsoft_Visual_Studio">Visual Studiju</a> 2010 s programskim jezicima C# i Visual Basic na Windws platformi te programskim jezikom <a href="http://en.wikipedia.org/wiki/Mono_%28software%29">Mono</a> na Linux platformi. Micro Framework ne zahtjeva temeljni operativni sustav za svoje izvršavanje jer se <em>Common Language Runtime</em> nazvan <em>TinyCLR</em> instalira direktno na hardversku platformu pa se on još naziva i <i>bootable</i><i> runtim</i>.  On je relativno mali i zauzima  samo nekoliko stotina kilobajta RAM memorije i ne zahtjeva procesor koji im jedinicu  za upravljane memorijom (<i>eng. memory management unit-MMU</i>). Osim toga Micro Framework se može izvršavati na  jeftinim 32-bitnim mikrokontrolerima koji troše vrlo malo energije. Razvoj programa za mikrokontrolerske uređaje upotrebom .NET Micro Framework-a razlikuje se od dosadašnjeg  pristupa. Klasična pristup  uzima u obzir specifičnosti odabrane sklopovske opreme kao što su sabirnice, memorijska mapa, prekidni vektori i slično i napisani program se može izvršavati samo na ciljanoj platformi. Micro Framework ima apstraktni pristup sklopovskoj opremi preko baznih klasa koji tu opremu tretira kao objekte što vam omogućava i objektni pristup programiranju. Stoga  ne morate brinuti o konfiguraciji specifičnih sklopovskih komponenti nego samo postaviti određena svojstava korištenih sklopova u baznoj klasi. Ovaj pristup se još  naziva  upotreba <i>managed driver-a </i> i omogućava razvoj aplikacija koje nisu vezane uz određenu sklopovsku opremu. Kao i ostali frameworki  i Micro Framework izvršava upravljani kod odnosno kompajler  generira, o procesoru neovisan, kod koji se naziva <i>intermediate language</i>  a onda se TinyCLR brine da se taj kod izvrši na određenoj platformi. Micro Framework nije sustav za rad u realnom vremenu (<i>eng. real-time</i>) i od njega se ne može očekivati strogo determinističko ponašanje. To znači da nemamo pristup definiranju raspoređivanja odnosno ne možemo egzaktno definirati način i parametre raspoređivanja. Isto tako određeni očekivani događaji mogu biti odgođeni za nekoliko milisekundi  a uzrok tome može biti neki  sistemski zahtjev za prekid ili rad sustava za oslobađanje memorije (<i>eng. Garbage collection</i>) bez obzira što se on aktivira u slobodno sistemsko vrijeme. Isto tako moramo znati da je izvršavanje upravljanog koda u pravilu sporije nego nativnog koda. Razlog  je što se s Micro Framework-om upravljani kod izvršava kao <a href="http://en.wikipedia.org/wiki/Interpreter_%28computing%29">interpreter </a>  za razliku od punog Framework-a i Compact Framework-a gdje postoji takozvani <i>just-in-time</i>  <a href="http://en.wikipedia.org/wiki/Compiler">kompajler</a> koji kod prvog izvršavanja pretvara upravljani u nativni kod.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_arhitektura.png"><img class="aligncenter size-full wp-image-1048" title="MicroFramework_arhitektura" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_arhitektura.png" width="580" height="328" /></a></p><h4>Netduino</h4><p><a href="http://netduino.com/">Netduino </a>je elektronička platforma bazirana na <a href="http://en.wikipedia.org/wiki/ARM_architecture">ARM mikrokontrolerima</a> koju možete programirati koristeći Micro Framework. Razvojno okruženje je Microsoft Visual Studio 2010 ali se može koristiti i  besplatna varzija ( Visual Studio 2010 Express). Netduino je hardverski otvorena platforma što znači da se  <em>firmware</em> kod kao i električne sheme i PCB projekti mogu koristi pod <a href="http://en.wikipedia.org/wiki/Apache_License">Apache 2.0 i BSD open source</a> licencom. Ovoga trena postoje 4 varijante Netduino modula:</p><ol><li>Netduino</li><li>Netduino Plus</li><li>Netduino mini</li><li>Netduino Go</li></ol><p>Moduli su prilagođeni za amatersku primjenu dok se dizajn bazira na popularnom konceptu <a href="http://www.arduino.cc/">Arduina</a> koji je napravljen za AVR mikrokontrolere. To zapravo znači da se na Netduino modulima mogu koristiti gotovo svi dodaci, koji se popularno nazivaju shields,  za Arduino module. Ovih dodataka  ima mnogo, od jednostavnih  senzora do složenih sustava kao što su GSM i drugi komunikcijski moduli.   Shodno tome  Netduno moduli imaju digitale ulaze/izlaze, analoge ulaze, serijske portove te <a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> i <a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">SPI</a> sučelja. Napajanje modula je izvedeno korištenjem nestabiliziranog napona 9-12 V koji se potom stabilizira te su na konektore izvedeni naponi 5V i 3.3V koje možete koristiti za ostatak  hardvera. Napajati module moguće je i preko USB porta koji istovremeno služi i za programiranje modula.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2013/01/NetduinoPlus.png"><img class="aligncenter size-full wp-image-1054" title="NetduinoPlus" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2013/01/NetduinoPlus.png" width="490" height="392" /></a></p><p>Netduino i Netduino Plus (najnovija inačica Netduino Plus 2 ) dizajnirani su upravo na Arduino konceptu i razlikuju se po količini memorije i korištenim sučeljem (Netduino Plus 2 ima Ethernet) dok je Netduino mini baziran na <a href="http://www.parallax.com/tabid/295/default.aspx">Basic Stamp</a> dizajnu. <a href="http://www.netduino.com/netduinomini/specs.htm">Netduino mini</a> je modul je izveden kao 24 pinski DIP chip i njega možete koristiti u svojim projektima upravo kao da  je riječ o standardnom mikrokontroleru. <a href="http://netduino.com/netduinogo/specs.htm">Netduino Go </a>je najnovija inačica i od ostali  se razlikuje po konektorima  i filozofiji univerzalnog sučelja za proširenja koji je nazvan <a href="http://forums.netduino.com/index.php?/topic/5325-introducing-gobus-15/"><em>GoBus</em></a> . GoBus je zapravo virtualni  hadrversko/softverski I/O koncept definiran kao open source protokol baziran na master-slave principu.    Na bilo koji GoBus port se može priključiti bilo koji GoBus modul sa podržanom  plug and play funkcionalnošću.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2013/01/netduinogo.png"><img class="aligncenter size-full wp-image-1055" title="netduinogo" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2013/01/netduinogo.png" width="523" height="477" /></a></p><p>Da bi mogli programirati Netduino module potrebna nam je i određena programska oprema. To se u prvom redu odnosi na Visual Studio prilagođen za Netduino platformu. Potrebne alate možemo podjeliti u tri skupine a to su:</p><ol><li>Visual Studio  2010 razvojna okolina</li><li>.Net Micro Framework razvojni SDK (eng. Software Development Kit)</li><li>Netduino razvojni SDK</li></ol><p>Ove programske pakete najbolje je i instalirati ovim redoslijedom. Kao što sam prije napisao kao razvojna okolin koristi se Microsoft Visual Studio 2010 i o tome kako se on koristi možete naći puno materijala na internetu. Valja samo napomenuti da se može koristiti i besplatna inačica Visual Studio 2010 Express koji možete skinuti sa stranica <a href="http://www.microsoft.com/express/downloads/">http://www.microsoft.com/express/downloads/</a> . Kao osnovni jezik za programiranje zamišljen je   C# ali je kasnije napravljeno da se može koristi i Visual Basic te Mono na Linux platformi. Ove mogućnost  ovisi o firmware-u koji se nalazi u modulu koji ste kupili. Trenutno je aktualna varijanta NETMF4.2 koja podržava i Visual Basic. Ako nabavite module  koji imaju firmaware 4.1 a želite programirati u Visual Basicu potrebno je upisati novi firmware koji možete skinuti s službenih stranica Netduino projekta <a href="http://forums.netduino.com/index.php?/topic/5120-announcing-net-mf-42-upgrade-for-all-netduino-hardware/">http://forums.netduino.com/index.php?/topic/5120-announcing-net-mf-42-upgrade-for-all-netduino-hardware/</a>  a proceduru kako to napraviti  možete naći nai <a href="http://wiki.netduino.com/Installing-the-TinyBooterDecompressor-step-by-step.ashx">wiki stranicama</a> Netduina. Zamjena firmware ne mora biti isključivo radi ovoga razloga nego, kao što je slučaj sa svim platformama otvorenog koda, neke nove mogućnosti i funkcije te ispravljanje grešaka iz prethodnih verzija te će te vjerojatno jednom u budućnosti mijenjati firmware.  .Net Micro Framwork SDK je su sistemske datoteke Visual Studia za spomenuti framework dok je Netduino razvojni SDK prilagođenje Visual Studia za podršku Netduino modula. Zahvaljući njemu će te nakon instalacije u svom VS imati pridodane predloške (<em>eng. template</em> ) za sve spomenute Nedtuino module.</p><h4>Prvi program</h4><p>Nakon uspješne instalacije navedenih programskih pakete i otvaranja kutije s vašim Netduinom spremni ste za pisanje prvog programa.Nakon startanja VS uz ostale predloške naći će se i predlošci za Netduino module. Na vama je da odaberete predložak koji odgovara vašem moduli i VS će izgenerirati vaš prvi projekt.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2013/01/MIcroFramework_VSNeduinoTemplate.png"><img class="aligncenter size-full wp-image-1060" title="MIcroFramework_VSNeduinoTemplate" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2013/01/MIcroFramework_VSNeduinoTemplate.png" width="654" height="363" /></a></p><p style="text-align: left;">Kao i ostali VS projekti i Neduino projekti se spremanju u jedan folder gdje se nalazi sve vezano uz projekt. Ako do sada niste radili s Visual Studiom pogledajte strukturu projekt foldera koji se po defaultu nalazi na <em>&#8230;userDocumentsVisual Studio 2010Projects</em>.  Struktura foldera projekta je gotovo identična kao i za ostale tipove VS projekata osim razlike u <em>Debug</em> i <em>Release</em> subfolderu gdje  će te naći subfoldere [be] i [Ie].  Nakon otvaranja projekta na zaslonu će te imati otvoren editor za pisanje vašeg koda. Za razliku od oubičajnog Visual Basic projekta ovdje nećete imati formu kao polazišnu klasu  nego VB  modul.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_VSNeduinoEditor.png"><img class="aligncenter size-full wp-image-1062" title="MicroFramework_VSNeduinoEditor" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_VSNeduinoEditor.png" width="771" height="492" /></a></p><p style="text-align: left;">Kao što sam rekao program se piše unutar klase <em>Module1.vb</em> a jednostavan program može izgledati ovako:</p><div class="wp_syntax"><table><tr><td class="code"><pre class="vb" style="font-family:monospace;">Module Module1
	<span style="color: #E56717; font-weight: bold;">Sub</span> Main()
		<span style="color: #151B8D; font-weight: bold;">Dim</span> led <span style="color: #151B8D; font-weight: bold;">As</span> OutputPort = <span style="color: #E56717; font-weight: bold;">New</span> OutputPort(Pins.ONBOARD_LED, <span style="color: #00C2FF; font-weight: bold;">False</span>)
	        <span style="color: #8D38C9; font-weight: bold;">Do</span>
	            led.Write(<span style="color: #00C2FF; font-weight: bold;">True</span>)
	            Thread.Sleep(1000)
	            led.Write(<span style="color: #00C2FF; font-weight: bold;">False</span>)
	            Thread.Sleep(1000)
	        <span style="color: #8D38C9; font-weight: bold;">Loop</span>
	<span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #E56717; font-weight: bold;">Sub</span>
<span style="color: #8D38C9; font-weight: bold;">End</span> Module</pre></td></tr></table></div><p style="text-align: left;">Ovaj primjer ima zadatak da na Netduinu pali i gasi ugrađenu LE diodu  <em>Pins.ONBOARD_LED</em> u taktu od 1 Hertza a to se izvršava unutar beskonačne <em>DO&#8230;Loop</em> petlje.</p><p style="text-align: left;">Nakon što ste napisali kod potrebno je program prebaciti u Netduino. Za razliku od programiranja mikrokontrolera na klasičan način ovdje vam nije potreban nikakav programator (niti hardverski niti softverski)  već je sve spremno za programiranje i startanje vašeg programa. Naravno na početku rada ste trebali spojiti Netduino na vaše računalo korištenjem micro usb kabela koji ste dobili uz modul. Ako je sve ispravno instalirano nakon priključivanja modula računalo će prepoznati modul i instalirati potrebne drivere kao i kod priključivanja  drugog usb uređaja. Da bi ste provjerili da li imate vezu s vašim Netduino modulom kliknite na <em> </em><em>My Project</em>    na desnoj strani i otvorit će vam se prozor sa svojstvima vaše aplikacije (<em>Project  Properties</em>). Ovdje možete vidjeti postavke aplikacije, kompajlera, referenci i slično.  Izaberite  <em>.NET Micro Framework</em> i provjerite aktivne postavke.  U polju <em>Device</em> trebao bi se pojaviti vaš Neduino modul dok bi polje <em>Transport</em>  trebalo biti postavljeno na <em>USB</em>. Ako je to tako spremni ste za programiranje vašeg Netduino modula  odnosno &#8220;deplojanje&#8221; kako se to ovdje naziva. To će te učinit na nači da odete u glavni izbornik i izaberete <em>Debug/Start Debug</em> ili jednostavno kliknete na zeleni trokutić (strelicu) u osnovnoj  traci s alatima. U  donjem statusnom  prozoru možete pratiti trenutne operacije programiranja i nakon nekog vremena LED dioda na vašem Netduini bi trebala veselo žmirkati. Sada kada je vaš program u Netduini vi možete zatvoriti VS  bez utjecaja na program u modulu koji je trajno pohranjen. Svaki put kad uključite napajanje (na bilo koji način ) program u Netduinu će se početi izvršavati.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_VSneduinoDeploy.png"><img class="aligncenter size-full wp-image-1065" title="MicroFramework_VSneduinoDeploy" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_VSneduinoDeploy.png" width="706" height="362" /></a></p><p>Moram napomenuti da sam pri pisanju ovoga posta polazio od pretpostavke da ste bar jednom pokušali pisati program u Visual Basicu. Ako to nije tako i ako se, uz upoznavanja s Netdunom, trebate upoznati i sa  osnovama pisanja Visual Basic programa to će te morati učinit sami.  Nadam se da  sam vam bar približio metodologiju programiranja mikrokontrolera u .Net okruženju i želim puno zabavnih trenutaka s Netduinom .</p><p>Još jednom ću ponoviti linkove gdje možete dobiti više informacija i preuzeti potrebne alate:</p><p>Službene stranice Netduino projekta: <a href="http://netduino.com/">http://netduino.com/</a></p><p>Microsoft Micro Framework: <a href="http://www.microsoft.com/net/multiple-platform-support">http://www.microsoft.com/net/multiple-platform-support</a></p><p>Microsoft Visual Studio 2010 Express : <a href="http://www.microsoft.com/visualstudio/eng/products/visual-studio-2010-express">http://www.microsoft.com/visualstudio/eng/products/visual-studio-2010-express<br /> </a></p><p>Netduino forum: <a href="http://forums.netduino.com/">http://forums.netduino.com/</a></p><p>Netduino Wiki stranice: <a href="http://wiki.netduino.com/">http://wiki.netduino.com/</a></p><p>&nbsp;</p><p>&nbsp;</p> ]]></content:encoded> </item> <item><title>Kapacitivne dodirne tipke</title><link>http://www.quercus-lab.com/kapacitivne-dodirne-tipke/</link> <pubDate>Wed, 25 Jan 2012 07:22:47 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Mikrokontroleri]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=489</guid> <description><![CDATA[Do danas su razvijeni raznorazni senzori na dodir,  počevši od čisto vodljivih tipova apliciranih na televizijskim aparatima osamdesetih godina  prošlog stoljeća, pa  preko optičkih, do današnjih otporničkih i kapacitivnih koji se koriste na modernim mobilnim telefonima. Njihov razvoj i primjena  uvjetovana je razvojem tehnoloških postupaka i elektronskih komponenti a veliki napredak je napravljen masovnom produkcijom [&#8230;]]]></description> <content:encoded><![CDATA[<p><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_logo2.png"><img class="size-full wp-image-691 alignleft" title="touch_logo2" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_logo2.png" width="180" height="130" /></a>Do danas su razvijeni raznorazni senzori na dodir,  počevši od čisto vodljivih tipova apliciranih na televizijskim aparatima osamdesetih godina  prošlog stoljeća, pa  preko optičkih, do današnjih otporničkih i kapacitivnih koji se koriste na modernim mobilnim telefonima. Njihov razvoj i primjena  uvjetovana je razvojem tehnoloških postupaka i elektronskih komponenti a veliki napredak je napravljen masovnom produkcijom i primjenom mikrokontrolera. Kapacitivna metoda detekcije dodira danas je najraširenija koristi se  gotovo na svim elektronskim uređajima počevši od kontrolnih panela u kabinama za tuširanje do prijenosnih računala i mobitela.  Mnogi proizvođači elektronskih komponenti u svom proizvodnom programu imaju integrirane krugove koji omogućavaju razvoj dodirnog sučelja. Na zadovoljstvo mnogih zaljubljenika elektronike ona je aplikativna na najmanjim mikrokontrolerima i  ovdje je opisana jedna jednostavna metoda na mikrokotroleru  Atmel ATtiny2131</p><h3>Princip rada</h3><p>Osnovni princip rada kapacitivnih senzora osjetljivih na dodir je promjena kapaciteta područja dodira. Metoda detekcije promjena je različita a ovdje će se objasniti metoda koja je uobičajena u većini mjerača kapaciteta a radi se integracijskoj metodi mjerenja. Algoritam metode je usporedba vremena trajanja nabijanja kondenzatora poznatog kapaciteta sa vremenom nabijanja nepoznatog a na osnovu njihovog omjera se izračunava kapacitet nepoznatog kondenzatora. Za primjenu metode kod dodirne tipke nama treba samo sigurna detekcije promjene kapaciteta i to je osnovni zahtjev jer je promjena kapaciteta vrlo mala.Poznato je iz osnova elektrotehnike da svaka  elektronska komponenta pa tako i mikrokontroler odnosno njegov I/O port posjeduje parazitni kapacite i on se koristi kao etalonski kondenzator <em>C<sub>s</sub></em>. Nepoznati kondenzator  <em>C<sub>x</sub></em> je kapacitet ljudskog tijela  koji po <a href="http://en.wikipedia.org/wiki/Human-body_mode">modelu za ESD </a>ima kapacitet do 100 <em>pF</em>  i koji se formira kada se prstom dodirne metalna  površina izolirana nekim tankim izolatorom. Ako za mikrokontroler izaberemo ATTiny2313 odnosno  parazitni kapacitet  je oko 15 pF i prijelazna pojava punjenja toga kondenzatora na napon koji  se detektira kao logička 1 ( a to je po specifikacijama 2,65 V kod napajanja 5V) traje oko 9 mikrosekundi. Ako kao jednu elektrodu drugog kondenzatora pripremimo područje bakra na tiskanoj pločici površine 16&#215;16 mm to vrijeme punjenja se produžuje na oko 16 mikrosekundi  i to je ta vremenska razlika koju moramo iskoristiti kao detekciju dodira odnosnu &#8220;pritisnute&#8221; tipke.</p><p><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_scope.png"><img class="aligncenter size-full wp-image-699" title="touch_scope" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_scope.png" width="625" height="472" /></a>Da bi osigurali detekciju promjene kapaciteta poslužit će mo se standardnim I/O portom mikrokontrolera Atmel ATTiny2313 jer on sadrži sve električne i programske komponente potrebne za to. Koristit ćemo registre <em>DDRx.n, PORTx.n i PINx.n</em> gdje x označava korišteni port (A,B ,C, D) dok n označava broj bita porta(0-7). <em>DDR</em> registar služi za definiranje da li će port biti korišten kao ulazni ili izlazni. Ako je njegova vrijednost 0 port se koristi kao ulaz te će  registar <em>PORT</em> biti odspojen od pina mikrokontrolera tako da stanje registra <em>PORT</em> neće imati utjecaja na stanje pina. Druga namjena <em>DDR</em> registra je uključivanje <em>pull-up</em> otpornika koji su integrirani u mikrokontroler. Ako je  port definiran kao ulaz (DDRx.n=0)  s registrom <em>PORTx.n</em> se uključuje (<em>PORTx.n=1</em>)  odnosno  isključuje (<em>PORTx.n=0</em>) navedeni otpornik. Osnovna namjena registra <em>PORTx.n </em> je jasno odnosno on spaja pin mikrokontrolera na <em>Vcc</em> odnosno <em>Gnd</em> ako je I/O  port definiran kao izlaz (<em>DDRxn=1</em>).  Namjena Registar <em>PINx.n</em>  je  uvijek ista a to je da čita logičko stanje pina mikrokontrolera. Od ostalih vanjskih komponenti potrebna nam je jedan otpornik preko kojeg ćemo trajno spojiti pin mikrokontrolera na Vcc napajanje te površina bakra tiskane pločice koja će služiti kao jedna ploča kondenzatora odnosno imati ulogu senzora i  ova površina mora biti pokrivena nekim  izolatorom.</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_unloadC.png"><img class="aligncenter size-full wp-image-705" title="touch_unloadC" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_unloadC.png" width="506" height="382" /></a>Navedene komponente će nam poslužiti za generiranje dva osnovna stanja a to je pražnaje i punjenje kondenzatora. Pražnjenje se ostvaruje na način da se stanje registra  <em>PORTx.n</em> postavi u logičku nulu a potom se stanje <em>DDRx.n</em> registra promjeni u logičku jedinicu. Na taj način će se pin mikrokontrolera postaviti u nulu  što će rezultirati pražnjenjem kondenzatora <em>C</em><sub><em>s</em>.</sub>  i sada je sustav spreman za mjernu sekvencu. Postavljanjem <em>DDRx.n</em> registra u logiču nulu odspaja se pin mikrokontrolera od <em>PORTx.n</em> registra te je omogućeno  punjenje kondenzatora preko vanjskog otpornika <em>R</em>.</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_loadC.png"><img class="aligncenter size-full wp-image-711" title="touch_loadC" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_loadC.png" width="507" height="382" /></a>Istovremeno s početkom punjenja aktivira se mjerenje vremena i  čitajući stanje registra <em>PINx.n</em> provjerava se logičko stanje ulaza odnosno napon na kondenzatoru. Kada je vrijednost <em>PINx.n</em> registra logička jedinica zapamti se vrijeme punjenja i to etalonsko vrijeme i označava stanje <em>&#8220;dodir nije detektiran&#8221;</em> odnosno <em>&#8220;tipka nije stisnuta&#8221;</em>. Kada se prstom dodirne površina &#8220;senzora&#8221; na tiskanoj pločici spaja se kondenzatoru <em>Cs</em> još jedan <em>Cx</em> (paralelno) a vrijeme potrebno da se detektira logička jedinica registra PNx.n se produžava. To prekoračenje prije izmjerenog etalonskog vremena omogućava da se detektira prisutnost prsta na senzoru odnosno stanje<em> &#8220;taster je stisnut&#8221;</em>.</p><h3 style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_loadCfinger.png"><img class="aligncenter size-full wp-image-714" title="touch_loadCfinger" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_loadCfinger.png" width="509" height="383" /></a>Programska izvedba</h3><p>Gore opisane sekvence vrlo je jednostavno izvesti i to ćemo napravit u <a href="http://www.mcselec.com/index.php?option=com_content&amp;task=view&amp;id=14&amp;Itemid=41">BASCOM</a> programskom jeziku. Na početku je potrebno izmjeriti vrijeme da se parazitni kondenzator <em>Cs</em> bez prisutnosti prsta na senzoru nabije na logičku jedinicu i to spremiti u varijablu <em>TouchTreshold.</em> Učiniti ćemo to u <em>DO&#8230; LOOP</em> u petlji  u koji će biti sekvenca pražnjenja kondenzatora (2 milisekunde), početak punjenja, čekanje od <em>TouchTreshold </em>mikrosekundi  te provjeravanje da li je pin u logičkoj jednici. Poslije toga na početku slijedeće  iteracije  petlje povečavamo varijablu <em>TouchTreshold</em> za 1. Kada se detektira logička jedinica na pinu izlazimo iz <em>DO ..LOOP</em> petlje i trenutna vrijednost  varijable<em> TouchTreshold </em>  je  prije spomenuto etalonsko vrijeme . Tom vremenu dodajemo još 2 mikrosekunde da bi sa sigurnošću  detektirali neprisutnost prsta.</p><div class="wp_syntax"><table><tr><td class="code"><pre class="qbasic" style="font-family:monospace;"><span style="color: #a1a100;">DO</span>
   TouchTreshold <span style="color: #66cc66;">=</span> TouchTreshold <span style="color: #66cc66;">+</span> <span style="color: #cc66cc;">1</span>
   DDRD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">1</span> : PORTD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">0</span>                      <span style="color: #808080;">' prazni</span>
   waitms <span style="color: #cc66cc;">2</span>
   PORTD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">0</span> : DDRD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">0</span>                      <span style="color: #808080;">' start punjenja</span>
   waitus TouchTreshold
   <span style="color: #a1a100;">IF</span> PIND.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">1</span> <span style="color: #a1a100;">THEN</span>                            <span style="color: #808080;">' provjera napunjenosti</span>
      TouchTreshold <span style="color: #66cc66;">=</span> TouchTreshold <span style="color: #66cc66;">+</span> <span style="color: #cc66cc;">2</span>
      <span style="color: #000066;">EXIT</span> <span style="color: #a1a100;">DO</span>
   endif
<span style="color: #a1a100;">LOOP</span></pre></td></tr></table></div><p>Nakon što smo ovo napravili možemo u glavnom programu skenirati sve naše senzor, detektirati dodir i izvršiti određene akcije. Program je sličan inicijalizacijskom dijelu samo što ovdje kao rezultat na provjeru  napunjenosti palimo ili gasimo signalizacijsku diodu. Dakle nakon što smo ispraznili kondenzator počinjemo ga puniti  te  testiramo da li je on pun nakon  vremena koje je dobiveno u inicijalizacijskoj sekvenci. Ako je nakon toga vremena pin nije logičkoj jedinici znači da je ukupni kapacitet  koji se puni veći od parazitnog kapaciteta <em>C<sub>s</sub></em> odnosno površina senzora je dotaknuta prstom. U listingi programa je kod samo za 1 kanal i koristi se pin 7 (<em>PD3</em>) kao senzor a pin 18 (<em>PB6</em>) kao indikacija  dodirnutog senzora.</p><div class="wp_syntax"><table><tr><td class="code"><pre class="qbasic" style="font-family:monospace;">LED1 <span style="color: #000066;">ALIAS</span> PORTB.6
<span style="color: #a1a100;">DO</span>
   <span style="color: #808080;">' Channel 1</span>
   DDRD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">1</span> : PORTD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">0</span>                     <span style="color: #808080;">' prazni</span>
   waitms <span style="color: #cc66cc;">2</span>
   PORTD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">0</span> : DDRD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">0</span>                     <span style="color: #808080;">' start punjenja</span>
   waitus TouchTreshold
   <span style="color: #a1a100;">IF</span> PIND.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">0</span> <span style="color: #a1a100;">THEN</span>                           <span style="color: #808080;">' provjera napunjenosti</span>
      LED1<span style="color: #66cc66;">=</span><span style="color: #cc66cc;">1</span>
   <span style="color: #a1a100;">ELSE</span>
      LED1<span style="color: #66cc66;">=</span><span style="color: #cc66cc;">0</span>
   endif
<span style="color: #a1a100;">LOOP</span></pre></td></tr></table></div><h3>Praktična realizacija</h3><p>Kao prototip je napravljena tipkovnica s četiri dodirne tipke. To je ustvari elektronski modul koji  bi trebao zamijeniti četiri standarne tipke na malom operatorskom panelu u  mojem projektu kučne automatizacije. Svaka dodirna tipka ima svjetlosnu  indikaciju kao povratnu informaciju  &#8220;pritiska&#8221; tipke. Upotrebljeni mikrokontroler je ATtiny2313 a sam modul nema   stabilizirano napajanje već se napaja s 5V iz uređaja na kojem će biti. Izlazni signali su četiri digitalna izlaza koji poprimaju  stanje dodirne tipke a pomoću kratkospojnika na pinu 3 (PD1) može se definirati signal &#8220;pritisnute&#8221; tipke . Izlazni signal da je tipka  &#8220;pritisnuta&#8221; bit će onog  logičkog nivoa koji je trenutno na pinu 3.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_keypad.png"><img class="aligncenter size-full wp-image-759" title="touch_keypad" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_keypad.png" width="558" height="222" /></a></p><p style="text-align: left;">Tipkovnica je napravljena na dvostranom  tiskanoj pločici  tako da su na gornjem <em>layeru</em> dodirni senzori odnosno bakrene površine velićine 16&#215;16 milimetara.  Ostali elementi su smješteni odozdola te  su,  iako standarne veličine, lemljeni su  kao <a href="http://en.wikipedia.org/wiki/SMD">smd</a> elementi  dok bi finalna variajanta svakako trebala biti prava smd.  Žice koje se vide su za napajanje (plava i crvena) i za eksterni <a href="http://en.wikipedia.org/wiki/In-system_programming">ISP programator.</a></p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_board.png"><img class="aligncenter size-full wp-image-762" title="touch_board" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_board.png" width="534" height="223" /></a></p><p style="text-align: left;"><em></em>Električna shema je jedostavn i iz nje se vidi da je korišten ATtiny2313  s vlastitim  generatorom takta i rudimentarnim reset krugom. Otpornici na senzorima dodira su 680 kilooma i njihova vrijednost je utvrđeni  eksperimentalno. Oni ovise površini dodirnog senzora te debljine i tipu izolacije (prednje maske) pa će te vjerojatno njih morati utvrditi eksperimentalno u neki drugim izvedbama.<a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_schematic.png"> <img class="aligncenter size-full wp-image-749" title="touch_schematic" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_schematic.png" width="692" height="451" /></a>Prototipni modul je u  fazi testiranja radio vrlo pouzdano ali nije testiran u težem radnom okruženu (što mu nije bila ni namjena).</p><p style="text-align: center;">[jwplayer mediaid=&#8221;1030&#8243;]</p><p style="text-align: left;">Datoteku koja sadrži  shemu, tiskanu pločicu, izvorni te izvršni kod možete skinuti ovdje: <a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/TouchKeypad_quercus-lab.zip">TouchKeypad_quercus-lab</a></p> ]]></content:encoded> </item> </channel> </rss>