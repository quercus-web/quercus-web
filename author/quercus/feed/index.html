<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" ><channel><title>quercus &#8211; Quercus Lab</title> <atom:link href="http://www.quercus-lab.com/author/quercus/feed/" rel="self" type="application/rss+xml" /><link>http://www.quercus-lab.com</link> <description>Blog o softverskom razvoju, elektronici ...</description> <lastBuildDate>Wed, 30 Oct 2013 08:40:37 +0000</lastBuildDate> <language>en-US</language> <sy:updatePeriod>hourly</sy:updatePeriod> <sy:updateFrequency>1</sy:updateFrequency> <generator>https://wordpress.org/?v=4.9.8</generator> <item><title>Netduino &#8211; mikrokontroleri na objektni način</title><link>http://www.quercus-lab.com/netduino-mikrokontroleri-na-objektni-nacin/</link> <pubDate>Wed, 30 Jan 2013 08:45:32 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Mikrokontroleri]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=1024</guid> <description><![CDATA[Tjekom razvoja tehnologije kod programera je došlo do  uske specijalizacije područja interesa. Možemo govoriti o dvije osnovne grupe: prva grupu čine programeri aplikacija za osobna  računala  dok drugu  grupu predstavljaju programeri aplikacija koje se izvode na specijaliziranim uređajima nestandardiziranih platformi.  Programeri prve grupe rade  uglavnom na vrlo apstraktnoj razini programiranja dok oni drugi još uvijek [&#8230;]]]></description> <content:encoded><![CDATA[<p><a href="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_logo.png"><img class="alignleft size-full wp-image-1036" title="MicroFramework_logo" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_logo.png" width="180" height="130" /></a>Tjekom razvoja tehnologije kod programera je došlo do  uske specijalizacije područja interesa. Možemo govoriti o dvije osnovne grupe: prva grupu čine programeri aplikacija za osobna  računala  dok drugu  grupu predstavljaju programeri aplikacija koje se izvode na specijaliziranim uređajima nestandardiziranih platformi.  Programeri prve grupe rade  uglavnom na vrlo apstraktnoj razini programiranja dok oni drugi još uvijek moraju imati dobra znanja o hardverskim karakteristikama ciljane opreme. Razvoj telekomunikacija, ponajprije mobilnih uređaja, uvjetovao je potrebu približavanja ove dvije kategorije te je Microsoft odlučio svoje razvojne alate  unificirati za upotrebu u  oba segmenta. Nakon što je izdao reduciranu varijantu osnovnog .NET Frameworka koju je nazvao Compact Framework,  namijenjenu uglavnom  uređajima multimedijskih karakteristika,  pojavila se i inačica koja cilja na  uređaje u segmentu robotizacije i automatizacije pod nazivom Micro Framework. Širenje znanja o ovim programskim proizvodima potaknula je pojava sklopovske opreme za njihovu primjenu. Jedna takva , uslovno rečeno, platforma je  i Netduino. Netduino je modul otvorenog koda dizajniran na  Arduino konceptu koji je vrlo popularan u amaterskoj mikrokontrolerskoj zajednici. Osnovni princip ove filozofije je da za ulazak u svijet mikrokontrolera gotovo ne trebate alat. Dovoljno je da kupite modul uz koje dolaze osnovni set kablova i žica, stavite modul na stol do računala, pokrenete razvojnu aplikaciju, napišete kod i stisnete Run tipku i odmah vidite rezultata svoga rada.</p><h4>Što je Microsoft .NET Micro Framework</h4><p><a href="http://en.wikipedia.org/wiki/.NET_Micro_Framework"><em>Microsoft .NET Micro Framework</em></a> je mala i efikasna .NET <em>runtime</em> okolina za izvršavanje takozvanog upravljanog koda (<i>eng. <a href="http://en.wikipedia.org/wiki/Managed_code">menaged code</a></i>) na malim i resursima ograničenim računarskim platformama na kojima se ne može izvršavati operativni sustav<a href="http://en.wikipedia.org/wiki/Windows_CE"> Windows CE</a> i njegov <a href="http://en.wikipedia.org/wiki/.NET_Compact_Framework">.NET Compact Framework</a>.  .NET Micro Framework je sličan .NET Comapact Frameworku kao i punom <a href="http://en.wikipedia.org/wiki/.NET_Framework">.NET Frameworku</a> što znači da se aplikacije za njega mogu razvijati istim alatima i razvojnim okruženjima. Ovo je tek uvjetno točno jer  je razvoj mikrokontrolerskih aplikacija ovog trenutka moguć samo u <a href="http://en.wikipedia.org/wiki/Microsoft_Visual_Studio">Visual Studiju</a> 2010 s programskim jezicima C# i Visual Basic na Windws platformi te programskim jezikom <a href="http://en.wikipedia.org/wiki/Mono_%28software%29">Mono</a> na Linux platformi. Micro Framework ne zahtjeva temeljni operativni sustav za svoje izvršavanje jer se <em>Common Language Runtime</em> nazvan <em>TinyCLR</em> instalira direktno na hardversku platformu pa se on još naziva i <i>bootable</i><i> runtim</i>.  On je relativno mali i zauzima  samo nekoliko stotina kilobajta RAM memorije i ne zahtjeva procesor koji im jedinicu  za upravljane memorijom (<i>eng. memory management unit-MMU</i>). Osim toga Micro Framework se može izvršavati na  jeftinim 32-bitnim mikrokontrolerima koji troše vrlo malo energije. Razvoj programa za mikrokontrolerske uređaje upotrebom .NET Micro Framework-a razlikuje se od dosadašnjeg  pristupa. Klasična pristup  uzima u obzir specifičnosti odabrane sklopovske opreme kao što su sabirnice, memorijska mapa, prekidni vektori i slično i napisani program se može izvršavati samo na ciljanoj platformi. Micro Framework ima apstraktni pristup sklopovskoj opremi preko baznih klasa koji tu opremu tretira kao objekte što vam omogućava i objektni pristup programiranju. Stoga  ne morate brinuti o konfiguraciji specifičnih sklopovskih komponenti nego samo postaviti određena svojstava korištenih sklopova u baznoj klasi. Ovaj pristup se još  naziva  upotreba <i>managed driver-a </i> i omogućava razvoj aplikacija koje nisu vezane uz određenu sklopovsku opremu. Kao i ostali frameworki  i Micro Framework izvršava upravljani kod odnosno kompajler  generira, o procesoru neovisan, kod koji se naziva <i>intermediate language</i>  a onda se TinyCLR brine da se taj kod izvrši na određenoj platformi. Micro Framework nije sustav za rad u realnom vremenu (<i>eng. real-time</i>) i od njega se ne može očekivati strogo determinističko ponašanje. To znači da nemamo pristup definiranju raspoređivanja odnosno ne možemo egzaktno definirati način i parametre raspoređivanja. Isto tako određeni očekivani događaji mogu biti odgođeni za nekoliko milisekundi  a uzrok tome može biti neki  sistemski zahtjev za prekid ili rad sustava za oslobađanje memorije (<i>eng. Garbage collection</i>) bez obzira što se on aktivira u slobodno sistemsko vrijeme. Isto tako moramo znati da je izvršavanje upravljanog koda u pravilu sporije nego nativnog koda. Razlog  je što se s Micro Framework-om upravljani kod izvršava kao <a href="http://en.wikipedia.org/wiki/Interpreter_%28computing%29">interpreter </a>  za razliku od punog Framework-a i Compact Framework-a gdje postoji takozvani <i>just-in-time</i>  <a href="http://en.wikipedia.org/wiki/Compiler">kompajler</a> koji kod prvog izvršavanja pretvara upravljani u nativni kod.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_arhitektura.png"><img class="aligncenter size-full wp-image-1048" title="MicroFramework_arhitektura" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_arhitektura.png" width="580" height="328" /></a></p><h4>Netduino</h4><p><a href="http://netduino.com/">Netduino </a>je elektronička platforma bazirana na <a href="http://en.wikipedia.org/wiki/ARM_architecture">ARM mikrokontrolerima</a> koju možete programirati koristeći Micro Framework. Razvojno okruženje je Microsoft Visual Studio 2010 ali se može koristiti i  besplatna varzija ( Visual Studio 2010 Express). Netduino je hardverski otvorena platforma što znači da se  <em>firmware</em> kod kao i električne sheme i PCB projekti mogu koristi pod <a href="http://en.wikipedia.org/wiki/Apache_License">Apache 2.0 i BSD open source</a> licencom. Ovoga trena postoje 4 varijante Netduino modula:</p><ol><li>Netduino</li><li>Netduino Plus</li><li>Netduino mini</li><li>Netduino Go</li></ol><p>Moduli su prilagođeni za amatersku primjenu dok se dizajn bazira na popularnom konceptu <a href="http://www.arduino.cc/">Arduina</a> koji je napravljen za AVR mikrokontrolere. To zapravo znači da se na Netduino modulima mogu koristiti gotovo svi dodaci, koji se popularno nazivaju shields,  za Arduino module. Ovih dodataka  ima mnogo, od jednostavnih  senzora do složenih sustava kao što su GSM i drugi komunikcijski moduli.   Shodno tome  Netduno moduli imaju digitale ulaze/izlaze, analoge ulaze, serijske portove te <a href="http://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> i <a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">SPI</a> sučelja. Napajanje modula je izvedeno korištenjem nestabiliziranog napona 9-12 V koji se potom stabilizira te su na konektore izvedeni naponi 5V i 3.3V koje možete koristiti za ostatak  hardvera. Napajati module moguće je i preko USB porta koji istovremeno služi i za programiranje modula.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2013/01/NetduinoPlus.png"><img class="aligncenter size-full wp-image-1054" title="NetduinoPlus" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2013/01/NetduinoPlus.png" width="490" height="392" /></a></p><p>Netduino i Netduino Plus (najnovija inačica Netduino Plus 2 ) dizajnirani su upravo na Arduino konceptu i razlikuju se po količini memorije i korištenim sučeljem (Netduino Plus 2 ima Ethernet) dok je Netduino mini baziran na <a href="http://www.parallax.com/tabid/295/default.aspx">Basic Stamp</a> dizajnu. <a href="http://www.netduino.com/netduinomini/specs.htm">Netduino mini</a> je modul je izveden kao 24 pinski DIP chip i njega možete koristiti u svojim projektima upravo kao da  je riječ o standardnom mikrokontroleru. <a href="http://netduino.com/netduinogo/specs.htm">Netduino Go </a>je najnovija inačica i od ostali  se razlikuje po konektorima  i filozofiji univerzalnog sučelja za proširenja koji je nazvan <a href="http://forums.netduino.com/index.php?/topic/5325-introducing-gobus-15/"><em>GoBus</em></a> . GoBus je zapravo virtualni  hadrversko/softverski I/O koncept definiran kao open source protokol baziran na master-slave principu.    Na bilo koji GoBus port se može priključiti bilo koji GoBus modul sa podržanom  plug and play funkcionalnošću.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2013/01/netduinogo.png"><img class="aligncenter size-full wp-image-1055" title="netduinogo" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2013/01/netduinogo.png" width="523" height="477" /></a></p><p>Da bi mogli programirati Netduino module potrebna nam je i određena programska oprema. To se u prvom redu odnosi na Visual Studio prilagođen za Netduino platformu. Potrebne alate možemo podjeliti u tri skupine a to su:</p><ol><li>Visual Studio  2010 razvojna okolina</li><li>.Net Micro Framework razvojni SDK (eng. Software Development Kit)</li><li>Netduino razvojni SDK</li></ol><p>Ove programske pakete najbolje je i instalirati ovim redoslijedom. Kao što sam prije napisao kao razvojna okolin koristi se Microsoft Visual Studio 2010 i o tome kako se on koristi možete naći puno materijala na internetu. Valja samo napomenuti da se može koristiti i besplatna inačica Visual Studio 2010 Express koji možete skinuti sa stranica <a href="http://www.microsoft.com/express/downloads/">http://www.microsoft.com/express/downloads/</a> . Kao osnovni jezik za programiranje zamišljen je   C# ali je kasnije napravljeno da se može koristi i Visual Basic te Mono na Linux platformi. Ove mogućnost  ovisi o firmware-u koji se nalazi u modulu koji ste kupili. Trenutno je aktualna varijanta NETMF4.2 koja podržava i Visual Basic. Ako nabavite module  koji imaju firmaware 4.1 a želite programirati u Visual Basicu potrebno je upisati novi firmware koji možete skinuti s službenih stranica Netduino projekta <a href="http://forums.netduino.com/index.php?/topic/5120-announcing-net-mf-42-upgrade-for-all-netduino-hardware/">http://forums.netduino.com/index.php?/topic/5120-announcing-net-mf-42-upgrade-for-all-netduino-hardware/</a>  a proceduru kako to napraviti  možete naći nai <a href="http://wiki.netduino.com/Installing-the-TinyBooterDecompressor-step-by-step.ashx">wiki stranicama</a> Netduina. Zamjena firmware ne mora biti isključivo radi ovoga razloga nego, kao što je slučaj sa svim platformama otvorenog koda, neke nove mogućnosti i funkcije te ispravljanje grešaka iz prethodnih verzija te će te vjerojatno jednom u budućnosti mijenjati firmware.  .Net Micro Framwork SDK je su sistemske datoteke Visual Studia za spomenuti framework dok je Netduino razvojni SDK prilagođenje Visual Studia za podršku Netduino modula. Zahvaljući njemu će te nakon instalacije u svom VS imati pridodane predloške (<em>eng. template</em> ) za sve spomenute Nedtuino module.</p><h4>Prvi program</h4><p>Nakon uspješne instalacije navedenih programskih pakete i otvaranja kutije s vašim Netduinom spremni ste za pisanje prvog programa.Nakon startanja VS uz ostale predloške naći će se i predlošci za Netduino module. Na vama je da odaberete predložak koji odgovara vašem moduli i VS će izgenerirati vaš prvi projekt.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2013/01/MIcroFramework_VSNeduinoTemplate.png"><img class="aligncenter size-full wp-image-1060" title="MIcroFramework_VSNeduinoTemplate" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2013/01/MIcroFramework_VSNeduinoTemplate.png" width="654" height="363" /></a></p><p style="text-align: left;">Kao i ostali VS projekti i Neduino projekti se spremanju u jedan folder gdje se nalazi sve vezano uz projekt. Ako do sada niste radili s Visual Studiom pogledajte strukturu projekt foldera koji se po defaultu nalazi na <em>&#8230;userDocumentsVisual Studio 2010Projects</em>.  Struktura foldera projekta je gotovo identična kao i za ostale tipove VS projekata osim razlike u <em>Debug</em> i <em>Release</em> subfolderu gdje  će te naći subfoldere [be] i [Ie].  Nakon otvaranja projekta na zaslonu će te imati otvoren editor za pisanje vašeg koda. Za razliku od oubičajnog Visual Basic projekta ovdje nećete imati formu kao polazišnu klasu  nego VB  modul.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_VSNeduinoEditor.png"><img class="aligncenter size-full wp-image-1062" title="MicroFramework_VSNeduinoEditor" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_VSNeduinoEditor.png" width="771" height="492" /></a></p><p style="text-align: left;">Kao što sam rekao program se piše unutar klase <em>Module1.vb</em> a jednostavan program može izgledati ovako:</p><div class="wp_syntax"><table><tr><td class="code"><pre class="vb" style="font-family:monospace;">Module Module1
	<span style="color: #E56717; font-weight: bold;">Sub</span> Main()
		<span style="color: #151B8D; font-weight: bold;">Dim</span> led <span style="color: #151B8D; font-weight: bold;">As</span> OutputPort = <span style="color: #E56717; font-weight: bold;">New</span> OutputPort(Pins.ONBOARD_LED, <span style="color: #00C2FF; font-weight: bold;">False</span>)
	        <span style="color: #8D38C9; font-weight: bold;">Do</span>
	            led.Write(<span style="color: #00C2FF; font-weight: bold;">True</span>)
	            Thread.Sleep(1000)
	            led.Write(<span style="color: #00C2FF; font-weight: bold;">False</span>)
	            Thread.Sleep(1000)
	        <span style="color: #8D38C9; font-weight: bold;">Loop</span>
	<span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #E56717; font-weight: bold;">Sub</span>
<span style="color: #8D38C9; font-weight: bold;">End</span> Module</pre></td></tr></table></div><p style="text-align: left;">Ovaj primjer ima zadatak da na Netduinu pali i gasi ugrađenu LE diodu  <em>Pins.ONBOARD_LED</em> u taktu od 1 Hertza a to se izvršava unutar beskonačne <em>DO&#8230;Loop</em> petlje.</p><p style="text-align: left;">Nakon što ste napisali kod potrebno je program prebaciti u Netduino. Za razliku od programiranja mikrokontrolera na klasičan način ovdje vam nije potreban nikakav programator (niti hardverski niti softverski)  već je sve spremno za programiranje i startanje vašeg programa. Naravno na početku rada ste trebali spojiti Netduino na vaše računalo korištenjem micro usb kabela koji ste dobili uz modul. Ako je sve ispravno instalirano nakon priključivanja modula računalo će prepoznati modul i instalirati potrebne drivere kao i kod priključivanja  drugog usb uređaja. Da bi ste provjerili da li imate vezu s vašim Netduino modulom kliknite na <em> </em><em>My Project</em>    na desnoj strani i otvorit će vam se prozor sa svojstvima vaše aplikacije (<em>Project  Properties</em>). Ovdje možete vidjeti postavke aplikacije, kompajlera, referenci i slično.  Izaberite  <em>.NET Micro Framework</em> i provjerite aktivne postavke.  U polju <em>Device</em> trebao bi se pojaviti vaš Neduino modul dok bi polje <em>Transport</em>  trebalo biti postavljeno na <em>USB</em>. Ako je to tako spremni ste za programiranje vašeg Netduino modula  odnosno &#8220;deplojanje&#8221; kako se to ovdje naziva. To će te učinit na nači da odete u glavni izbornik i izaberete <em>Debug/Start Debug</em> ili jednostavno kliknete na zeleni trokutić (strelicu) u osnovnoj  traci s alatima. U  donjem statusnom  prozoru možete pratiti trenutne operacije programiranja i nakon nekog vremena LED dioda na vašem Netduini bi trebala veselo žmirkati. Sada kada je vaš program u Netduini vi možete zatvoriti VS  bez utjecaja na program u modulu koji je trajno pohranjen. Svaki put kad uključite napajanje (na bilo koji način ) program u Netduinu će se početi izvršavati.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_VSneduinoDeploy.png"><img class="aligncenter size-full wp-image-1065" title="MicroFramework_VSneduinoDeploy" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2013/01/MicroFramework_VSneduinoDeploy.png" width="706" height="362" /></a></p><p>Moram napomenuti da sam pri pisanju ovoga posta polazio od pretpostavke da ste bar jednom pokušali pisati program u Visual Basicu. Ako to nije tako i ako se, uz upoznavanja s Netdunom, trebate upoznati i sa  osnovama pisanja Visual Basic programa to će te morati učinit sami.  Nadam se da  sam vam bar približio metodologiju programiranja mikrokontrolera u .Net okruženju i želim puno zabavnih trenutaka s Netduinom .</p><p>Još jednom ću ponoviti linkove gdje možete dobiti više informacija i preuzeti potrebne alate:</p><p>Službene stranice Netduino projekta: <a href="http://netduino.com/">http://netduino.com/</a></p><p>Microsoft Micro Framework: <a href="http://www.microsoft.com/net/multiple-platform-support">http://www.microsoft.com/net/multiple-platform-support</a></p><p>Microsoft Visual Studio 2010 Express : <a href="http://www.microsoft.com/visualstudio/eng/products/visual-studio-2010-express">http://www.microsoft.com/visualstudio/eng/products/visual-studio-2010-express<br /> </a></p><p>Netduino forum: <a href="http://forums.netduino.com/">http://forums.netduino.com/</a></p><p>Netduino Wiki stranice: <a href="http://wiki.netduino.com/">http://wiki.netduino.com/</a></p><p>&nbsp;</p><p>&nbsp;</p> ]]></content:encoded> </item> <item><title>VB OPC klijent</title><link>http://www.quercus-lab.com/vb-opc-klijent/</link> <pubDate>Mon, 01 Oct 2012 18:06:51 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Automatizacija]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=889</guid> <description><![CDATA[&#160; Prva računala za kontrolu industrijskih procesa praktički i nisu imala nikakvu interakciju sa ljudima koji su nadzirali proizvodnju. Ako su i imali to su bile kontrolne ploče naslijeđene od ranijih relejnih sustava upravljanja. Razvojem informatičke  tehnologije monitori su postali sastavni dio i industrijskih postrojenja  te je nadzor i interakcija ljudi i strojeva postala mnogo [&#8230;]]]></description> <content:encoded><![CDATA[<p>&nbsp;</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/06/VB_klijent.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/06/VB_klijent.png" alt="" title="VB_klijent" class="size-full wp-image-892 alignleft" height="130" width="180" /></a>Prva računala za kontrolu industrijskih procesa praktički i nisu imala nikakvu interakciju sa ljudima koji su nadzirali proizvodnju. Ako su i imali to su bile kontrolne ploče naslijeđene od ranijih relejnih sustava upravljanja. Razvojem informatičke  tehnologije monitori su postali sastavni dio i industrijskih postrojenja  te je nadzor i interakcija ljudi i strojeva postala mnogo jednostavnija i efikasnija. Razvoj aplikacija u ovom segmentu automatizacijskih sustava dugo je bio moguć  samo sa specijalnim razvojnim alatima. Pojavom OPC tehnologije stvari su se bitno promjenile te se sada ovaj dio posla  može obaviti s gotovo bilo kojim programom i razvojnim okolinom opće (programske) namjene.  Ovdje ću pokušati objasniti razvoj malog programa pisanog u Visual Basicu 6 koji koristi OPC tehnologiju za komunikaciju s procesnim računalom i može poslužiti kao operatorsko sučelje (<a href="http://en.wikipedia.org/wiki/Human-machine_interface"><em>HMI</em></a>).</p><h4 style="text-align: left;">Visual Basic 6</h4><p>Basic (<a href="http://en.wikipedia.org/wiki/BASIC"><span style="font-size: x-small;" size="2"></span><em>Beginners All-Purpose Symbolic Instruction Code</em></a>) je programski jezik kojeg koriste, ili su koristili, najviše programera u povijesti računalstva. Visual Basic 6 je inaćica koja sadrži više stotina naredbi i funkcija te je integriran u razvojnu okolinu  (<em>IDE</em>) za brzi i pregledni razvoj aplikacija s grafičkim sučeljem. Osim  Visual Studija, Visual Basic 6 je sastavni dio i <em>Microsoft Office</em> paketa  gdje služi za automatizaciju Excela, Worda ili PowerPointa. Upravo ta inaćica nazvana VBA (<a href="http://en.wikipedia.org/wiki/Visual_Basic_for_Applications"><em>Visual Basic for Application</em></a>) je i skriptni jezik mnogih komercijalnih razvojnih okolina za razvoj SCADA i HMI aplikacija kao što su <em>WinCC</em>  (<em>Simatic</em>)   ili <em>FactoryTalk</em>  (<em>RockwelSoftware</em>). Ova činjenica te relativna jednostavnost učenja i primjene dobar su razlog da se pozabavite Visual Basicom  mada će vas mnogi profesionalni programeri gledati s prezirom. Iako ne možemo reći u potpunosti, VB6  je objektni programski jezik i za razvoj aplikacije koristimo objekte . Objektima možemo podešavati svojsta (<em>Properties</em>) i definirati akcije na  pojedine događaje (<em>Event</em>s). Isto tako objektima možemo definirati aktivnosti koje će izvršati i to se zovu metode (<em>Methode</em>). Razvojna okolina VB6 sastoji se od nekolko cijelina :</p><ul><li>u sredini zaslona je objekt koji se naziva forma<em> (Form</em>) i on predstavlja grafičko sučelje naše aplikacije. Na formu stavljamo ostale objekte grafičkog sučelja kao što su tipke (<em>Buttons</em>), natpisi (<em>Labels</em>), padajuči izbornici (<em>DropdownBoxs</em>), slike (<em>Images</em>) i tako dalje.  Isto tako u na tome mjestu može biti programski editor gdje pišemo programski kod. Klikom miša na pojedini objekt prelazimo iz grafičkog u tekstalni mod izrade aplikacije odnosno prelazimo u programski editor.</li><li>s lijeve strane zaslona  nalazi se traka s dostupnim objetima (<em>Toolbox</em>) koje možemo prebaciti na formu  jednostavnim potezanjem  mišom.</li><li>s desne strane uobićajeno je da se nalaze tablični preglednici svojstava i strukture našeg projekta. Kada kliknemo na pojedini objekt na  formu (selektiramo ga) u ovom pregledniku se automatski izlistavaju svojstva dotičnog objeka gdje ta  svojstva možemo i mijenjati.</li></ul><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/07/VB6_IDE.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/07/VB6_IDE.png" title="VB6_IDE" class="aligncenter size-full wp-image-921" height="400" width="640" /></a></p><p>Osim toga na vrhu zaslona nalazi se standarni izbornik (<em>Menu</em>) sa svim alatima potrebnim za manipulaciju s programskim elementima, kompaliranjem programa, traženjem pogrešaka i definiranjem opcija razvojne okoline. Na dnu zaslona se u pojedinim fazama  programiranja pojavljuju prozori s rezultatima kompajliranja i eventualnim pogreškama. Dakle ako niste nikada programirali u VB6 potrebno je malo detaljinije se upoznati s načinom  rada u njemu. Na interentu imate mnogo <a href="http://www.ic.ims.hr/vba/vba-kazalo.html">tutorijala</a> od početnih koraka do naprednih opcija pa se ja ovdje neću više baviti time.</p><h4>OPC server &#8211; simulator procesa</h4><p>Da bi zrada bilo koje HMI/SCADA aplikacije bila komforna, odnosno da se ne piše na slijepo, potrebno je imati i vezu prema sklopovskoj opremi (PLC-u). Kako je kanal komunikacije  prilkom pisanja ovakvih aplikacija korištenjem VB6  OPC server neophodno je imati i OPC server sposoban za komunikaciju prema ciljanom PLC-u. Da bi  vam demonstrirali primjer pisanja male HMI aplikcaije koje  vi možete modificirati i testirati napisan je poseban OPC server. Ovaj OPC server ne treba nikakvu slopovsku opremu nego u svom kodu mijenja vrijednosti tag varijabli. Ovakve simulatorske OPC server možete naći kod svih proizvođača OPC servera ali ono što ovaj server razlikuje od njih je to da on u potpunosti simulira mali stvarni proces. To znaći da vi ne morate ručno mijenjati vrijednosti OPC tagova (na strani simulatora) nego se OPC server ponaša kao da je spojen na PLC koji upravlja industrijskim procesom. Radi se o jednostavnom procesu punjenja i pražnjenja spremnika tekućine.</p><p>OPC server QuercusLab.ProcesSimulatorLite.1.0 sadrži sljedće OPC stavke:</p><table border="1"><tbody><tr><td style="text-align: center;"><strong>OPC stavka</strong></td><td style="text-align: center;"><strong>Tip varijable</strong></td><td style="text-align: center;"><strong>Opis</strong></td></tr><tr><td> Tank.AutomaticMode</td><td> VT_Bool (Boolean)</td><td> Mod rada simulatora procesa (ručno/automatski)</td></tr><tr><td> Tank.Level.Value</td><td> VT_I4 (Long Integer)</td><td> Trenutna razina tekućine u spremniku</td></tr><tr><td> Tank.Level.Preset</td><td> VT_I4 (Long Integer)</td><td> Zadana razina tekućine u spremniku</td></tr><tr><td> Tank.Level.Hysteresis</td><td> VT_R4 (FLoat)</td><td> Histereza uključivanja punjenja u postocima</td></tr><tr><td> Tank.SourcePump.ON</td><td> VT_Bool (Boolean)</td><td> Status dobavne pumpe</td></tr><tr><td> Tank.DrainValve.ON</td><td> VT_Bool (Boolean)</td><td> Status ventila za ispuštanje</td></tr></tbody></table><p>Punjenje spremnika ostvaruje se uključivanjem dobavne pumpe  <em>Tank.SourcePump.ON</em>  a pražnjenje uključivanjem ventila za ispuštanje <em>Tank.DrainValve.ON</em>. Razina u spremniku <em>Tank.Level.Value</em> se može kontrolirati  definiranjem stavke <em>Tank.AutomaticMode</em>. Ručni mod omogućava neovisnu kontrolu rada dobavne pumpe i ispusnog ventila. Automatski mod osigurava konstantnu zadanu razinu  <em>Tank.Level.Preset</em>  upravljanjem  radom dobavne pumpe. Dobavna pumpa se uključuje nakon što razina padne ispod zadane za vrijednost definiranog postotka <em>Tank.Level.Hystersis</em> a isključuje kada razina dostigne zadanu vrijednost. Mod rada nema utjecaja na ventil za ispuštanje i on se uvijek može uključivati i isključivati.</p><h4>Visual Baisc 6 HMI aplikacija</h4><p>Izgradnja OPC klijent HMI aplikacije korištenjem VB6 programskog jezika  se može razvrstati na dva osnovna načina:</p><ul><li>pisanje programa korištenjem  osnovnih univerzalnih objekta korisničkog sučelja</li><li>pisanje programa korištenjem specijaliziranih objekta namijenjenih radu sa OPC serverom</li></ul><p>Prvi način zahtjeva više posla jer je potrebno pisanje vlastitih rutina dohvata podataka s OPC servera korištenjem poziva specificiranim u DA Automatizacijskom sučelju. Brigu o dobivenim podacima također mora voditi programer te ih obrađivati i prosljeđivati univerzalnim objektima korisničkog sučelja ili baze podataka. Ovakav način uz svoje nedostatke ima i prednosti u vidu potpune kontrole nad aplikacijom i maksimalne prilagodljivosti klijent aplikacije zahtjevima korisnika. Drugi način oslobađa programera ovih poslova jer se o tome brinu odabrani specijalizirani objekti.  Zadatak programera je da odabere objekte koji će najbolje odgovarati zahtjevima OPC klijent aplikacije, implementira  ih u svoj projekt te ih parametrira. Današnja ponuda takvih objekata je dosta velika i ona uključuje kontrole vizualizacije procesa, obrade i prezentacije alarma, pripreme i implementacije recepata, generiranja izvještaja te kontrole baza podataka. Osnovna prednost ovakvog načina izgradnje OPC klijent aplikacije je brzina izrade i smanjena mogućnost skrivenih grešaka jer su korištene kontrole već prošle testiranje. Negativni aspekti su uniformnost aplikacija i dodatna sredstva za nabavku kontrola koja poskupljuju aplikaciju. Naravno da je moguće i kombinacija ova dva načina tako da se maksimalno iskoriste prednosti i eliminiraju  mane obiju načina</p><h4>Grafičko sučelje &#8211; HMI vizualizacija</h4><p>U ovoj OPC klijent HMI aplikaciji pokazati ćemo upravo taj kombinirani način. Aplikacija će se bazirati isključivo na vizualizaciji procesa i upravljanju osnovnim aktuatorima procesa radi jednostavnosti i boljeg razumijevanja početnicima. Shodno tome i elementi za njenu izgradnju su zaparavo grafički objekti vizualizacije. Kao primjer korištenja gotovih  objekta,koji mogu biti komercijalni ili besplatni,  imat ćemo jednostavne grafičke prekidače i lampice. Ovi objekti su zapravo ActiveX kontrole koje smo razvili isto tako korištenjem Visual Basica te su kompajlirani zasebno.  <a href="http://en.wikipedia.org/wiki/ActiveX">ActiveX</a>  objekt koje ćemo koristi nosi naziv <em>Mini_HMI.ocx</em> i sadrži kontrole <em>qlSwitc</em>h, <em>qlLam</em>p i<em> qlSwitchFaceplate</em>.</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/07/Mini_HMI_ActiveX.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/07/Mini_HMI_ActiveX.png" title="Mini_HMI_ActiveX" class="aligncenter size-full wp-image-927" height="158" width="382" /></a></p><p style="text-align: left;">Drugi način je kreiranje vlastiti kontrola unutar samog programskog koda koji se koriste isto kao i prije opisane komercijalne kontrole. Generiranje ovih kontrola je na način da se u projekt doda takozvani <em>UserControl</em> objekt. <em>UserControl</em> može sadržavati sve što i <em>Form</em> objekt tako da se više standardnih VB kontrola može implementirati u novu, vlastitu. Ponašanje ovakvog objekta unutar HMI aplikacije definirate u programskom kodu.  Programski kod korisničkih kontrola je,  kao i izvršni kod, integralni dio Visual Basic projekta. Programiranje ovih kontrola je , uz neke specifičnosti, identično kao i programiranje ostalih elementa VB6 projekta. Važno je napomenuti da se prilkom kreiranja  UserControl objekta vodi idejom da se on piše što je više moguće  univerzalno da bi se mogao upotrebiti više puta  unutar samog projekta ili na nekim drugim projektima. Dobro napisani UserControl se može izdvojiti iz projekta i iz njega se može kompajlirati ActiveX kontrola koju smo spomenuli prije.  U našoj HMI aplikaciji koristit ćemo UserControl objekt <em>qlTank</em> koji će vizualizirat sam spremnik. Korisnička kontrola se sastoji od dvije  <em>Label</em> kontrole te jedne <em>Shape</em> kontrole. Label kontrole služe za ispis naziva spremnika i ispisa razine tekućine u spremniku dok Shape kontrola predstavlja senzor razine. Sama dinamička vizualizacija razine u spremniku odrađena je korištenjem grafičkih API poziva. Ovaj način programiranja je malo složeniji i zahtjeva  bolje poznavanje programiranja ali omogućava efektivniju i složeniju vizualizaciju. Ako niste vični ovakvom načinu programiranja na raspolaganju su vam milijuni besplatnih <em>UserControl</em> objekta koje možete skinuti s interneta i koristiti prilikom razvoja  vlastite HMI aplikacije.</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/07/UserControl_qlTank.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/07/UserControl_qlTank.png" title="UserControl_qlTank" class="aligncenter size-full wp-image-929" height="476" width="640" /></a></p><p style="text-align: left;">Treći način je da ne koristite ništa od ovoga navedenog nego da svoju HMI aplikaciju gradite korištenjem standardnih kontrola koje dolaze uz VisualBasic 6 i pisanjem programskog koda u osnovnim procedurama.</p><p style="text-align: left;">Kreiranje grafičkog sučelja odnosno vizualizacije započinjete postavljanjem gore navedenih objekta na glavnu (u ovom slučaju i jedinu) formu aplikacije. Prilikom pokretanja VB6 automatski se generiranja jedan <em>Form</em> objekt koji je ujedno i glavni odnosno startni. Po potrebi možete dodavati još formi korištenjem menu komandi <em>Project.AddForm</em> te ih pozivati iz programskog koda u skladu s vašim idejama. Elemente  korisničkog sučelja jednostavno dovlačite iz trake s alatima i postavljate na formu. Prilikom postavljanja automatski se generiraju imena objekta i oni se pojavljuju u tablici na desnoj strani ekrana. Tamo im možete mijenjati nazive kao i većinu svojstava. U traci s alatima se nakon prvog pokretanja mogu naći samo standardne kontrole. U našem slučaju se koristimo s dodatnim kontrolama te ih moramo dodati u traku s alatima. ActiveX kontrole su datoteke s ekstenzijom <em>*.ocx</em> i uobičajno je da se nalaze u sistemskom folderu &#8230;<em>windows/system32  </em>ali će raditi s bilo koje lokacije ako se dobro registriraju. Dakle  nakon što ste kopirali ActiveX datoteku u željeni direktorij potrebno je kontrolu registrirati i to činite tako da odete na  <em>Windows StartButon/Run</em> te u Open upišete  <em>&#8220;regsrv32 &lt;puna putanja/naziv activex datoteke&gt;&#8221;</em>.  Nakon što ste uspješno registrirali ActiveX kontrolu možete ju dodati u traku s alatima tako što će te kliknuti (desni klik)  na traku s alatima i izbrati komandu <em>Components</em>. Na zaslonu će se pojaviti lista svih regsitriranih ActiveX kontrola te će te ju odabrati i kliknuti OK. U našem slučaju će te odabrati &#8220;Quercus Lab mini HMI Components&#8221; i nakon što ste kliknuli Ok gore opisane kontrole odnosno njihove ikone će se pojaviti u traci s alatima.</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/07/RegOcx.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/07/RegOcx.png" title="RegOcx" class="aligncenter size-full wp-image-931" height="332" width="470" /></a></p><p style="text-align: left;">UserControl  ikone se automatski pojavljuju u traci s alatima kada se dodaju u projekt. Dodati se mogu na dva načina. Prvi je da se iz menija aktivira komanda <em>Project/Add UserControl</em> i tada se dodaje korisnička kontrola bez koda. Dakle ovo će te raditi kada želite napraviti novu korisničku kontrolu. U slučaju da ju već imate, bilo iz prijašnjeg projekta ili ste ju skinuli s interneta, dodat će te ju na način da kliknete na <em>Project</em> drvo ( na desnoj strani zaslona) te aktivirate komandu <em>Add/User Control</em> te iz dijaloga <em>Add UserControl/Existing</em> izaberete  datoteku s programskim kodom kontrole.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/07/Add_UserControl.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/07/Add_UserControl.png" title="Add_UserControl" class="aligncenter size-full wp-image-945" height="328" width="604" /></a></p><h4 style="text-align: left;">Spajanja na OPC server</h4><p>Nakon što ste pripremili i kreirali svoje HMI grafičko sučelje možete priječi na pisanje koda za komunikaciju s procesnom opremom. Ovdje se pristup bitno razlikuje od rada na komercijalnim SCADA razvojnim alatima. Ako je kreiranje izgleda grafičkog sučelje bilo slično komunikacijski dio je morate odraditi isključivo pisanjem programskog koda. Još je nešto neophodno da napravite prije samog kodiranja a to je podešavanje komunikacijskog kanala. U VB 6 on može biti isključivo OPC server i moramo u projekt dodati ActivX objekt koji zna komunicirati s njim. Taj objekt se naziva <em> DA Automation Wraper</em>  i može se besplatno skinuti s web stranica OPC fondacije. Kao i kontrole i ovaj wraper se mora prvo registrirati u sustav po gore opisanoj proceduri a tek potom ga se može  dodati u reference projekta. Dodavanje se vrši izborom komande <em>Project/References</em> iz glavnog menija.</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/07/Reg_DAWraper.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/07/Reg_DAWraper.png" title="Reg_DAWraper" class="aligncenter size-full wp-image-937" height="310" width="469" /></a></p><p style="text-align: left;">Sada smo spremni za pisanje koda: Pisanje koda započinjemo u području deklaracija tako da deklariramo neophodne OPC objekte. Radi se o objektima tipa <i>OPCServer</i>, <i>OPCGroups</i> i <i>OPCGroup</i>. Objekte koji imaju događaje deklarirat ćemo s  ključnom riječju <i>WithEvents</i>  da bi mogli koristiti iste. Drugi dio deklaracija odnosi se na varijable u koje spremamo podatke. To će biti varijable tipa polje u koje ćemo spremati nazive tagova (<i>OPCItemIDs</i>), korisničke šifre tagova (<i>OPCItemsClientHandles</i>), serverske šifre (<i>ItemServerHandles</i>) te greške prilikom transakcija s OPC serverom (<i>ItemServerErrors</i>). Na kraju dodajemo ostale varijable koje će služiti u algoritmima prezentacije podataka.</p><div class="wp_syntax"><table><tr><td class="code"><pre class="vb" style="font-family:monospace;"><span style="color: #151B8D; font-weight: bold;">Dim</span> <span style="color: #8D38C9; font-weight: bold;">WithEvents</span> simOPCServer  <span style="color: #151B8D; font-weight: bold;">As</span> OPCServer
<span style="color: #151B8D; font-weight: bold;">Dim</span> simGroups <span style="color: #151B8D; font-weight: bold;">As</span> OPCGroups
<span style="color: #151B8D; font-weight: bold;">Dim</span> <span style="color: #8D38C9; font-weight: bold;">WithEvents</span> simOPCGroup <span style="color: #151B8D; font-weight: bold;">As</span> OPCGroup
<span style="color: #151B8D; font-weight: bold;">Dim</span> OPCItemCollection <span style="color: #151B8D; font-weight: bold;">As</span> OPCItems
&nbsp;
<span style="color: #151B8D; font-weight: bold;">Dim</span> OPCItemCount <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Integer</span>                         <span style="color: #008000;">' količina opc stavki
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> OPCItemIDs() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">String</span>                          <span style="color: #008000;">' polje identifikacijskih oznaka (naziva) stavki
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> OPCItemsClientHandles() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>                 <span style="color: #008000;">' polje šifri stavki definiranih od strane klijenta
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> ItemServerHandles() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>                     <span style="color: #008000;">' polje šifri stavki definiranih od strane servera
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> ItemServerErrors() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>                      <span style="color: #008000;">' polje za spremanje greški servera
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> RemoveItemServerErrors() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>                <span style="color: #008000;">'
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> WriteServerHandles() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>                    <span style="color: #008000;">' polje za upis stavki na opc server - serverska sifra
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> ItemsValue() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Variant</span>                         ' polje za vrijednosti stavki</pre></td></tr></table></div><p>Nakon što smo deklarirali neophodne varijable OPC objekte potrebno je na početku izvršavanja programa i kreirati ih. To  ćemo  napraviti u događaju <em>Form _Load</em>:</p><div class="wp_syntax"><table><tr><td class="code"><pre class="vb" style="font-family:monospace;"><span style="color: #E56717; font-weight: bold;">Private</span> <span style="color: #E56717; font-weight: bold;">Sub</span> Form_Load()
<span style="color: #008000;">' EVENT: kada se ucita form (prakticki na pocetku programa)
</span>
<span style="color: #151B8D; font-weight: bold;">Set</span> simOPCServer = <span style="color: #E56717; font-weight: bold;">New</span> OPCServer                                <span style="color: #008000;">' kreira se objekt OPCServer
</span><span style="color: #E56717; font-weight: bold;">Call</span> OPC_Connect(<span style="color: #800000;">&quot;QuercusLab.ProcesSimulatorLite.1.0&quot;</span>)          <span style="color: #008000;">' poziv potprograma spajanja na OPC server
</span><span style="color: #E56717; font-weight: bold;">Call</span> OPCValue_Init                                              <span style="color: #008000;">' poziv potprograma inicijalizacije vrijednosti procesa
</span>
<span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #E56717; font-weight: bold;">Sub</span></pre></td></tr></table></div><p>Za spajanje i prekid veze s OPC serverom pisat ćemo posebne procedure i onda ih pozivati po potrebi. Procedura za spajanje naziva se OPC_Connect a kao parametar prosljeđujemo naziv OPC servera.  Pozivom metode <em>simOPCServer</em><em>.Connect</em> spajamo se na isti. Slijedi kreiranje OPCGruop objekta te definiranje njegovih svojstava. Neophodno je kreirati bar jednu OPC grupu metodom <em> simGroups .Add(&#8220;Tank&#8221;)</em> te definirati vrijeme osvježavanja podataka svojstvom <em>simGroups.UpdateRate.</em>  Potom ćemo proglasiti grupu aktivnom s svojstvom <em>simGroups.DefaultGroupIsActive = True</em>. Želimo li zaprimati podatke svaki puta kada se promjene vrijednosti tagova definirati ćemo to svojstvom <em>simGroups.IsSubscribed = True</em>. Dodavanje tagova (u OPC terminologiji <em>Items</em>&#8211; stavki) započinjemo dimenzioniranjem polja u koja spremamo simboličke nazive i korisničke  šifre tagova.  Nazive spremamo u u polje <i>OPCItemIDs</i> a korisničke šifre u polje <i>OPCItemClientHandles</i>. Završetak dodavanje tagova je pozivanje metode<i> OPCItemCollection.OPCItems.AddItems</i>  a parametri koji su neophodni su broj stavki (broj članova definiranih polja), polje s nazivima stavki (<i>OPCItemsIDs</i>), polje s korisničkim šiframa (<em>OPCItem</em><i>ClientHandles)</i>, polje serverskih šifri (<i>ItemServerHandles)</i> te polje za eventualne greške prilikom transakcije (<i>ItemsServerErrors</i>). Polje serverski šifre je prazno polje koje dimenzionira server i u njega upisuje vlastite šifre naših tagova koje korespondiraju indeksom s korisničkim šiframa.</p><div class="wp_syntax"><table><tr><td class="code"><pre class="vb" style="font-family:monospace;"><span style="color: #E56717; font-weight: bold;">Private</span> <span style="color: #E56717; font-weight: bold;">Sub</span> OPC_Connect(<span style="color: #151B8D; font-weight: bold;">ByVal</span> OPC_ServerName <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">String</span>)
<span style="color: #008000;">' PODPROGRAM: SPAJANJE NA OPC SERVER
</span><span style="color: #008000;">' aktiviram OPCserver objekt , spajam se na njega i dodajem (prijavljujem) tagove
</span>
simOPCServer.Connect (OPC_ServerName)                   <span style="color: #008000;">' spajanje na OPC server
</span>
<span style="color: #151B8D; font-weight: bold;">Set</span> simGroups = simOPCServer.OPCGroups                  <span style="color: #008000;">' kreira se objekt OPCGroups
</span>simGroups.DefaultGroupIsActive = <span style="color: #00C2FF; font-weight: bold;">True</span>                   <span style="color: #008000;">' objekt aktivan
</span>simGroups.DefaultGroupDeadband = 0                      <span style="color: #008000;">' definicija &quot;mrtvog pojasa&quot; analognih stavki (globalno)
</span>
<span style="color: #151B8D; font-weight: bold;">Set</span> simOPCGroup = simGroups.Add(<span style="color: #800000;">&quot;Tank&quot;</span>)                 <span style="color: #008000;">' kreira se objekt OPCGroup s nazivom &quot;Tank&quot;
</span>simOPCGroup.UpdateRate = 300   <span style="color: #008000;">' milisekunda            ' period osvježavanja podataka  u milisekundama
</span>simOPCGroup.DeadBand = 0                                <span style="color: #008000;">' definicija &quot;mrtvog pojasa&quot; analognih stavki
</span>simOPCGroup.IsSubscribed = <span style="color: #00C2FF; font-weight: bold;">True</span>                         <span style="color: #008000;">' pretplate stavki aktivne
</span>
<span style="color: #151B8D; font-weight: bold;">Set</span> OPCItemCollection = simOPCGroup.OPCItems            <span style="color: #008000;">' kreira se objekt OPCItems
</span>OPCItemCollection.DefaultIsActive = <span style="color: #00C2FF; font-weight: bold;">True</span>                <span style="color: #008000;">' objekt aktivan
</span>
<span style="color: #008000;">' priprema  polja stavki za dodavanje na OPC server
</span>OPCItemCount = 6                                        <span style="color: #008000;">' broj stavki
</span><span style="color: #151B8D; font-weight: bold;">ReDim</span> OPCItemIDs(6)                                     <span style="color: #008000;">' dimenzioniranje polja naziva stavki
</span><span style="color: #151B8D; font-weight: bold;">ReDim</span> OPCItemsClientHandles(6)                          <span style="color: #008000;">' dimenzioniranje polja šifri stavki
</span><span style="color: #008000;">' definiranje stavki
</span>OPCItemsClientHandles(1) = 1: OPCItemIDs(1) = <span style="color: #800000;">&quot;Tank.Level.Value&quot;</span>         <span style="color: #008000;">'
</span>OPCItemsClientHandles(2) = 2: OPCItemIDs(2) = <span style="color: #800000;">&quot;Tank.Level.Preset&quot;</span>
OPCItemsClientHandles(3) = 3: OPCItemIDs(3) = <span style="color: #800000;">&quot;Tank.Level.Hysteresis&quot;</span>
OPCItemsClientHandles(4) = 4: OPCItemIDs(4) = <span style="color: #800000;">&quot;Tank.SourcePump.ON&quot;</span>
OPCItemsClientHandles(5) = 5: OPCItemIDs(5) = <span style="color: #800000;">&quot;Tank.DrainValve.ON&quot;</span>
OPCItemsClientHandles(6) = 6: OPCItemIDs(6) = <span style="color: #800000;">&quot;Tank.AutomaticMode&quot;</span>
&nbsp;
<span style="color: #008000;">' dodavanje stavki na server
</span><span style="color: #008000;">' OPCItemCount - broj stavki  koje se  dodaju
</span><span style="color: #008000;">' ItemsIDs - polje s nazivima tagova
</span><span style="color: #008000;">' OPCItemsClientHandles - polje s siframa stavki definirani od strane klijenta
</span><span style="color: #008000;">' ItemServerHandles - polje u koje ce OPC server upisati (vratiti) serverske sifre stavki
</span><span style="color: #008000;">' (ove sifre ce se koristiti prilikom upisa vrijednosti tagova na OPC server)
</span><span style="color: #008000;">' ItemServerErrors - polje u koje ce server upisati eventualne greske prilkom ove transakcije
</span>OPCItemCollection.AddItems OPCItemCount, OPCItemIDs, OPCItemsClientHandles, ItemServerHandles, ItemServerErrors
&nbsp;
<span style="color: #008000;">' ako je nesto poslo krivo ispisujem gresku i zaustavlja aplikaciju
</span><span style="color: #8D38C9; font-weight: bold;">For</span> i = <span style="color: #151B8D; font-weight: bold;">LBound</span>(ItemServerErrors) <span style="color: #8D38C9; font-weight: bold;">To</span> <span style="color: #151B8D; font-weight: bold;">UBound</span>(ItemServerErrors)
    <span style="color: #8D38C9; font-weight: bold;">If</span> ItemServerErrors(i) &amp;lt;&amp;gt; 0 <span style="color: #8D38C9; font-weight: bold;">Then</span>
        MsgBox <span style="color: #800000;">&quot;Greška prilkom dodavanja stavki na OPC server!&quot;</span> &amp;amp; OPCItemIDs(i), vbOKOnly, <span style="color: #800000;">&quot;Error&quot;</span>
        Unload Me
        <span style="color: #151B8D; font-weight: bold;">Stop</span>
    <span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #8D38C9; font-weight: bold;">If</span>
<span style="color: #8D38C9; font-weight: bold;">Next</span>
<span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #E56717; font-weight: bold;">Sub</span></pre></td></tr></table></div><h4>Primanje i slanje podataka</h4><p>Zahvaljujući tome što smo se prilikom spajanja pretplatili (<em>.IsSusctibed=True</em>) na podatke ne trebamo provjeravati stanje vrijednosti tagova. OPC server će svaki put kada se vrijednost bilo kojega taga promjeni generirati događaj <em>DataChange</em> i proslijediti nam nove vrijednosti. Prosljeđuje se broj stavki <em>NumItems</em> (praktički broj elementa polja podataka), polje s šiframa stavki <em>ClientHandles</em>, polje s vrijednostima tagova <em>ItemValues</em>, polje s kvalitetom veze <em>Qualities</em>, polje s vremenom očitanja <em>TimeStamps</em> te oznake transakcije <em>TransactionID</em>. Na nama je zadatak  da prođemo kroz polje korisnički šifri, dekodiramo tagove te vrijednosti istih ispišemo u kontrole na našem ekranu. To uobičajno činimo koristeći se <em>Case</em> petljom za dekodiranje i <em>For&#8230;Next</em> petljom za provjeru svih članova polja.</p><div class="wp_syntax"><table><tr><td class="code"><pre class="vb" style="font-family:monospace;"><span style="color: #E56717; font-weight: bold;">Private</span> <span style="color: #E56717; font-weight: bold;">Sub</span> simOPCGroup_DataChange(<span style="color: #151B8D; font-weight: bold;">ByVal</span> TransactionID <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>, <span style="color: #151B8D; font-weight: bold;">ByVal</span> NumItems <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>, ClientHandles() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>, ItemValues() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Variant</span>, Qualities() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>, TimeStamps() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Date</span>)
<span style="color: #008000;">' EVENT: kada se promjeni stanje &quot;pretplacenih&quot; tagova OPC server generira ovaj event i salje vrijednosti tih tagova
</span><span style="color: #008000;">' NumItems - broj (kolicina) tagova
</span><span style="color: #008000;">' ClinetHandles() - korisnicke sifre tagova
</span><span style="color: #008000;">' ItemsValue() - vrijednosti tagova
</span><span style="color: #151B8D; font-weight: bold;">Dim</span> i <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Integer</span>
&nbsp;
<span style="color: #008000;">' obrada svih tagova
</span><span style="color: #8D38C9; font-weight: bold;">For</span> i = 1 <span style="color: #8D38C9; font-weight: bold;">To</span> NumItems
    <span style="color: #008000;">'Debug.Print ClientHandles(i)
</span>    <span style="color: #008000;">'Debug.Print
</span>    <span style="color: #8D38C9; font-weight: bold;">Select</span> <span style="color: #8D38C9; font-weight: bold;">Case</span> ClientHandles(i)
    <span style="color: #8D38C9; font-weight: bold;">Case</span> 1
        Me.tnkMain.Value = ItemValues(i)
        <span style="color: #8D38C9; font-weight: bold;">If</span> Me.tnkMain.Maxlevel = <span style="color: #00C2FF; font-weight: bold;">True</span> <span style="color: #8D38C9; font-weight: bold;">Or</span> Me.tnkMain.MinLevel = <span style="color: #00C2FF; font-weight: bold;">True</span> <span style="color: #8D38C9; font-weight: bold;">Then</span>
            Me.lmpAlarm.Value = <span style="color: #00C2FF; font-weight: bold;">True</span>
            <span style="color: #8D38C9; font-weight: bold;">If</span> Me.tnkMain.Maxlevel = <span style="color: #00C2FF; font-weight: bold;">True</span> <span style="color: #8D38C9; font-weight: bold;">Then</span> Me.labAlarmText.Caption = <span style="color: #800000;">&quot;Razina iznad dozvoljene&quot;</span>
            <span style="color: #8D38C9; font-weight: bold;">If</span> Me.tnkMain.MinLevel = <span style="color: #00C2FF; font-weight: bold;">True</span> <span style="color: #8D38C9; font-weight: bold;">Then</span> Me.labAlarmText.Caption = <span style="color: #800000;">&quot;Razina ispod dozvoljene&quot;</span>
        <span style="color: #8D38C9; font-weight: bold;">Else</span>
            Me.lmpAlarm.Value = <span style="color: #00C2FF; font-weight: bold;">False</span>: Me.labAlarmText.Caption = <span style="color: #800000;">&quot;&quot;</span>
        <span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #8D38C9; font-weight: bold;">If</span>
    <span style="color: #8D38C9; font-weight: bold;">Case</span> 2
        Me.txtlevelPreset.Text = Str(ItemValues(i))
    <span style="color: #8D38C9; font-weight: bold;">Case</span> 3
        Me.txtHystersis.Text = Str(ItemValues(i))
    <span style="color: #8D38C9; font-weight: bold;">Case</span> 4
        Me.lmpSourcePump.Value = ItemValues(i)
        <span style="color: #E56717; font-weight: bold;">Call</span> SourcePipeAnimation(ItemValues(i))
    <span style="color: #8D38C9; font-weight: bold;">Case</span> 5
        Me.lmpDrainValve.Value = ItemValues(i)
        <span style="color: #E56717; font-weight: bold;">Call</span> DrainPipeAnimation(ItemValues(i))
    <span style="color: #8D38C9; font-weight: bold;">Case</span> 6
        Me.swfAutomatic.LampValue = ItemValues(i)
    <span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #8D38C9; font-weight: bold;">Select</span>
<span style="color: #8D38C9; font-weight: bold;">Next</span> i
&nbsp;
<span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #E56717; font-weight: bold;">Sub</span></pre></td></tr></table></div><p>Želimo li promjeniti vrijednost neke stavke na raspolaganju su nam funkcije za sinkroni i asinkroni  upis. Sinkroni upis ćemo napravit funkcijom <em>SyncWrite</em> dok su nam parametri: broj stavki koje upisujemo , polje s serverskim šiframa, polje s vrijednostima stavki i polje za eventualne greške prilikom ove operacije. Ovdje valja primjetiti da se kao parametar koriste serverske a ne korisničke šifre stavki. Serverske šifre su upravo one koje nam je OPC server vratio prilkom dodavanja naši korisničkih šifri. U našem primjeru na početku programa u OPC server zapisujemo inicijalna stanja nekih stavki da bi nam simulator počeo raditi  a to radimo u proceduri <em>OPCValue_Init</em>.</p><div class="wp_syntax"><table><tr><td class="code"><pre class="vb" style="font-family:monospace;"><span style="color: #E56717; font-weight: bold;">Private</span> <span style="color: #E56717; font-weight: bold;">Sub</span> OPCValue_Init()
<span style="color: #008000;">' PODPROGRAM : POCETNE POSTAVKE
</span><span style="color: #008000;">' upisujem u OPC server zadanu vrijednost
</span>
<span style="color: #151B8D; font-weight: bold;">ReDim</span> WriteServerHandles(3): <span style="color: #151B8D; font-weight: bold;">ReDim</span> ItemsValue(3)
WriteServerHandles(1) = ItemServerHandles(2): ItemsValue(1) = 1900                          <span style="color: #008000;">' &quot;Tank.LevelPreset&quot; = 1900
</span>WriteServerHandles(2) = ItemServerHandles(3): ItemsValue(2) = 80                            <span style="color: #008000;">' &quot;Tank.LevelHysteresis&quot; = 80
</span>WriteServerHandles(3) = ItemServerHandles(6): ItemsValue(3) = Me.swfAutomatic.SwitchValue   <span style="color: #008000;">' &quot;Tank.AutomaticMode&quot; = stanje prekidaca MAN-AUTO
</span><span style="color: #008000;">' sinkrono zapisivanje vrijednosti
</span><span style="color: #008000;">' 3 - broj stavki
</span><span style="color: #008000;">' WriteServerHandles - polje s siframa definiranim od servera
</span><span style="color: #008000;">' ItemsValue - polje se definiranim novim vrijednostima
</span><span style="color: #008000;">' ItemServerErrors - polje s greškama prilkom zapisivanja
</span>simOPCGroup.SyncWrite 3, WriteServerHandles, ItemsValue, ItemServerErrors
<span style="color: #008000;">' obrada greske
</span><span style="color: #8D38C9; font-weight: bold;">For</span> i = <span style="color: #151B8D; font-weight: bold;">LBound</span>(ItemServerErrors) <span style="color: #8D38C9; font-weight: bold;">To</span> <span style="color: #151B8D; font-weight: bold;">UBound</span>(ItemServerErrors)
    <span style="color: #8D38C9; font-weight: bold;">If</span> ItemServerErrors(i) &amp;lt;&amp;gt; 0 <span style="color: #8D38C9; font-weight: bold;">Then</span>
        MsgBox <span style="color: #800000;">&quot;Greška prilkom dodavanja stavki na OPC server!&quot;</span>, vbOKOnly, <span style="color: #800000;">&quot;Error&quot;</span>
    <span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #8D38C9; font-weight: bold;">If</span>
<span style="color: #8D38C9; font-weight: bold;">Next</span>
<span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #E56717; font-weight: bold;">Sub</span></pre></td></tr></table></div><p>Na kraju rada  neophodno je da se uredno odjavimo s OPC servera. Ovdje ćemo to ućiniti u događaju Form_Unload. Brisanje stavki  radimo metodom <em>simOPCGroup.OPCItems.Remove</em> a grupe <em>simGroups.Remove</em>. Na kraju oslobodimo memoriju brisanjem objekta koje smo koristili.</p><div class="wp_syntax"><table><tr><td class="code"><pre class="vb" style="font-family:monospace;"><span style="color: #E56717; font-weight: bold;">Private</span> <span style="color: #E56717; font-weight: bold;">Sub</span> Form_Unload(Cancel <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Integer</span>)
<span style="color: #008000;">' EVENT: prije nego se program završi
</span>
<span style="color: #151B8D; font-weight: bold;">Dim</span> RemoveItemServerErrors() <span style="color: #151B8D; font-weight: bold;">As</span> <span style="color: #F660AB; font-weight: bold;">Long</span>
<span style="color: #008000;">' brišemo naše prijavljenje stavke sa servera
</span><span style="color: #008000;">' 6 - broj stavki koje brišemo (sve!)
</span><span style="color: #008000;">' ItemServerHandles - polje serverskih šifri koje brisemo
</span><span style="color: #008000;">' RemoveItemServerErrors - polje s greskama kod brisanja
</span>simOPCGroup.OPCItems.Remove 6, ItemServerHandles, RemoveItemServerErrors
<span style="color: #008000;">' brišemo korištenu grupu
</span><span style="color: #008000;">' brišemo korištene objekte za grupu
</span>simGroups.Remove (<span style="color: #800000;">&quot;Tank&quot;</span>)
<span style="color: #151B8D; font-weight: bold;">Set</span> simOPCGroup = <span style="color: #00C2FF; font-weight: bold;">Nothing</span>
<span style="color: #151B8D; font-weight: bold;">Set</span> simGroups = <span style="color: #00C2FF; font-weight: bold;">Nothing</span>
<span style="color: #008000;">' odspajamo se sa server
</span><span style="color: #008000;">' brišemo objekt za server
</span>simOPCServer.Disconnect
<span style="color: #151B8D; font-weight: bold;">Set</span> simOPCServer = <span style="color: #00C2FF; font-weight: bold;">Nothing</span>
<span style="color: #8D38C9; font-weight: bold;">End</span> <span style="color: #E56717; font-weight: bold;">Sub</span></pre></td></tr></table></div><p>Ovo će biti dovoljno za osnovnu komunikaciju vaše HMI aplikacije i procesnog računala a dalje je na vama da ju nadogradite s željenom, odnosno potrebnom, funkcionalnošću koristeći se standardnim i dodatnim VB6 rutinama.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/09/VB_OPCClient_Screen1.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/09/VB_OPCClient_Screen1.png" title="VB_OPCClient_Screen" class="aligncenter size-full wp-image-1003" height="382" width="640" /></a></p><h4>Preuzimanje</h4><p>Ovdje su opisane samo one programske rutine koje se tiću OPC servera dok  rad sa VB objektima možete vidjeti u programskom kodu. Sve potrebno, uključujući i OPC Srever ProcesSimulatorLite.1.0, da pokušate napraviti vlastiti VB6 OPC klijent ili samo da vidite kako se to radi   možete skinuti ovdje: <a href="/wp-content/uploads/2012/09/vb6clientsetup.exe">VB6ClientSetup.exe</a></p><p>Za pokretanje OPC servera ProcesSimulatorLite.1.0 potrebno je imati instaliran NET Framework3.5 kojega možete skinuti sa službenih Microsoftovih stranica: <a href="http://www.microsoft.com/en-us/download/confirmation.aspx?id=21">dotNetFx35setup.exe</a></p><p>Ako nemate instaliran Visual Basic 6 razvojni  paket za pokretanje iskompajliranog primjera bit će vam potreban VB6 Runtime koji možete skinuti ovdje: <a href="http://download.microsoft.com/download/vb60pro/install/6/Win98Me/EN-US/VBRun60.exe">VBRun60.exe</a></p> ]]></content:encoded> </item> <item><title>OPC Data Access server</title><link>http://www.quercus-lab.com/opc-data-acces-server/</link> <pubDate>Thu, 26 Apr 2012 05:35:42 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Automatizacija]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=795</guid> <description><![CDATA[OPC Data Access server je najvažnija i najkorištenija OPC  specifikacija do sada. Smatra se da je oko 99% implementacija OPC tehnologije upravo ovo sučelje.  OPC DA server  omogućava razmjenu informacija u realnom vremenu  između uređaja u polju (procesu) kao što su PLC, DCS ili PAC, sustava za kontrolu  i nadzor  kao što su HMI, SCADA [&#8230;]]]></description> <content:encoded><![CDATA[<p>OPC <a href="http://www.quercus-lab.com/wp-content/uploads/2012/03/OPC_DA_logo.png"><img class="size-full wp-image-845 alignleft" title="OPC_DA_logo" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/03/OPC_DA_logo.png" width="180" height="130" /></a>Data Access server je najvažnija i najkorištenija OPC  specifikacija do sada. Smatra se da je oko 99% implementacija OPC tehnologije upravo ovo sučelje.  OPC DA server  omogućava razmjenu informacija u realnom vremenu  između uređaja u polju (procesu) kao što su PLC, DCS ili PAC, sustava za kontrolu  i nadzor  kao što su <a href="http://en.wikipedia.org/wiki/HMI">HMI</a>, <a href="http://en.wikipedia.org/wiki/SCADA">SCADA</a> ili operatorski paneli. Dodatna funkcionalnost je mogućnost razmjene informacija između samih sustava automatizacije različitih proizvođača.   Arhitektura OPC DA Servera  je <a href="http://en.wikipedia.org/wiki/Client%E2%80%93server_model">klijent-server model</a>  gdje  OPC Server komponenta koja osigurava sučelje ka OPC objektima i upravlja sa njima. OPC klijent aplikacija komunicira sa OPC poslužiteljem preko spomenutih sučelja.</p><h4>OPC DA sučelje (interface)</h4><p>OPC tehnologija se temelji na  Microsoft OLE (<i>ActiveX)</i> tehnologiji i komunikacijskim modelima COM (<a href="http://en.wikipedia.org/wiki/Component_Object_Model"><i>Component Object Model</i></a>) i DCOM (<a href="http://en.wikipedia.org/wiki/Distributed_Component_Object_Model"><i>Distributed Component Object Model</i></a>). OPC sadrži standardni set sučelja, svojstva i metoda koje se koriste u aplikacijama kontrola procesa i automatizacije. OLE/COM tehnologije definiraju se kako individualne programske komponente koje mogu međudjelovati i dijeliti podatke.</p><p>OPC specifikacije sadrže dva seta sučelja:</p><ol><li>Prilagođeno  sučelje (<i>Custom Interface</i>)</li><li>Automatizacijsko sučelje (<i>Automation Interface</i>)</li></ol><p>OPC poslužitelji moraju implementirati prilagođeno sučelje i opcijski  mogu implementirati automatizacijska  sučelja.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_Interface.png"><img class="aligncenter" title="OPC_Interface" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_Interface.png" width="656" height="289" /></a></p><p>U neki m slučajevima OPC Foundation  osigurava omotnicu (<em>wrap</em><em>per</em>) za standardno automatizacijsko sučelje . Ovaj <em>wrapperDLL</em> može biti korišten za bilo koji specifični proizvođački  (<em>Vendor</em>) poslužitelj.  Općenito, OPC klijent programi koji se kreiraju koristeći skriptno bazirane programske jezike će koristiti automatizacijsko sučelje. Klijent programi koji su kreirani u C++ će lakše koristiti prilagođeno sučelje za postizanje najbolje performanse.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/03/OPC_wraperDLL.png"><img class="aligncenter size-full wp-image-868" title="OPC_wraperDLL" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/03/OPC_wraperDLL.png" width="629" height="278" /></a></p><p>Ono što ovaj standard želi definirati je zajednički način na koji aplikacije u oblasti upravljanja i vođenja procesa mogu pristupiti podacima o procesu. Automatizacijsko sučelje treba osigurati istu funkcionalnost kao i prilagođeno (<i>Custom</i>) sučelje, ali na način koji je blizak trendovima u načinu programiranja  u automatizaciji. Osnovni cilj dizajna sučelja je da radi kao omotnica (<i>wrapper</i>) za <i>OPC DataAcces Custom Interface</i> te da osigurava pogodan mehanizam funkcionalnosti. Klijent koji koristi <i>OPC Data Automation</i> sučelje koristi wrapper DLL kao sponu ka <i>OPC Data Custom Interface</i> serveru. Na ovaj način bilo koja aplikacija koja ima <em>OLE Automation Interface</em> funkcionalnost (<i>VBA,VB.Net, Delphi,  Excel</i>) ima mogućnost pristupa lokalnom OPC serveru  a preko wraper-a udaljenom <i>OPC Custom Interface</i> serveru.</p><h4><b>OPC DA Server  model<br /> </b></h4><p><i>OPCServer</i> objekt je osnovna instanca OPC poslužitelja. Korisnik mora kreirati <i>OPCServer</i> objekt  prije nego se mogu dobiti reference za druge objekte. Sadrži <i>OPCGroups</i> kolekciju i kreira <i>OPCBrowser</i> objekte.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/03/opc_DA_model.png"><img class="aligncenter size-full wp-image-865" title="opc_DA_model" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/03/opc_DA_model.png" width="622" height="303" /></a></p><h4></h4><h4>OPCServer objekt</h4><p><i>OPCServer</i> objekt osigurava  korisniku pristupi (za čitanje i pisanje) ili komunikaciju sa skupom izvora podataka. Tipovi izvora koji su na raspolaganju su funkcija implementacije poslužitelja. OPC Automation klijent se povezuje sa OPC Automation serverom koji komunicira sa izvorom podataka (odnosno sa DA Serverima), putem funkcionalnosti koju osiguravaju automatizacijski objekti koji su opisani u ovom standardu. <i>OPCServer</i> osigurava jedan <i>OPCGroups</i> objekt za Automation kolekciju da bi održavao sakupljanje <i>OPCGroup</i> objekata. Korisnik pristupa poslužitelju izvršavajući <i>OPCServer.Connect</i> metodu birajući jedan od dostupnih OPC poslužitelja čiju listu može dobiti pomoću <i>OPCServer.GetOPCServers</i> metode. Nakon uspješnog pristupa dostupna su mu podaci o karakteristici, statusu i postavkama izabranog poslužitelja kao što su verzija poslužitelja, proizvođač, ime poslužitelja i slično. Od događaja dostupan je samo jedan, <i>OPCServer.ServerShutDown</i>, koji obavještava da poslužitelj nije više dostupan.</p><h4> OPC Browser objekt</h4><p>Objekt  koji  izlistava  (brows-a)  imena  stavki  (items)  u  konfiguraciji  poslužitelja.  Postoji  samo  jedna  instanca  <em>OPCBrowser </em> objekta  za  instancu  <em>OPCServer</em>  objekta.  Ako  server  ne  podržava  izlistavanje  <em>CreateBrowser</em>  metoda <em>OPCServer</em>  objekta  neće  kreirati  ovaj  objekt.    Korisnik  su  dostupna  eventualna  hijerarhijska  organizacija  stavki  pomoću  <em>OPCBrowser.ShowBranches</em>  i  <em>OPCBrowser.ShowLeafs</em>  metoda  kao  i  navigacija  kroz  istu  metodama <em>OPCBrowser.MoveToRoot</em>, <em>OPCBrowser.MoveUp</em>, <em>OPCBrowser.MoveDown</em> i <em>OPCBrowser.MoveTo</em> metodama</p><h4>OPCGroups i OPCGroup objekt</h4><p><i>OPCGroups</i> objekt je automatizacijska kolekcija koja sadrži sve<i> OPCGroup</i> objekte. Ovaj objekt klijent kreirao unutar opsega <i>OPCServera</i> sa kojim se automatizacijska  aplikacija povezala putem <i>OPCServer.Connect</i> metode. Osigurava korisniku dodavanje, modificiranje i upravljanje s kolekcijom <i>OPCGrup</i> objekta. <i><br /> </i></p><p><i>OPCGroup</i> objekt je instanca <i>OPCGroups</i> objekta. Namjena ovog objekta je održavanje informaciju o stanju i osiguranje mehanizma kreiranja servisa akvizicije podataka za <i>OPCItem Collection</i> objekta koji <i>OPCGroup</i> objekt referencira. Korisnik dodaje novu grupu u kolekciju metodom <i>OPCGruop.Add</i>. Nakon  toga može svojstvom <i>OPCGroup.IsActive</i> kontrolirati status dostupnih podataka unutar grupe. Pomoću  svojstva <i>OPCGroup.IsSubscribed</i> se korisnik preplaćuje na asinkrono primanje podatak kada se promjeni vrijednost odabranih stavki na poslužitelju. Promjena vrijednosti inicira aktiviranje <i>OPCGroup.DataChange</i> događaja te se servisiranjem istog zaprimaju vrijednosti promijenjenih podataka. Definiranjem svojstva <i>OPCGropu.UpdataRate</i> kontrolira se period sinkrone razmjene (<i>Read/Write</i>) odabranih podataka u milisekundama. Razmjena se ostvaruje <i>OPCGroup.SincWrite</i> i <i>OPCGroup.SincRead</i> metodama. Asinkrona razmjena podataka moguća je metodama <i>OPCGroup.AsincRead</i>, <i>OPCGroup.AsincWrite</i> te     <i>OPCGroup.AsincRefresh</i> metodama. Završetkom asinkrone razmjene podataka generiraju se događaji <i>OPCGroupe.AsincReadComplete</i> i <i>OPCGroup.AsincWriteComplete</i>.</p><h4>OPCItems i OPCItem objekt</h4><p><i>OPCItems</i> je  kolekcija koja sadrži sve <i>OPCItem</i> objekte koje  klijent kreira unutar opsega <i>OPCServer-a</i>, i odgovarajućeg <i>OPCGroup</i> objekta koji je automatizacijska aplikacija kreirala.<i> OPCItem</i> je Automation objekt koji održava definiciju stavki (<i>Item-a</i>), trenutnu vrijednost, statusnu informaciju i posljednje vrijeme ažuriranja (<i>Update</i>).</p><h4>OPC DA tipovi podataka</h4><p>Kao što je spomenuto u početki OPC koristi COM a osnovni tip podataka u njemu je <a href="http://en.wikipedia.org/wiki/Variant_type">Variant</a>. Variant je tip  podataka duljine 16 byte koji u sebi može sadržavati većinu ostalih   tipova. Prva dva byta su cijelobrojni podaci koji definiraju tip podataka koji su pohranjeni od 7 do 15 byte.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/04/OPC_DA_variant.png"><img class="aligncenter size-full wp-image-882" title="OPC_DA_variant" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/04/OPC_DA_variant.png" width="557" height="81" /></a></p><p>Svi OPC serveri podržavaju slijedeće tipove Variant podataka:</p><table border="1"><tbody><tr><td style="text-align: center;">Tip</td><td style="text-align: center;">Podaci u bytovima 8 do 15</td><td style="text-align: center;">Opis vrijednosti koji VARIANT vrača</td></tr><tr><td> VT_I1</td><td> 1-byte signed integer</td><td> Cijelobrojna vrijednost  duljine 1 byta</td></tr><tr><td> VT_I2</td><td> 2-byte signed integer</td><td> Cijelobrojna vrijednost  duljine 2 byta</td></tr><tr><td> VT_I4</td><td> 4-byte signed integer</td><td> Cijelobrojna vrijednost  duljine 4 byta</td></tr><tr><td> VT_UI1</td><td> 1-byte unsigned integer</td><td> Pozitivna cijelobrojna vrijednost duljine 1 byta</td></tr><tr><td> VT_UI2</td><td> 2-byte unsigned integer</td><td> Pozitivna cijelobrojna vrijednost duljine 2 byta</td></tr><tr><td> VT_UI4</td><td> 4-byte unsigned integer</td><td> Pozitivna cijelobrojna vrijednost duljine 4 byta</td></tr><tr><td> VT_R4</td><td> 4-byte IEEE floating-point number</td><td> Realna vrijednost  duljine 4 byta</td></tr><tr><td> VT_R8</td><td> 8-byte IEEE floating-point number</td><td> Realna vrijednost  duljine 8 byta</td></tr><tr><td> VT_CY</td><td> CURRENCY type</td><td> Novčana vrijednostima s decimalnim zarezom</td></tr><tr><td> VT_DATE</td><td> DATE type</td><td> Datum i vrijeme</td></tr><tr><td> VT_BSTR</td><td> BSTR type</td><td> String koji počinje s oznakom duljine a završava s  null karakterom</td></tr><tr><td> VT_BOOL</td><td> VARIANT_BOOL type</td><td> Logička vrijednost TRUE ili FALSE</td></tr></tbody></table><p>&nbsp;</p> ]]></content:encoded> </item> <item><title>OPC tehnologija</title><link>http://www.quercus-lab.com/opc-tehnologija/</link> <pubDate>Sat, 25 Feb 2012 16:21:45 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Automatizacija]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=418</guid> <description><![CDATA[Dosadašnji sustavi automatizacije podrazumijevali su komunikacije između uređaja na razini automatizacije u polju i nadzornih sustava koji su se temeljili na komunikacijskim protokolima svojstvenim sklopovlju uređaja koje povezuju. Takav način povezivanja zahtijevao je isporuku ili izradu specifičnih komunikacijskih programskih sučelja (software driver-a) za svaki uređaj u sustavu. Zbog toga je krajnji kupac kupovao skup sustav [&#8230;]]]></description> <content:encoded><![CDATA[<p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/Opc_logo.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/01/Opc_logo.png" alt="" title="Opc_logo" class="alignleft size-full wp-image-574" height="135" width="180" /></a>Dosadašnji sustavi automatizacije podrazumijevali su komunikacije između uređaja na razini automatizacije u polju i nadzornih sustava koji su se temeljili na komunikacijskim protokolima svojstvenim sklopovlju uređaja koje povezuju. Takav način povezivanja zahtijevao je isporuku ili izradu specifičnih komunikacijskih programskih sučelja (<em>software driver-a</em>) za svaki uređaj u sustavu. Zbog toga je krajnji kupac kupovao skup sustav čije je održavanje i eventualno proširenja bilo komplicirano i skupo. Rješenje se ogledavalo u razvoju standardnog sučelja koji će omogućiti jednostavnu primjenu (<em>plug &amp; play</em>) te jednostavno održavanje i buduće proširenje. Takav standard trebao je biti prikladan i za jednostavne i za složene sustave koji bi se gradili na osnovu  otvorene i unificirane komunikacije od osnovne razine automatizacije do složenih informacijskih  sustava.  Rješenje je ponuđeno kao novi koncept baziran na OPC tehnologiji što  skraćenica (<em>OLE for Process Control</em>) koja označava Microsoft tehnologiju <a href="http://en.wikipedia.org/wiki/OLE">OLE </a>(<em>Object Linking and Embedding</em>) primijenjenu u kontroli procesa. Iz toga slijedi kompatibilnost OPC tehnologije sa MS Windows aplikacijama i činjenica da je moguće izraditi veoma prikladne i cijenom povoljni male aplikacije vizualizacije bazirane na Microsoftovoj tehnologiji</p><h4>Arhitektura informacijskog sustava u procesnoj industriji</h4><p>Uvođenjem inteligentnih uređaja u postrojenjima kao dijelova sistema vođenja nadzora i upravljanja pojavljuje se obilje informacija, o uređajima ali i o postrojenju, koji nisu prije bili raspoloživi. Ove informacije osiguravaju podatke o stanju uređaja, njegovim konfiguracijskim parametrima te okruženju u kojem se uređaj nalazi. Spomenute informacije  se trebaju prikazati korisniku na konzistentan način. Brigu nad njima preuzimaju procesna računala (PLC-i) koristeći suvremene industrijske računalne mreže kao podatkovne magistrale na razini postrojenja (polja). Instaliranje distribuiranih sistema upravljanja (DCS) i<a href="http://en.wikipedia.org/wiki/SCADA"> SCADA</a> sustava sa zadaćom  da nadziru upravljanje   procesima čine ove podatke raspoložive i u elektronskoj formi, za razliku od ranijih sustava kada su mnogi od njih bili ručno prikupljani i zapisivani. Zahtjev za kontrolom financijskih aspekata proizvodnih procesa ostvaruje se integracijom ovih prikupljenih informacija iz procesa u poslovne sustave. Držeći se ovih smjernica pri  razvoju informacijskih sustava  u procesnoj industriji dolazimo do tipične arhitekture sustava u kojoj uočavamo tri osnovne razine:</p><ol><li>Poslovni menedžment</li><li>Menadžment procesa</li><li>Menadžment u postrojenju (polju)</li></ol><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_Netwrok.png"><img class="aligncenter size-full wp-image-459" title="OPC_Netwrok" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_Netwrok.png" alt="" height="480" width="640" /></a></p><h4>OPC – novi koncept sustava automatizacije</h4><p>Dosadašnji sustavi automatizacije podrazumijevali su komunikacije između uređaja na razini automatizacije u polju i nadzornih sustava koji su se temeljili na komunikacijskim protokolima koji su bili svojstveni sklopovlju uređaja koje povezujemo. Takav način povezivanja zahtijevao je isporuku ili izradu komunikacijskih programskih sučelja (<em>software driver-a</em>) za svaki uređaj u sustavu. Ta programska sučelja isporučivala su se u sklopu SCADA sustava samo za poznatije uređaje (PLC, mjerni uređaji, itd.). Često se događalo da potrebe povezivanja nekih specifičnih, a često vrlo važnih, uređaja u sustav predstavlja tešku a nekad i nepremostivu poteškoću. U tom slučaju koristili su se takozvani konverteri protokola koji su često bili skuplji od samih uređaja. Te i slične poteškoće poskupljivale su složenije sustave, te tako pridonijele opće priznatom mišljenju da se složenija sustavi automatizacije ekonomski ne isplate.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_SCADA_Classic.png"><img class="aligncenter size-full wp-image-438" title="OPC_SCADA_Classic" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_SCADA_Classic.png" alt="" height="242" width="599" /></a></p><p>Cijene integracija različitih podsustava znatno su rasle zbog činjenice da je za svaki uređaj bilo potrebno izrađivati posebno programsko sučelje. Statistike govore da je za programski razvoj tipične nadzorno – kontrolne aplikacije bilo potrebno utrošiti za pisanje programskog sučelja oko 25-30% inženjerskog razvojnog vremena. Integratori sustava trošili su veoma mnogo razvojnog vremena za takve poslove te je konačna cijena sustava bila skupa kao i održavanje budući da je zahtijevalo specijalistička znanja. Rezultat tog  je bio da je krajnji kupac kupovao skup sustav čije je održavanje i eventualno proširenja bilo isto tako komplicirano i skupo. Rješenje se ogledavalo u razvoju standardnog sučelja koji će omogućiti jednostavnu primjenu (<em>plug &amp; play</em>) te jednostavno održavanje i buduće proširenje. Takav standard trebao je da bude prikladan i za jednostavne i složene sustave koji bi se gradili na osnovu  otvorene i jednostavne komunikacije od osnovne razine automatizacije do složenih informacijskih <a href="http://en.wikipedia.org/wiki/Management_information_system">MIS </a>sustava (<em>Management Information System</em>).</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_SCADA_Modern1.png"><img class="aligncenter size-full wp-image-461" title="OPC_SCADA_Modern1" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_SCADA_Modern1.png" alt="" height="307" width="636" /></a></p><p>Rješenje je ponuđeno kao novi koncept baziran na OPC tehnologiji. Na priloženim slikama prikazana je razlika novog koncepta OPC strukture (Sl. 2a) i stare komunikacijske strukture (Sl. 2b). Terminologija OPC izvodi se kao  skraćenica (<em>OLE for Process Control</em>) koja označava Microsoft tehnologiju OLE (<em>Object Linking and Embedding</em>) primijenjenu u kontroli procesa. Iz toga slijedi kompatibilnost OPC tehnologije sa MS Windows aplikacijama i činjenica da je moguće izraditi veoma prikladne i cijenom povoljni male aplikacije vizualizacije koje kao podlogu (<em>OPC Client</em>) koriste npr. neku od komponenata MS Office paketa (npr. Excel). Tijekom protekle decenije OPC je postao industrijski standard kojeg razvijaju najuglednije svjetske kompanije sa područja automatizacije u suradnji sa tvrtkom Microsoft. U tom smislu osnovana je neprofitabilna zaklada OPC Foundation koja okuplja preko 150 članova, pretežno svjetski poznatih razvojnih ustanova i tvrtki. OPC tehnologija se temelji na već spomenutom Microsoft OLE (<em>ActiveX)</em> tehnologiji i komunikacijskim modelima COM (<a href="http://en.wikipedia.org/wiki/Component_Object_Model"><em>Component Object Model</em></a>) i DCOM (<a href="http://en.wikipedia.org/wiki/Distributed_Component_Object_Model"><em>Distributed Component Object Model</em></a>). OPC sadrži standardni set sučelja, svojstva i metoda koje se koriste u aplikacijama kontrola procesa i automatizacije. OLE/COM tehnologije definiraju se kako individualne programske komponente koje mogu međudjelovati i dijeliti podatke.</p><h3 style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_SCADA_Modern2.png"><img class="aligncenter size-full wp-image-462" title="OPC_SCADA_Modern2" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/OPC_SCADA_Modern2.png" alt="" height="304" width="634" /></a>OPC specifikacije i smjernice razvoja</h3><p>OPC specifikacije definiraju skup sučelja (<em>Interface</em>) koji se lako implementiraju primjenom objektno orijentiranog programiranja i omogućava laku manipulaciju tim objektima. Softver pomoću koga korisnik upravlja procesom  (<a href="http://en.wikipedia.org/wiki/Human-machine_interface"><em>Human-Machine Interface</em></a>), upravljački softver ili softver za akviziciju podataka (<em>SCADA</em>) može obrađivati ili prikupljati podatke sa različitih računara u mreži. Specifikacije definiraju standardne mehanizme za pristupanje podacima na serveru po nazivima. Projektanti koji razvijaju hardver i softver mogu jednostavno razmjenjivati informacije pomoću širokog spektra sistemskih aplikacija, u koje se ubrajaju distribuirana kontrola sistema (<em>DCS</em>), SCADA sustavi, procesna računala PLC (<em>Programmable Logical Controler</em>) kao i razni inteligentni uređaji, povezani preko računarske mreže.</p><p>Prva verzija OPC standarda V1.0 je objavljena u kolovozu 1996. godine. Tijekom  1997. godine vršene su korekcije na standardu a krajem 1998. godine se pojavila verzija V2.0 sa značajnim izmjenama. Standard je podržan od strane najvećih svjetskih kompanija koje se bave izradom PLC-a i softvera za vizualizaciju procesa. OPC je baziran na tehnologijama OLE, ActiveX, COM  i DCOM i dostupan je na 32-bitnom operativnom sistemu Microsoft Windows. Pomoću DCOM tehnologije mogu  se razmjenjivati podaci (objekti) i sa drugim operativnim sistemima kao što su <a href="http://en.wikipedia.org/wiki/Unix">Unix</a> ili<a href="http://en.wikipedia.org/wiki/Linux"> Linux</a>. Do danas je izdano desetak OPC specifikacija od kojih možemo izdvojiti tri osnovne:</p><ol start="1"><li><strong>OPC Data Access</strong> (<em>OPC DA</em>) – Koristi se za razmjenu podataka između servera i procesne opreme u realnom vremenu. <em> OPC Data Access</em> je  najvažnija specifikacija i sučelje  koje je najviše implementiranu u svim primjenama OPC tehnologije danas. Ono omogućava čitanje i pisanje varijabli procesa u realnom vremenu.<br /> <strong>OPC Complex Data, OPC Batch, and OPC Data eXchange (DX)</strong> su ekstenzije <em>OPC DA</em> servera za poboljšanu funkcionalnost. <em>Complex Data</em>  definira način pristupa kompleksno strukturiranim varijablama procesa dok <em> OPC Batch</em>  je specifikacija namijenjena klijentima kod slijednih (batch) procesa (S88). <em>OPC Data eXchange</em>  (<em>DX</em>)  specifikacija definira način razmjene podataka između DA servera  kada je klijent definiran unutar servera.</li><li><strong>OPC Alarms &amp; Events</strong> (<em>OPC A&amp;E</em>) – Omogućava  pozive alarma i događaja na zahtjev za razliku od kontinuiranog protoka podataka <em>OPC DA</em> servera.  To uključuje obradu alarma, aktivnosti operatora, informacijske poruka i poruke o praćenju procesa. Pri tome se pod pojmom  Alarms  i Events  smatraju jednokratne poruke o stanju procesa i nedozvoljenim promjenama unutar njega.</li><li><strong>OPC Historical Data Access </strong><em>(OPC HDA)</em><strong> – </strong>Za razliku od <em>OPC DA</em> servera koji omogućava praćenje procesa u realnom vremenu <em>OPC HDA</em> te podatke sprema i čuva. Koristeći se <em>OPC HDA</em> serverom SCADA sustavi se transformiraju iz jednostavnog (<em>data logging</em>) sustava u kompleksne alate za praćenje i analizu procesa u bilo koje vrijeme.</li></ol><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/02/OPC_Specifitation.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/02/OPC_Specifitation.png" title="OPC_Specifitation" class="aligncenter size-full wp-image-839" height="250" width="636" /></a></p><p>Od ostalih  <strong>OPC XML-DA</strong>  je prva OPC specifikacija koja nije bila vezana uz određenu programsku platformu kod koje je DCOM/COM komunikacija zamijenjena s <a href="http://en.wikipedia.org/wiki/SOAP">HTTP/SOAP</a> protokolima i tehnologijom web-servisa. <strong>OPC Security</strong> definira kontrole pristupa serveru  da bi se zaštitile važne  informacije i onemogućilo neovlašteno mijenjanje parametara procesa. <strong>OPC Commands</strong> definira mehanizme za pozivanje metode ili za izvršavanje programa putem OPC. Ova specifikacija nikada nije objavljen  budući da je završena  nakon što je započet rad na <strong>OPC Unified Architecture</strong> ali je sadržaj i funkcionalnost u potpunosti je uklopljen u UA.</p><p><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/opc_UALogo.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2012/01/opc_UALogo.png" alt="" title="opc_UALogo" class="aligncenter size-full wp-image-817" height="205" width="240" /></a></p><p>Slijedeća generacija OPC specifikacija trebala je napustiti koncept ograničene Microsoft Windows platforme a OPC Foundation bi trebala osigurati portabilnost na ostale operativne sustave. Ova specifikacija nazvana <strong><em>OPC Unified</em></strong> (<em>OPC UA</em>) podržava skalabilnost kompletnog protokola što omogućava implementaciju na  embeded platforme za razliku od dosadašnje DCOM platforme koja troši razmjerno puno memorijskih resursa . Sadašnje specifikacije <em>DA, A&amp;E i HDA</em> servera zahtijevaju zasebno memorijsko prostore adresiranje dok ih <em>UA</em> specifikacija ujedinjuje što pojednostavljuje programske pozive. Sigurnost današnji servera je vrlo mala jer komunikacija zahtjeva otvoren port 135. <em> OPC Unified</em> arhitektura predviđa sigurnosni sustav baziran na <a href="http://en.wikipedia.org/wiki/W3C_Markup_Validation_Service">W3C</a> specifikacijama koji uključuju autorizaciju korisnika, razmjenu digitalnih certifikata i opcionalnu enkripciju poruka.</p><p>Performanse danas korištenih servera  uvelike su ograničene performansama <em>DCOM</em> sučelja dok novi standard predviđa mnogo bolje jer definira dvije transportne opcije:</p><ul><li><strong>Web bazirani protokol</strong> SOAP (XML kodirana razmjena podataka preko HTTP) kojije u osnovi tekstualan što daje mogućnost lagane integracije u razne sustave ali je i do nekoliko puta sporiji od DCOM prijenosa</li></ul><ul><li><strong>UA binarni protokol</strong> (binarno kodirana razmjena podataka preko TCP/IP) čija brzinaje usporediva, pa čak i brža od DCOM karakteristika</li></ul><p>Osim ovoga nova OPC UA specifikacija donosi bolje rezultate na polju robusnosti aplikacija, redundancije podataka, te mogućnosti upotrebe  kompleksnih i strukturiranih podataka.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> ]]></content:encoded> </item> <item><title>Kapacitivne dodirne tipke</title><link>http://www.quercus-lab.com/kapacitivne-dodirne-tipke/</link> <pubDate>Wed, 25 Jan 2012 07:22:47 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Mikrokontroleri]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=489</guid> <description><![CDATA[Do danas su razvijeni raznorazni senzori na dodir,  počevši od čisto vodljivih tipova apliciranih na televizijskim aparatima osamdesetih godina  prošlog stoljeća, pa  preko optičkih, do današnjih otporničkih i kapacitivnih koji se koriste na modernim mobilnim telefonima. Njihov razvoj i primjena  uvjetovana je razvojem tehnoloških postupaka i elektronskih komponenti a veliki napredak je napravljen masovnom produkcijom [&#8230;]]]></description> <content:encoded><![CDATA[<p><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_logo2.png"><img class="size-full wp-image-691 alignleft" title="touch_logo2" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_logo2.png" width="180" height="130" /></a>Do danas su razvijeni raznorazni senzori na dodir,  počevši od čisto vodljivih tipova apliciranih na televizijskim aparatima osamdesetih godina  prošlog stoljeća, pa  preko optičkih, do današnjih otporničkih i kapacitivnih koji se koriste na modernim mobilnim telefonima. Njihov razvoj i primjena  uvjetovana je razvojem tehnoloških postupaka i elektronskih komponenti a veliki napredak je napravljen masovnom produkcijom i primjenom mikrokontrolera. Kapacitivna metoda detekcije dodira danas je najraširenija koristi se  gotovo na svim elektronskim uređajima počevši od kontrolnih panela u kabinama za tuširanje do prijenosnih računala i mobitela.  Mnogi proizvođači elektronskih komponenti u svom proizvodnom programu imaju integrirane krugove koji omogućavaju razvoj dodirnog sučelja. Na zadovoljstvo mnogih zaljubljenika elektronike ona je aplikativna na najmanjim mikrokontrolerima i  ovdje je opisana jedna jednostavna metoda na mikrokotroleru  Atmel ATtiny2131</p><h3>Princip rada</h3><p>Osnovni princip rada kapacitivnih senzora osjetljivih na dodir je promjena kapaciteta područja dodira. Metoda detekcije promjena je različita a ovdje će se objasniti metoda koja je uobičajena u većini mjerača kapaciteta a radi se integracijskoj metodi mjerenja. Algoritam metode je usporedba vremena trajanja nabijanja kondenzatora poznatog kapaciteta sa vremenom nabijanja nepoznatog a na osnovu njihovog omjera se izračunava kapacitet nepoznatog kondenzatora. Za primjenu metode kod dodirne tipke nama treba samo sigurna detekcije promjene kapaciteta i to je osnovni zahtjev jer je promjena kapaciteta vrlo mala.Poznato je iz osnova elektrotehnike da svaka  elektronska komponenta pa tako i mikrokontroler odnosno njegov I/O port posjeduje parazitni kapacite i on se koristi kao etalonski kondenzator <em>C<sub>s</sub></em>. Nepoznati kondenzator  <em>C<sub>x</sub></em> je kapacitet ljudskog tijela  koji po <a href="http://en.wikipedia.org/wiki/Human-body_mode">modelu za ESD </a>ima kapacitet do 100 <em>pF</em>  i koji se formira kada se prstom dodirne metalna  površina izolirana nekim tankim izolatorom. Ako za mikrokontroler izaberemo ATTiny2313 odnosno  parazitni kapacitet  je oko 15 pF i prijelazna pojava punjenja toga kondenzatora na napon koji  se detektira kao logička 1 ( a to je po specifikacijama 2,65 V kod napajanja 5V) traje oko 9 mikrosekundi. Ako kao jednu elektrodu drugog kondenzatora pripremimo područje bakra na tiskanoj pločici površine 16&#215;16 mm to vrijeme punjenja se produžuje na oko 16 mikrosekundi  i to je ta vremenska razlika koju moramo iskoristiti kao detekciju dodira odnosnu &#8220;pritisnute&#8221; tipke.</p><p><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_scope.png"><img class="aligncenter size-full wp-image-699" title="touch_scope" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_scope.png" width="625" height="472" /></a>Da bi osigurali detekciju promjene kapaciteta poslužit će mo se standardnim I/O portom mikrokontrolera Atmel ATTiny2313 jer on sadrži sve električne i programske komponente potrebne za to. Koristit ćemo registre <em>DDRx.n, PORTx.n i PINx.n</em> gdje x označava korišteni port (A,B ,C, D) dok n označava broj bita porta(0-7). <em>DDR</em> registar služi za definiranje da li će port biti korišten kao ulazni ili izlazni. Ako je njegova vrijednost 0 port se koristi kao ulaz te će  registar <em>PORT</em> biti odspojen od pina mikrokontrolera tako da stanje registra <em>PORT</em> neće imati utjecaja na stanje pina. Druga namjena <em>DDR</em> registra je uključivanje <em>pull-up</em> otpornika koji su integrirani u mikrokontroler. Ako je  port definiran kao ulaz (DDRx.n=0)  s registrom <em>PORTx.n</em> se uključuje (<em>PORTx.n=1</em>)  odnosno  isključuje (<em>PORTx.n=0</em>) navedeni otpornik. Osnovna namjena registra <em>PORTx.n </em> je jasno odnosno on spaja pin mikrokontrolera na <em>Vcc</em> odnosno <em>Gnd</em> ako je I/O  port definiran kao izlaz (<em>DDRxn=1</em>).  Namjena Registar <em>PINx.n</em>  je  uvijek ista a to je da čita logičko stanje pina mikrokontrolera. Od ostalih vanjskih komponenti potrebna nam je jedan otpornik preko kojeg ćemo trajno spojiti pin mikrokontrolera na Vcc napajanje te površina bakra tiskane pločice koja će služiti kao jedna ploča kondenzatora odnosno imati ulogu senzora i  ova površina mora biti pokrivena nekim  izolatorom.</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_unloadC.png"><img class="aligncenter size-full wp-image-705" title="touch_unloadC" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_unloadC.png" width="506" height="382" /></a>Navedene komponente će nam poslužiti za generiranje dva osnovna stanja a to je pražnaje i punjenje kondenzatora. Pražnjenje se ostvaruje na način da se stanje registra  <em>PORTx.n</em> postavi u logičku nulu a potom se stanje <em>DDRx.n</em> registra promjeni u logičku jedinicu. Na taj način će se pin mikrokontrolera postaviti u nulu  što će rezultirati pražnjenjem kondenzatora <em>C</em><sub><em>s</em>.</sub>  i sada je sustav spreman za mjernu sekvencu. Postavljanjem <em>DDRx.n</em> registra u logiču nulu odspaja se pin mikrokontrolera od <em>PORTx.n</em> registra te je omogućeno  punjenje kondenzatora preko vanjskog otpornika <em>R</em>.</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_loadC.png"><img class="aligncenter size-full wp-image-711" title="touch_loadC" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_loadC.png" width="507" height="382" /></a>Istovremeno s početkom punjenja aktivira se mjerenje vremena i  čitajući stanje registra <em>PINx.n</em> provjerava se logičko stanje ulaza odnosno napon na kondenzatoru. Kada je vrijednost <em>PINx.n</em> registra logička jedinica zapamti se vrijeme punjenja i to etalonsko vrijeme i označava stanje <em>&#8220;dodir nije detektiran&#8221;</em> odnosno <em>&#8220;tipka nije stisnuta&#8221;</em>. Kada se prstom dodirne površina &#8220;senzora&#8221; na tiskanoj pločici spaja se kondenzatoru <em>Cs</em> još jedan <em>Cx</em> (paralelno) a vrijeme potrebno da se detektira logička jedinica registra PNx.n se produžava. To prekoračenje prije izmjerenog etalonskog vremena omogućava da se detektira prisutnost prsta na senzoru odnosno stanje<em> &#8220;taster je stisnut&#8221;</em>.</p><h3 style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_loadCfinger.png"><img class="aligncenter size-full wp-image-714" title="touch_loadCfinger" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_loadCfinger.png" width="509" height="383" /></a>Programska izvedba</h3><p>Gore opisane sekvence vrlo je jednostavno izvesti i to ćemo napravit u <a href="http://www.mcselec.com/index.php?option=com_content&amp;task=view&amp;id=14&amp;Itemid=41">BASCOM</a> programskom jeziku. Na početku je potrebno izmjeriti vrijeme da se parazitni kondenzator <em>Cs</em> bez prisutnosti prsta na senzoru nabije na logičku jedinicu i to spremiti u varijablu <em>TouchTreshold.</em> Učiniti ćemo to u <em>DO&#8230; LOOP</em> u petlji  u koji će biti sekvenca pražnjenja kondenzatora (2 milisekunde), početak punjenja, čekanje od <em>TouchTreshold </em>mikrosekundi  te provjeravanje da li je pin u logičkoj jednici. Poslije toga na početku slijedeće  iteracije  petlje povečavamo varijablu <em>TouchTreshold</em> za 1. Kada se detektira logička jedinica na pinu izlazimo iz <em>DO ..LOOP</em> petlje i trenutna vrijednost  varijable<em> TouchTreshold </em>  je  prije spomenuto etalonsko vrijeme . Tom vremenu dodajemo još 2 mikrosekunde da bi sa sigurnošću  detektirali neprisutnost prsta.</p><div class="wp_syntax"><table><tr><td class="code"><pre class="qbasic" style="font-family:monospace;"><span style="color: #a1a100;">DO</span>
   TouchTreshold <span style="color: #66cc66;">=</span> TouchTreshold <span style="color: #66cc66;">+</span> <span style="color: #cc66cc;">1</span>
   DDRD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">1</span> : PORTD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">0</span>                      <span style="color: #808080;">' prazni</span>
   waitms <span style="color: #cc66cc;">2</span>
   PORTD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">0</span> : DDRD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">0</span>                      <span style="color: #808080;">' start punjenja</span>
   waitus TouchTreshold
   <span style="color: #a1a100;">IF</span> PIND.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">1</span> <span style="color: #a1a100;">THEN</span>                            <span style="color: #808080;">' provjera napunjenosti</span>
      TouchTreshold <span style="color: #66cc66;">=</span> TouchTreshold <span style="color: #66cc66;">+</span> <span style="color: #cc66cc;">2</span>
      <span style="color: #000066;">EXIT</span> <span style="color: #a1a100;">DO</span>
   endif
<span style="color: #a1a100;">LOOP</span></pre></td></tr></table></div><p>Nakon što smo ovo napravili možemo u glavnom programu skenirati sve naše senzor, detektirati dodir i izvršiti određene akcije. Program je sličan inicijalizacijskom dijelu samo što ovdje kao rezultat na provjeru  napunjenosti palimo ili gasimo signalizacijsku diodu. Dakle nakon što smo ispraznili kondenzator počinjemo ga puniti  te  testiramo da li je on pun nakon  vremena koje je dobiveno u inicijalizacijskoj sekvenci. Ako je nakon toga vremena pin nije logičkoj jedinici znači da je ukupni kapacitet  koji se puni veći od parazitnog kapaciteta <em>C<sub>s</sub></em> odnosno površina senzora je dotaknuta prstom. U listingi programa je kod samo za 1 kanal i koristi se pin 7 (<em>PD3</em>) kao senzor a pin 18 (<em>PB6</em>) kao indikacija  dodirnutog senzora.</p><div class="wp_syntax"><table><tr><td class="code"><pre class="qbasic" style="font-family:monospace;">LED1 <span style="color: #000066;">ALIAS</span> PORTB.6
<span style="color: #a1a100;">DO</span>
   <span style="color: #808080;">' Channel 1</span>
   DDRD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">1</span> : PORTD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">0</span>                     <span style="color: #808080;">' prazni</span>
   waitms <span style="color: #cc66cc;">2</span>
   PORTD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">0</span> : DDRD.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">0</span>                     <span style="color: #808080;">' start punjenja</span>
   waitus TouchTreshold
   <span style="color: #a1a100;">IF</span> PIND.3 <span style="color: #66cc66;">=</span> <span style="color: #cc66cc;">0</span> <span style="color: #a1a100;">THEN</span>                           <span style="color: #808080;">' provjera napunjenosti</span>
      LED1<span style="color: #66cc66;">=</span><span style="color: #cc66cc;">1</span>
   <span style="color: #a1a100;">ELSE</span>
      LED1<span style="color: #66cc66;">=</span><span style="color: #cc66cc;">0</span>
   endif
<span style="color: #a1a100;">LOOP</span></pre></td></tr></table></div><h3>Praktična realizacija</h3><p>Kao prototip je napravljena tipkovnica s četiri dodirne tipke. To je ustvari elektronski modul koji  bi trebao zamijeniti četiri standarne tipke na malom operatorskom panelu u  mojem projektu kučne automatizacije. Svaka dodirna tipka ima svjetlosnu  indikaciju kao povratnu informaciju  &#8220;pritiska&#8221; tipke. Upotrebljeni mikrokontroler je ATtiny2313 a sam modul nema   stabilizirano napajanje već se napaja s 5V iz uređaja na kojem će biti. Izlazni signali su četiri digitalna izlaza koji poprimaju  stanje dodirne tipke a pomoću kratkospojnika na pinu 3 (PD1) može se definirati signal &#8220;pritisnute&#8221; tipke . Izlazni signal da je tipka  &#8220;pritisnuta&#8221; bit će onog  logičkog nivoa koji je trenutno na pinu 3.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_keypad.png"><img class="aligncenter size-full wp-image-759" title="touch_keypad" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_keypad.png" width="558" height="222" /></a></p><p style="text-align: left;">Tipkovnica je napravljena na dvostranom  tiskanoj pločici  tako da su na gornjem <em>layeru</em> dodirni senzori odnosno bakrene površine velićine 16&#215;16 milimetara.  Ostali elementi su smješteni odozdola te  su,  iako standarne veličine, lemljeni su  kao <a href="http://en.wikipedia.org/wiki/SMD">smd</a> elementi  dok bi finalna variajanta svakako trebala biti prava smd.  Žice koje se vide su za napajanje (plava i crvena) i za eksterni <a href="http://en.wikipedia.org/wiki/In-system_programming">ISP programator.</a></p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_board.png"><img class="aligncenter size-full wp-image-762" title="touch_board" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_board.png" width="534" height="223" /></a></p><p style="text-align: left;"><em></em>Električna shema je jedostavn i iz nje se vidi da je korišten ATtiny2313  s vlastitim  generatorom takta i rudimentarnim reset krugom. Otpornici na senzorima dodira su 680 kilooma i njihova vrijednost je utvrđeni  eksperimentalno. Oni ovise površini dodirnog senzora te debljine i tipu izolacije (prednje maske) pa će te vjerojatno njih morati utvrditi eksperimentalno u neki drugim izvedbama.<a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_schematic.png"> <img class="aligncenter size-full wp-image-749" title="touch_schematic" alt="" src="http://www.quercus-lab.com/wp-content/uploads/2012/01/touch_schematic.png" width="692" height="451" /></a>Prototipni modul je u  fazi testiranja radio vrlo pouzdano ali nije testiran u težem radnom okruženu (što mu nije bila ni namjena).</p><p style="text-align: center;">[jwplayer mediaid=&#8221;1030&#8243;]</p><p style="text-align: left;">Datoteku koja sadrži  shemu, tiskanu pločicu, izvorni te izvršni kod možete skinuti ovdje: <a href="http://www.quercus-lab.com/wp-content/uploads/2012/01/TouchKeypad_quercus-lab.zip">TouchKeypad_quercus-lab</a></p> ]]></content:encoded> </item> <item><title>Interbus-S industrijska mreža</title><link>http://www.quercus-lab.com/interbus-s-industrijska-mreza/</link> <comments>http://www.quercus-lab.com/interbus-s-industrijska-mreza/#respond</comments> <pubDate>Thu, 08 Dec 2011 11:50:16 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Automatizacija]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=324</guid> <description><![CDATA[Upotreba računala za upravljanje je najvažnija značajka suvremenih upravljačkih sustava u procesnoj industriji. Računala se povezuju neposredno na proces a međusobno se povezuju u mrežu računala. U početku primjene računala za upravljanje, kada su računala bila vrlo skupa,  upravljanje se je zasnovalo na upotrebi jednog velikog središnjeg  računala, no  razvojem tehnologije poluvodičkih elemenata  cijena računala [&#8230;]]]></description> <content:encoded><![CDATA[<p><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus.png" title="Interbus" class="size-full wp-image-482 alignleft" width="180" height="130" /></a>Upotreba računala za upravljanje je najvažnija značajka suvremenih upravljačkih sustava u procesnoj industriji. Računala se povezuju neposredno na proces a međusobno se povezuju u mrežu računala. U početku primjene računala za upravljanje, kada su računala bila vrlo skupa,  upravljanje se je zasnovalo na upotrebi jednog velikog središnjeg  računala, no  razvojem tehnologije poluvodičkih elemenata  cijena računala postaje sve manje značajna i istovremeno  snaga malih računala  omogućuje primjenu velikog broja računala za upravljanje proizvodnje u nekom pogonu ili cijeloj tvornici. Svaki industrijski pogon se sastoji od velikog  broja procesnih jedinica koje se mogu upravljati računalom, tako da se vrlo često veliki broj računala u industrijskom pogonu međusobno povezuje u višerazinsku strukturu računalnu mreže. Na prvoj računalnoj razini nalaze se računala za neposredno upravljanje pojedenim procesima.  Ova računala imaju zadaće upravljanja slijedom operacija i regulaciju pojedinih procesnih veličina. Informacije s razine neposredne proizvodnje prenose se na višu razinu. Na ovoj razini se obavljaju složeni  zadaci upravljanje kao što je  optimiranje proizvodnih planova. Takova računala podržavaju distribuirane baze podataka o tekućoj  proizvodnji kao i tehničku dokumentaciju o procesnim jedinicama. Na najvišoj razini se nalazi središnje ili glavno računalo  koje ima najveću procesnu moć obrade informacija. Za razmjenu informacija u ovako organiziranim računalnim sustavima razvili su se specifične računalne mreže koja su prilagođene određenoj razini komunikacije i fizičkim uslovima koji  vladaju u pojedinim područjima. Kao primjer tako organiziranog sustava prikazana je  mrežna struktura tiskarskog postrojenja u kojoj je primijenjen moderan pristup automatizaciji i mrežnoj tehnologiji.</p><h4 style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/PrintingMaschineNetwork.png"><img class="aligncenter size-full wp-image-325" title="PrintingMaschineNetwork" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/PrintingMaschineNetwork.png" alt="" width="604" height="390" /></a></h4><h4 style="text-align: left;">Princip rada Interbus-S mreže</h4><p style="text-align: left;">Interbus-S senzorsko-aktorska mreža je digitalni serijski komunikacijski sustav za prijenos podataka između kontrolnog sustava i raznoraznih senzora i aktora. Interbus-S je koncipiran kao serijski podatkovni prsten koji radi isključivo u realnom vremenu u okviru master/slave metode kontrole prijenosa a strukturiran je kao pozadinski posmični registar.  Svaki  član mreže (<em>slave</em>) sa svojim registrima dio je tog prstenastog posmičnog registra.  Interbus master u mrežnom modulu  čini centralni dio Interbus sustava koji kontrolira  čitav sustav te omogućava da su ulazno-izlazni podaci dostupni slici procesa. Tijekom jednog mrežnog ciklusa serijski se isporučuju izlazni podaci  članovima mreže ali se istovremeno od njih  zaprimaju ulazni podaci. Na kraju ciklusa svi izlazni podaci su distribuirani  a ulazni upisani u ulaznu mapu slike procesa. Koristeći prstenastu strukturu moguće je ostvariti  istovremenu predaju i zaprimanje podataka (<em>full dupleks</em>) a predvidljivo vrijeme pristupa  za  sve članove mreže je zajamčeno.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_cycle.png"><img class="aligncenter size-full wp-image-394" title="Interbus_cycle" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_cycle.png" alt="" width="555" height="413" /></a></p><h4 style="text-align: left;">Interbus-S mrežna toplogija</h4><p style="text-align: left;">Topologija ove mreže je prsten koji sve  članove mreže integrira u jedinstven transportnu  putanju. Dodatna karakteristika Interbus-S mreže je prijenos podataka u oba smjera za sve članove. Fizički izgled mreže je radi toga  linijska ili razgranate struktura s pojedinačnim  ograncima.  Spajanje na mrežu ostvaruje se mnogostrukim serijskim spojevima tako da svaki član svojim ulazom zaprima podatke od prethodnog  člana te ga odašilje prema slijedećem. U tom kontekstu linije se označavaju kao  DO (<em>DataOut</em>) linija ako je tok podataka od  nadređenog (mastera) te kao DI (<em>DataIn</em>) ako je tok podataka ka nadređenom.  Analizirajući realnu  strukturu mreže mogu se izvući slijedeće prednosti:</p><ul><li>Adresiranje članova mreže pomoću kodnih prekidača nije potrebno jer je fizičkim položajem svaki član jasno određen u mreži.</li><li>Nisu potrebni skupi pojačivači signala jer se signal u svakom članu mreže regenerira.</li><li>Omogućen je istovremeni prijam i odašiljanje podataka što karakterizira prijenos kao <em>full dupleks.</em></li><li>Point to point struktura omogućava zamjenu transportnih medija (svjetlovoda  naprimjer) u bilo kome dijelu mreže ako je to potrebno s obzirom na smetnje u tom dijelu.</li><li>Omogućena je implementacija rutina samodijagnostike svakog člana mreže.</li></ul><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_topolgy.png"><img class="aligncenter size-full wp-image-409" title="Interbus_topolgy" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_topolgy.png" alt="" width="464" height="582" /></a></p><p>Ovako opisana topologija omogućava spajanje najviše 512 mrežnih  članova dok je ukupna količina podataka 4098 bita što je uobičajena ulazno-izlazna mapa većine procesnih računala. U fizičkoj strukturi Interbus-S industrijske mreže razlikujemo dvije vrste mrežnih segmenata. Jedan od tih segmenata nazivamo   <em>Remote bus</em> i on predstavlja vezu između  mrežnih  čvorova koji ne nose informaciju nego omogućavaju daljnje grananje strukture . Na svaki mrežni čvor nastavlja se segment koji se naziva <em>Local bus</em> i koji spaja ulazno-izlazne mrežne članove u prsten. Maksimalna duljina  <em>Remote bus</em>-a odnosno udaljenost između dva  <em>Remote bus</em> mrežna  adaptera (<em>BA–BusAdapter</em>) je 400 metara dok je ukupna duljina mreže limitirana na 13 km.  Udaljenost između dva mrežna člana unutar <em>Local Bus</em>-a je 20 metara.</p><h4>OSI model Interbus-S protokola</h4><p>Interbus-S protokol baziran je na OSI referentni model ali zbog gore navedenih specifičnosti  koristi samo 1,2 i 7 sloj .  Ostale funkcije od 3 do 6 sloja implementirane su u 7 (aplikacijskom) sloju. Koristeći fizički sloj  signali se odašilju standardnom brzinom od 500 kbps koristeći NRZ  (<em>non-return to zero</em>) metodu. Podatkovni sloj se brine za integritete podataka i  upravlja  cikličkim prijenosom podatka koristeći   <em>summation frame method</em>.  Ovaj sloj prosljeđuje  podatke aplikacijskom sloju preko dva različita podatkovna kanala:</p><ul><li>Podatkovni kanal procesa (<em>Process Data Channel</em>) je primarni kanal Interbus-S mreže i  koristi se za prijenos procesnih informacija koje se obrađuju skupom senzora i aktuatora.</li><li>Parametarski kanal (<em>Parameter Channel</em>) omogućava cikličku razmjenu parametarskih  podataka između složenijih  članova uključenih u mrežu. Ovaj kanal zahtjeva veći komunikacijski paket i koristi servise bazirane na master-slave strukturi.</li></ul><p><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_OSI.png"><img class="aligncenter size-full wp-image-387" title="Interbus_OSI" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_OSI.png" alt="" width="521" height="275" /></a></p><p>Svaki Interbus-S mrežni član sadrži procesni kanal dok je parametarski dodan kao mogućnost  (opcija). Ovakva hibridna struktura protokola koja koristi dvije neovisne kanala podataka omogućava u istoj mreži implementaciju složenih (inteligentnih) mrežnih  članova i  jednostavnih senzora i aktora. Osim toga u svakom sloju se tijekom rada mreže izvršavaju dijagnostičke rutine o kjima se brine rutina koji se naziva<em> Network Menegment  (upravljanje mrežom)</em> .</p><h4>Summation Frame Protokol</h4><p>Interbus-S je jedina industrijska mreža koja koristi <em>summation frame method</em>  pomoću kojeg se razmjenjuje podaci između nadređenog i podređenih  članova mreže u  samo jednom komunikacijskom ciklusu i to simultano u oba smjera (<em>full duplex</em>).  Ova metoda omogućuje  predviđeno trajanje komunikacijskog ciklusa što mu daje prednost  u procesima koji se kontroliraju u realnom vremenu. U   <em>summation</em> okviru, koji se sastoji od  zaglavlja (<em>haeder</em>), povratne riječi (<em>loop-back word</em>), podataka i kontrolne sekvence, podaci za sve članove mreže su grupirani u jedan podatkovni blok.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_sumframe.png"><img class="aligncenter size-full wp-image-382" title="Interbus_sumframe" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_sumframe.png" alt="" width="582" height="180" /></a></p><p>Razmjena podataka koristeći ovaj protokol izvršava se u s slijedećim sekvencama:</p><ol><li>Svi mrežni članovi se resetiraju te se identifikacijski kodovi  dotičnog člana učitava u posmični registar.</li><li>Nadređeni član  inicira početak identifikacijskog ciklusa u kome se metodom posmaka transportiraju identifikacijski kodovi svih trenutno prisutnih članova zajedno sa količinom podataka koji pojedinačno obrađuju.</li><li>Završetkom ID-ciklusa nadređeni ažurira trenutnu topologiju mreže i uspoređuje je sa  zahtijevanom konfiguracijom te ako nema greške spreman je za početak podatkovnog ciklusa.</li><li>U slučaju greške slijedeći identifikacijskim ciklusom moguće je rekonfigurirati mrežu te ponovo startati podatkovni ciklus.</li><li>Pokreće se podatkovni ciklus koji se ciklički izvršava sve dok se CRC metodama ne utvrdi greška u prijenosu podataka što uzrokuje ponavljanje opisane sekvence.</li></ol><h4>Procesni podatkovni kanal</h4><p>Procesni podaci su oni koji neposredno opisuju kontrolirani proces i predstavljaju u realnom vremenu stanja izvršnih i senzorskih uređaja koji sudjeluju u procesu. Kompleksnost tih podataka gledana sa stanovišta pojedinačnih mrežnih  članova nije velika i kreče se od nekoliko bitova do d nekoliko bytova. Ova karakteristika omogućava umrežavanje u Interbus-S mrežu velikog broja mrežnih članova sa karakterističnom širinom podataka od 8 do 16 bita(1 word). Nakon što je utvrdio konfiguraciju mreže nadređeni može početi sa prijenosom podataka između procesnog računala i ulazno-izlaznih uređaja. Podatkovni ciklus uključujeposmak podatkovnih blokova prema podređenim članovima mreže i to po, u identifikacijskom ciklusu,  utvrđenom redoslijedu i količini podataka. Kada podatkovni blok dospije do mrežnog  člana provjerava se pripada li taj podatak tom  članu. Ako je odgovor potvrdan mrežni  član prihvaća dobavljene podatke u svoj izlazni registar te iz svog ulaznog registra prosljeđuje u posmični  registar. Na ovaj način se nakon punog posmaka posmičnog registra razmjeni cjelovita slika procesa .</p><h4>Parametarski podatkovni kanal</h4><p>Parametarski podatkovni kanal koristi se da bi neovisni proizvođači razmjenjivali kompleksne  podatke za svoje uređaje unutar Interbus-S mreže. Za razliku od procesnih podataka koji se  prenose ciklički parametarski podaci se razmjenjuj samo na zahtjev određenog mrežnog  člana. Kompleksnost tih podataka je u mnogome veća od procesnih i uobičajeno iznosi od 10  do 100 baytova. Tipični Interbus-S uređaji koji koriste  parametarski podatkovni kanal su  frekvencijski i tiristorski motorni pretvarači, servo-pozicioneri te operatorski i upravljački  paneli. Implementacija parametarskog podatkovnog kanala u  <em>summation frame</em>  zahtjeva  razdavanje kompleksnih parametarskih poruka na više dijelova. Tako razdvojeni parametri se potom prenose zajedno sa procesnim podacima unutar podatkovnog ciklusa i na taj se način  proširuje podatkovni blok  <em>summation frame</em>.   Komunikacija koja koristi parametarski podatkovni kanal bazira se na klijent/server modelu:</p><ol><li>Mrežni  član koji želi komunicirati šalje zahtjev (<em>request</em>) i on u komunikacijskom  odnosu predstavlja klijenta.</li><li>Interbus master prenosi  zahtjev  na ciljani podređeni  član koji reagira odgovorom  (response) i on predstavlja server.</li><li>Ovaj se  odgovor prenosi do člana koji je inicirao komunikaciju i na taj način mu se  poručuje da može početi sa slanjem parametara.</li><li>Slijedi  razmjena parametara koristeći Interbus-S nadređeni uređaj kao posrednika u komunikaciji.</li></ol><p>Parametarski podatkovni kanal može se koristiti i  za razmjenu podataka između nadređenih  (slave) članova mreže i između nadređenog i podređenog člana (što je češći slučaj).</p><h4>Konektori i kablovi</h4><p>Interbus-S standard (IEC 61158) se bazira na RS-485 standardu kao električnoj specifikaciji za prijenos podataka  u <em>Remote bus</em> segmentu mreže.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_RS422.png"><img class="aligncenter size-full wp-image-398" title="Interbus_RS422" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_RS422.png" alt="" width="601" height="145" /></a></p><p style="text-align: left;">Raspored priključaka standardnog ožičenja Interbus-S mreže  s DB-9 konektorima:</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_DB9.png"><img class="aligncenter size-full wp-image-402" title="Interbus_DB9" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_DB9.png" alt="" width="586" height="182" /></a></p><p style="text-align: left;">Raspored priključaka standardnog ožičenja Interbus-S mreže  s IP 65 konektorima:</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_IP65.png"><img class="aligncenter size-full wp-image-404" title="Interbus_IP65" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_IP65.png" alt="" width="553" height="173" /></a></p><p style="text-align: left;">Raspored spajanja Interbus-S mreže  s terminalskim priključnicama:</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_Term.png"><img class="aligncenter size-full wp-image-406" title="Interbus_Term" src="http://www.quercus-lab.com/wp-content/uploads/2011/12/Interbus_Term.png" alt="" width="439" height="267" /></a></p><h4>Interbus-S ASICs</h4><p>ASICs (<em>Application  Specific  Integrated  Circuit</em>) je integrirani krug za primjenu u točno  definiranoj aplikaciji za razliku od integriranih krugova opće namjene. Razvojem ASICs  čipova pojednostavljen je i ubrzan razvoj krajnjih uređaja posebno u otvorenim industrijskim  mrežama kao što je Interbus-S. Isto tako pojednostavljeno je razumijevanje i implementacija  mrežnog protokola kod krajnjeg korisnika. Korisnicima Interbu-S mreže dostupna su dva ASICs čipa:</p><ul><li><em>Slave  SuPI</em> – implementacija podređenog mrežnog člana  Interbus-S mreže s ulazno-izlaznim funkcijama</li><li><em>Master  IPMS</em>  &#8211; sučelje između Interbus-S mreže s jedne strane i mikroprocesorskog   upravljanja s druge</li></ul> ]]></content:encoded> <wfw:commentRss>http://www.quercus-lab.com/interbus-s-industrijska-mreza/feed/</wfw:commentRss> <slash:comments>0</slash:comments> </item> <item><title>Proračun količina rezervnih dijelova</title><link>http://www.quercus-lab.com/spareparts-calc/</link> <pubDate>Wed, 30 Nov 2011 18:13:32 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Razno]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=19</guid> <description><![CDATA[Ukupne potrebe za održavanjem određenog tipa uređaja mogu se klasificirati na potrebe za  preventivnim i na potrebe za  korektivnim održavanjem. U realizaciji je teško točno razdvojiti  preventivno od korektivnog održavanja, pa se i u teoriji održavanja barata s različitim  definicijama i razgraničenjima preventivnog i korektivnog održavanja. Međutim, uobičajeno je u preventivno održavanje ubrojiti sve one [&#8230;]]]></description> <content:encoded><![CDATA[<p><a href="http://www.quercus-lab.com/wp-content/uploads/2011/11/spc.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2011/11/spc.png" alt="" title="spc" class="alignleft size-full wp-image-480" width="180" height="130" /></a>Ukupne potrebe za održavanjem određenog tipa uređaja mogu se klasificirati na potrebe za  preventivnim i na potrebe za  korektivnim održavanjem. U realizaciji je teško točno razdvojiti  preventivno od korektivnog održavanja, pa se i u teoriji održavanja barata s različitim  definicijama i razgraničenjima preventivnog i korektivnog održavanja. Međutim, uobičajeno je u preventivno održavanje ubrojiti sve one radnje održavanja, koje nisu posljedica takve neispravnosti uređaja, koja stvarno jeste prekinula izvršenje rada uređaja prema namjeni. S druge strane, radnje održavanja kojima se otklanjaju posljedice otkaza, koji je nastao pri izvršavanju zadatka prema namjeni uređaja, ubrajaju se u korektivno održavanje (koje se nekad naziva naknadno ili neplansko). Bez obzira rade li se o jednom ili drugom tipu , u večini slučajeva, za efikasnu akciju potrebni su rezervni dijelovi.</p><h4>Model proračuna optimalnih količina rezervnih dijelova</h4><p style="text-align: left;">Asortiman rezervnih  dijelova zavisi od strukture tehničkog sustava, pogodnosti za održavanje i mogućnosti popravka uređaja. Količine pričuvnih dijelova zavise od pokazatelja pouzdanosti, broja jednakih dijelova u tehničkom sustavu, broja tehničkih sustava na održavanju (za koje se nabavljaju pričuvni dijelovi), zahtjeva za raspoloživost tehničkog sustava te prihvatljivosti troškova zaliha pričuvnih dijelova. Jedan od načina za normiranje pričuvnih dijelova je i matematičko modeliranje koje povezuje vjerojatnost da će pričuvni dio biti u zalihi kad zatreba,  pouzdanost dijela,  ekonomske parametre troškova zaliha i zastoja,  parametre količina i rasporeda tehničkih sredstava, te strukturu i parametre sustava snabdijevanja zalihama. Kako za većinu dijelova vrijedi da je intenzitet kvara  λ  konstantan, zahtjev za  količinom pričuvnih dijelova računamo po Poissonovoj raspodjeli pa vrijedi izraz:</p><p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/11/Poisson_calc.png"><img class="aligncenter size-full wp-image-281" title="Poisson_calc" src="http://www.quercus-lab.com/wp-content/uploads/2011/11/Poisson_calc.png" alt="" width="403" height="80" /></a><br /> Gdje je   <em>P(r)</em> vjerojatnost da će biti <em>r</em> ili manje zahtjeva za <em>i</em>-ti pričuvni dio, <em>N</em> broj tehničkih sustava na održavanju (za koje se osiguravaju zalihe), <em>n</em> broj i-tih dijelova, koji se proračunavaju kao pričuvni dijelovi u tehničkom sustavu, λ intenzitete otkaza i-tog dijela, <em>t</em> vrijeme rada tehničkog sustava, za koje se proračunavaju zalihe, <em>r</em> količina (broj) pričuvnih dijelova za <em>i</em>-ti dio.</p><h4>Intenzitet otkaza elemenata</h4><p>Razdoblje korisnog životnog vijeka je razdoblje aktivnog korištenja elemenata ili uređaja a karakteriziraju ga slučajni otkazi, različitog uzroka ili porijekla, uz koje se povremeno  pojavljuju poneki otkaz usred starosti ili istrošenosti. Zbog toga intenzitete otkaza<em>  λ(t) </em>  lagano raste s vremenom. No za praksu stvarna kosa linija  <em>λ(t)</em>  aproksimira horizontalnom,  čija vrijednost na ordinati je srednja vrijednost u toku razdoblja. Na taj način dobiva se  konstantna vrijednost intenziteta otkaza s kojom je mnogo jednostavnije računati s  zanemarivim greškama. U primjeni se nalazi više modela za proračun intenziteta otkaza elektroničkih elemenata i  sustava. Jedan od najpoznatijih modela za proračun intenziteta otkaza elektroničkih elemenata, koji je izrađen za potrebe američkih oružanih snaga, a rabi ga većina proizvođača  profesionalnih elektroničkih uređaja u svijetu je priručnik za predviđanje pouzdanosti <em>MIL- HDBK &#8211; 217 B, C, D, E i F</em>. Slovne oznake označavaju inačicu priručnika, koji se svakih nekoliko godina ažurira temeljem raščlambi podataka o otkazima i novih tehničkih i tehnoloških dostignuća (novi sastavni dijelovi, tehnologije izrade i sl.).  Podaci o intenzitetu otkaza elemenata po vrstama i podvrstama sistematizirani su u odgovarajuće tablice. Modeli za proračun intenziteta otkaza elemenata, prema ovom priručniku, zavise od vrste elemenata, ali imaju opći oblik:</p><p><a href="http://www.quercus-lab.com/wp-content/uploads/2011/11/SparePartsCalc_intenzitetotkaza.png"><img class="aligncenter size-full wp-image-297" title="SparePartsCalc_intenzitetotkaza" src="http://www.quercus-lab.com/wp-content/uploads/2011/11/SparePartsCalc_intenzitetotkaza.png" alt="" width="396" height="59" /></a></p><p>Izraz se sastoji od tri osnovna parametra: temeljnog intenzitete otkaza koji se isčitava iz tablica, čimbenika okoline rada sredstva i pokazatelja kvalitete elementa. Na  to se dodaju čimbenici koji se odnose na grupu, način konstrukcije, način korištenja, primijenjeni napon itd. Recipročna vrijednost intenzitetu otkaza je prosječno srednje vrijeme između dva kvara<em> MTBF  (mean time between failures)</em> a izražava se u satima rada.</p><h4 style="text-align: left;">SpareParts Calculator</h4><p style="text-align: left;">Aplikacija <em><strong>SpareParts Calculator</strong></em>  <strong><em></em></strong>je mali grafički kalkulator optimalnih količina rezervnih dijelova. Postoji nekoliko načina proračuna potrebnih rezervnih dijelova, a u programu se  koristiti metoda za jednostavni model kada je intenzitete kvara konstantan. Proračun se bazira na matematičkom modelu razvijenom od vodećih eksperata na području održavanja tehnoloških sustava u svijetu.  Za proračun je neophodno da znate, izračunate ili procijenite intenzitet otkaza dijelova ili elementa tehnološkog sustava. Rezultat proračuna su vjerojatnosti da će traženi rezervni dio biti na raspolaganju u trenutku kvara.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/11/SparePartsCalc_Program.png"><img class="aligncenter size-full wp-image-291" title="SparePartsCalc_Program" src="http://www.quercus-lab.com/wp-content/uploads/2011/11/SparePartsCalc_Program.png" alt="" width="474" height="422" /></a></p><h4>Rad s aplikacijom</h4><p>Prije aktiviranja proračuna potrebno  je pravilno definirati ulazne parametre:</p><p><a href="http://www.quercus-lab.com/wp-content/uploads/2011/11/SparePartsCalc_paramters.png"><img class="aligncenter size-full wp-image-287" title="SparePartsCalc_paramters" src="http://www.quercus-lab.com/wp-content/uploads/2011/11/SparePartsCalc_paramters.png" alt="" width="574" height="153" /></a></p><p>Osnovni ulazni  parametar je intenzitet otkaza elementa  ili srednja vrijednost između dva kvara (MTBF). Oba ova unosa su jednakovrijedna za proračun i izborom jednog od njih drugi se izračunava automatski. Dodatni parametri su broj istovrsnih elemenata u u sustavu (tehničkom sredstvu) te broj sustava za koje se proračunavaju rezervni dijelovi. Proračun se bazira na vremenskom periodu koji se unosi kao broj radnih sati i željenoj (ciljanoj) vjerojatnosti zaliha. Ovaj podatak je se unosu kao  postotak ( 1 je 100 posto).  Način proračuna definira se izborom <em>Optimalno/Definirano</em>  pri čemu optimalno znači da će se na izlaznom grafikonu prikazati vrijednosti vjerojatnosti da će se određeni dio naći u skladištu  i to za količine od 1 komada do količine koja zadovoljava uvjet  željene vjerojatnosti  zadan kao parametar. Ta količina, čija je vjerojatnost prva koja je jednaka ili veća željenoj, se ispisuje  u polju<em> Definirano</em>. Izaberemo li modus <em>Definirano</em> u grafikonu će biti prikazane sve vjerojatnosti od 1 komad  do broja komada upisanog u polje <em>Definirano</em>.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/11/SparepartsCalc_output.png"><img class="aligncenter size-full wp-image-289" title="SparepartsCalc_output" src="http://www.quercus-lab.com/wp-content/uploads/2011/11/SparepartsCalc_output.png" alt="" width="501" height="338" /></a></p><p style="text-align: left;">Ova aplikacija se nudi  &#8220;onakva kakva je&#8221;, bez jamstva i podrške bilo koje vrste. Aplikaciju možete koristiti na vlastitu odgovornost i  autor ne prihvaća nikakvu odgovornost za bilo koju štetu koju ova aplikacija može prouzročiti neposredno ili posredno</p><p style="text-align: left;">Za preuzimanje aplikacije kliknite ovdje: <a href="http://www.quercus-lab.com/wp-content/uploads/2011/11/SPCalc_setup.exe">SPCalc_setup</a></p> ]]></content:encoded> </item> <item><title>SoftPLC</title><link>http://www.quercus-lab.com/softplc/</link> <comments>http://www.quercus-lab.com/softplc/#respond</comments> <pubDate>Mon, 21 Nov 2011 11:15:48 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Automatizacija]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=228</guid> <description><![CDATA[Od početka razvoja PC kompatibilne tehnologije bilo je pokušaja korištenja iste za kontrolu procesne opreme. Glavni problem u razvoju tih aplikacija bilo je to što PC nije bio razvijan kao sustav za rad u stvarnom vremenu (real time).  Tek pretvaranje standardnih operativnih sustava (dos, windows, linux) u realtime operativne sustave stekli su se uvjeti za [&#8230;]]]></description> <content:encoded><![CDATA[<p><a href="http://www.quercus-lab.com/wp-content/uploads/2011/11/SoftPLC.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2011/11/SoftPLC.png" alt="" title="SoftPLC" class="alignleft size-full wp-image-485" height="130" width="180" /></a>Od početka razvoja PC kompatibilne tehnologije bilo je pokušaja korištenja iste za kontrolu procesne opreme. Glavni problem u razvoju tih aplikacija bilo je to što PC nije bio razvijan kao sustav za rad u stvarnom vremenu (<em>real time).  </em>Tek pretvaranje standardnih operativnih sustava (dos, windows, linux) u <em>realtime</em> operativne sustave stekli su se uvjeti za efikasno korištenje PC računala kao procesnih računala. I nakon toga programiranje takvih računala  u sustavima automatizacije bilo je teško jer inženjeri automatizacije, u pravilu, nisu bili obučeni za klasično programiranje u asembleru ili višim programskim jezicima  dok su vrsni programeri imali problema s poznavanjem industrijskih procesa. Stvaranje efikasnog tima bilo je vrlo teško i skupo stoga su kompanije koje su se bave razvojem takvih sustava odlučile definirati standarde koji su bitno pojednostavili primjeni PC bazirane opreme u sustavima automatizacije. Rezultat te inicijative je IEC63131 standard koji definira smjernice za programiranje  suvremenih PLC uređaja a koji je najbolje podržan u takozvanim SofPLC sustavima.<br /> SoftPLC sustavi su softverski proizvodi pomoću kojih standardne hardverske (intel, motorola, arm)  i softverske platforme (windows, linux) pretvaramo u moćna procesna računala.  Programiranje takvih računala je prilagođeno standardima programiranja običajnih PLC i PAC računala.</p><h4>ProConOS soft-PLC</h4><p>ProConOS (<em><strong>Pro</strong>gammable </em><strong><em>Con</em></strong><em>troller </em><strong><em>O</em></strong><em>perating </em><strong><em>S</em></strong><em>ystem</em>) je programsko bazirani PLC sustav koji osigurava PLC specificiran servis na standardnim ili specijalnim hardverskim platformama. To uključuje učitavanje i procesiranje PLC programa kao i mogućnost testiranje i ispravljanja programa (<em>debug)</em> pri pokretanju i održavanju strojeva i postrojenja upravljanih procesnim računalom. Druga definicija za ProConOS je da je on visoko učinkoviti <em>PLC runtime</em> sustav za kompleksne upravljačke aplikacije. Dizajniran je specijalno za IEC61131 normu i sadrži cijeli niz IEC61131 značajki. Dakle da bi ste dobili upotrebljivo procesno računalo trebate prvo izabrati neku stanadardnu sklopovsku opremu  (hardware) podesnu za automatizaciju vašeg procesa ili napraviti svoju baziranu na podržanim procesorima. Na takav hardver instaliarate neki od podržanih <em>realtime</em> operativni sustav. Sada je vaše računalo spremno za instaliranje softPLC-a ProConOS.  Nakon svega toga imate procesno računalo spremno za programiranje vašeg sustava automatizacije na manje ili više uobičajeni način programiranja PLC-a. PorConOS se isporučuje se s IEC61131 programskom razvojnom okolinom <em>KW Multiprog</em> koja omogućuje lagano programiranje u SFC, LD, STL ili IL programskim jezicima.</p><p><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/ProconOS_web.png"><img class="aligncenter size-full wp-image-238" title="ProconOS_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/ProconOS_web.png" alt="" height="305" width="591" /></a></p><p>Jedna od bitnih razlika programiranja podržanih od IEC 61131 norme , u odnosu na standarne PLC-e,  je mogućnost vremenskog upravljanja izvršavanjem pojednih programskih zadataka <em>(taskova</em>). Za razliku od kontinuiranog izvršavanja vašeg programskog koda  IEC 61131 standard  opisuje različite modele raspoređivanja vremena rada programskih taskova<em></em>:</p><ul><li><em>Default task</em> , svaki <em>resource</em> sadržava jedan default task koji ima najniži prioritete. Taj task nije vremenski raspoređen.</li><li><em>Cyclice task</em> koji se izvršava periodično u određenim vremenskim intervalima</li><li>System task poziva operacijski sustav PLC-a ako je došlo do promjena stanja PLC-a ili nekakve greške.<strong><em> </em></strong></li><li><em>Event or interrupt tasks</em>  se aktivira na određeni definirani događa ili stanje</li></ul><p style="text-align: left;">Svaki task ima određeni prioritete. U sustavima s takozvanim raspoređivanja sa preuzimanjem (<em>preemptivnim scheduling) </em>, koji je implementiran u softPLC-u ProConOS-u, task koji ima niži prioritete prekida se odmah kada se aktivira task s višim prioritetom za razliku od <em>none-preemptivnim</em> sustavima gdje nije moguć prekid trenutnog taska od strane taska s višim prioritetom.<br /> <a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/ProConOs_PreemptiveScheduling_web.png"><img class="aligncenter size-full wp-image-240" title="ProConOs_PreemptiveScheduling_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/ProConOs_PreemptiveScheduling_web.png" alt="" height="301" width="633" /></a></p><p>Radna memorija ProConOS-a podjeljana je  na slijedeće dijelove:</p><ul><li>PLC program – aktualni izvršni korisnički program</li><li>Međuspremnik (buffer) za interne aktualne podatke</li><li>Procesna memorija koja sadrži sliku procesa a razlikuje:<ul><li>I –  ulazne podatke</li><li>Q – izlazne podatke</li><li>M – memorijske varijable</li><li>RM – <em>retentivne </em>memorijske varijable</li></ul></li><li>memorija za takozvani <em>bootproject</em></li><li>memorija za kompresirani project (kompletan)</li></ul><p>Shodno kompatibilnošću s IEC smjernicama ProConOS podržava sve tipove varijabli definirane u standardu a samo programiranje zahtjeva simbolično adresiranje kako memorijskih tako i ulazno/izlaznih varijabli.</p><h4><strong>Razvojno okruženje KW Multiprog</strong></h4><p>Za programiranje PLC-a i PAC-a koji podržavaju standard IEC61131 postoji nekoliko razvojnih  okolina a jedno od njih je i KW Multiprog. Multiprog je 32-bitna PC aplikacija sa intuitivnim sučeljem i sustavom za pomoć napravljenim po uzoru na razvojna okruženje za programiranju u ostalim modernim programskim jezicima opće namjene. Podržava gotovo se smjernice IEC61131 standarda. Podržani su programski jezici LD, IL, ST, FBD i SCF te njihovo slobodno miješanje u zajedničkom projekt radi primjene najefikasnijeg načina programiranja zahtijevanog algoritma. Administracija projekta te reprezentacija pojedinih elementa projekta i njihova terminologija je po IEC smjernicama. Kompajleri za pojedine hardverske platforme su modularni. Podržana je instalacija, puštanje u pogon te testiranje koristeći ugrađene alate kao što su osciloskopski prikaz statusa i simulator. Korisničko sučelje striktno podržava Windows standarde upravljanja objektima kao i dodatne elemente kao što su čarobnjaci i sustav za pomoć baziran na HTML standardu.</p><p>Upravljane projektom u Multiprogu je jednostavno i oslanja se na <em>Windows Explorer</em> strukturu u obliku drva baziranu na  IEC61131 softverskom modelu. Pisanja programa moguće je svi 5 programskih jezika definirani EEC61131 standardom a to su:</p><ul><li>• <em>Instruction List</em> (IL)</li><li>• <em>Structured Text</em> (ST)</li><li>• <em>Function Block Diagram</em> (FBD)</li><li>• <em>Ladder Diagram</em> (LD)</li><li>• <em>Sequential Function Chart</em> (SFC)</li></ul><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/KW_Multiprog.png"><img class="aligncenter size-full wp-image-247" title="KW_Multiprog" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/KW_Multiprog.png" alt="" height="384" width="614" /></a></p><p>Kao što je i nabrojano neki od ovih programskih jezika se programiraju u tekstualnom a neki u grafičkom editoru. Tekstualni editor automatski ispisuje ključne riječi programskih jezika u određenim bojama u ovisnosti o sintaksi a podržano je i automatsko kompletiranje imena korištenih varijabli i strukturnih elementa funkcijski blokova. Grafički editor omogućava slobodno manipuliranje funkcijski blokovima, automatsko povezivanje pojedinih elementa te naknadno ubacivanje ili brisanje bez gubitka strukture. Pojedini programski elementi se ispisuje, kao i kod tekstualnog editora, u posebnim bojama   radi što jasnije strukture programa. Na istom radnom prostoru (<em>worksheetu</em>) moguće je miješati sva tri programska jezika: LD, FBD i SFC. Klikom miša na određeno mjesto u grafičkom okruženje moguće je prebaciti se u tekstualni editor i nastavka pisanja programa željenim programskim jezikom. Dodatne dijagnostičke funkcije skraćuju vrijeme puštanja u pogon i testiranja korištenih algoritama u realnom vremenu a to su:</p><ul><li>Logički analizator (<em>Logic Analyzer</em>)<br /> <a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/Multiprog_LogicAnalyzer_web.png"><img class="aligncenter size-full wp-image-253" title="Multiprog_LogicAnalyzer_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/Multiprog_LogicAnalyzer_web.png" alt="" height="339" width="566" /></a></li><li>Sustav recepata (<em>Recipes</em>)</li><li>Prekidne točke u programu (<em>Breakpoints</em>)</li><li>Pregled  memorijskih lokacija (<em>Address debug</em>)</li><li>Izvršavanje programa korak po korak (<em>Single step</em>)</li><li>Prepisivanje vrijednosti u programu ( <em>Overwriting and forcing</em>)<a href="http://www.quercus-lab.com/wp-content/uploads/2011/11/Multiprog_Debug_web.png"><img class="aligncenter size-full wp-image-274" title="Multiprog_Debug_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/11/Multiprog_Debug_web.png" alt="" height="388" width="614" /></a></li><li>Izmjene programa  u samom PLC-u (<em>Online changes</em>)</li><li>Simulacija programa (<em>PLC simulation</em>)<a href="http://www.quercus-lab.com/wp-content/uploads/2011/11/Multiprog_Download_web.png"><img class="aligncenter size-full wp-image-275" title="Multiprog_Download_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/11/Multiprog_Download_web.png" alt="" height="369" width="608" /></a></li></ul><p>&nbsp;</p> ]]></content:encoded> <wfw:commentRss>http://www.quercus-lab.com/softplc/feed/</wfw:commentRss> <slash:comments>0</slash:comments> </item> <item><title>IEC 61131 standard  i SFC</title><link>http://www.quercus-lab.com/iec61131-standard-i-sfc/</link> <comments>http://www.quercus-lab.com/iec61131-standard-i-sfc/#respond</comments> <pubDate>Fri, 21 Oct 2011 12:23:12 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Automatizacija]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=126</guid> <description><![CDATA[Današnja industrijska postrojenja uglavnom su upravljanja procesnim računalima koje se nazivaju Programljivi Logički Kontroleri ili skraćeno PLC-i.  Više od 25 godina nakon uvođenja prvi PLC-a, na ovom tržištu još uvijek nije bilo  međunarodnog standard sličanom onom za PC računala do definiranja IEC 61131 standarda. Mnogi proizvođači koriste svoj dijalekt  uvriježenih programskih jezika a napisani softver [&#8230;]]]></description> <content:encoded><![CDATA[<p style="text-align: left;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/IEC61131-3.png"><img src="http://www.quercus-lab.com/wp-content/uploads/2011/10/IEC61131-3.png" alt="" title="IEC61131-3" class="alignleft size-full wp-image-487" height="130" width="180" /></a>Današnja industrijska postrojenja uglavnom su upravljanja procesnim računalima koje se nazivaju <em>Programljivi Logički Kontroleri</em> ili skraćeno PLC-i.  Više od 25 godina nakon uvođenja prvi PLC-a, na ovom tržištu još uvijek nije bilo  međunarodnog standard sličanom onom za PC računala do definiranja IEC 61131 standarda. Mnogi proizvođači koriste svoj dijalekt  uvriježenih programskih jezika a napisani softver se koristi samo na tim kontrolerima.  Time je implementacije sklopovske opreme različitih proizvođača u jedinstven sustav upravljanja vrlo složen posao, a samim tim, i vrlo skup.  Stoga je za mnoge neshvatljivo da je trebalo više od 25 godina da se stvore zahtjevi za zajedničku programsku platformu kao što je standard IEC 61131-3.  Prije pojave IEC61131-3 standarda teorijski nije bilo moguće koristiti program napisan za određeni PLC na nekom drugom PLC-u (portanje). Nažalost veliki stupanj prenosivosti (portabilnosti) softvera bit će teško ostvariti i sada  jer standard samo definira specifikacije a od proizvođača se traži da on sam napravi spisak podržanih karakteristika.</p><h4>Osnove standarda</h4><p>Nekoliko većih kompanija  koje se bave razvojem prenosivog (portabilnog) softverom  za programiranje SoftPLC-a su formirali PLCopen Trade Association. PLCOpen je svjetska <em>vendor i product</em>  neovisna udruga koja  podržava IEC61131-3 normu. Osnovana je 1992 u Nizozemskoj a danas ima svoje urede u Kanadi i Japanu. Organizacija  informira korisnike i programere o standardu preko internetske stranice  <a href="http://www.plcopen.org/">www.plcopen.org</a>, besplatnim kvartalnim novostima te organizira konferencije po sajmovima.   PLCOpen definira tri različita <em>compliance classes </em>o prenosivosti kontrolnog sustava softvera<em>. </em></p><ol><li>Bazna razina (<em>Base Level</em> ) definira samo jezgru standarda (<em>core kerna</em>l) pa, iako je ograničena,  moguće je razvijati aplikacije na temelju nje. Ona ustvari samo pokazuje opredijeljenost proizvođača k standardu.</li><li>Razina  prenosivost (<em>Portability Level</em> ) sadrži veliki skup značajki, uključujući korisnički definiranih funkcija i funkcija bloka. Ova razina zahtijeva da sustav ima opciju <em>izvoz / uvoz</em>  za jednostavnu razmjenu programskog koda između sustava različitih proizvođača</li><li>Najviša razina, potpuna usklađenost  (<em>Full Compliance)</em>, nudi razmjenu potpune aplikacije, uključujući i konfiguracijskih informacija, između različitih sustava kontrole</li></ol><p>Po standardu  svi programi trebaju se rastaviti na funkcionalne elemente, programske organizacione jedinice (POU). Jedna POU sadrži funkcije, funkcijske blokove ili programe. Ako je moguče treba izvršavati  pojedine dijelove aplikacijskog programa razlčitom dinamikom u smislu da  sustav treba podržavati individualne vremenske intervale za različite POU (<em>Time</em> <em>Scheduling)</em></p><h4>Programski jezici</h4><p>Pisanja programa treba biti moguće u svim programskim jezicima koje definiran IEC61131 norma a to su:</p><ul><li> <em>Instruction List</em> (IL)- lista instrukcija grupiranih u korake programa koja uvelike podsječa na programiranje u asembleru</li><li> <em>Structured Text</em> (ST) – struktuirani tekst je standardni programski jezik više razine nalik na Pascal</li><li> <em>Function Block Diagram</em> (FBD) – funkcijski blok dijagram izgledom podsjeća na električne sheme digitalnih sklopova</li><li> <em>Ladder Diagram</em> (LD) – Ljestvičasti dijagram koji je prvi program za programiranje u sustavima automatizacije a izgledom oponaša električne sheme spajanja</li><li> <em>Sequential Function Chart</em> (SFC) – sekvencijalni funkcijski dijagram izgledom podsjeća na dijagrame  tijeka a posebno je prihvatljiv za brzo i pregledno programiranje sekvencijalnih procesa</li></ul><p>&nbsp;</p><h4>Sekvencijalni funkcijski diagram &#8211; SFC</h4><p>Jedan od zahtjeva standarda je da složena sekvencijalna događanja treba razložiti na događaje (<em>events</em>) s konciznim grafičkim jezikom a to se postiže upravo s SFC-om. U biti SFC nije programski jezik nego prezentacijski okvir sekvencijalne strukture koji objedinjuje programske algoritme napisane u ostalim jezicima.  SFC programski jezik razlikuje dvije osnovna elementa grafikona a to su korak  (<em>step</em>) i prijelaz ili tranzicija (<em>transition</em>). Koraci se predstavljaju četverokutima a povezani su okomitim linijama koje označavaju vremenski tijek. Svaki korak ima jedinstveni naziv a povezuje se (asocira) s jednom ili više akcija. Akcija može biti jednostavna binarna naredba ili , što je češći slučaj, poziv funkcije ili POU. POU može ravnopravno biti pisana u jednom od ostala 4 normirana programska jezika. Prijelaz iz jednog u drugi korak moguć je kad je ispunjen uslov prijelaza koji se  grafički prezentira kao vodoravna linija. To je  binarna varijabla koja se automatski generira a na nju je moguće   djelovati u bilo kojem dijelu programa.</p><p>Primjer jednog jednostavnog SFC programa imamo na slici. Program započinje inicijalnim korakom <em>S0</em> uz koji nij asocirana nikakva akcija.Izvršavanje programa iz koraka u korak uslovljeno je prijelazima <em>Tr1, Tr2, Tr3, Tr4 i Tr5</em>.  Zadovoljavajući  ove uslove aktiviraju se redom korak <em>S0</em> do <em>S4</em>.  Kada je aktivan korak<em> S1</em> on izvršava binarnu komandu  SET nad varijablom Var1. Slijedći korak <em>S2</em> poziva programsku organizacionu jedinicu  POU1 koja se izvršava samo dok je taj korak aktivan. Nakon prelaska na korak <em>S3</em> resetira se varijabla Var1 i ako je uslov <em>Tr3</em> ispunjen aktivira  se korak  <em>S4</em>. Ovaj korak poziva program POU2 ali s odgodom od 10 vremenskih jedinica. Konačno, ispunjavanjem uslova <em>Tr5</em> zatvara se petlja a izvršavanje tijeka programa se vrača na početak.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Base.png"><img class="aligncenter size-full wp-image-201" title="SFC_Base" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Base.png" alt="" height="360" width="318" /></a></p><h4>Kvalifikacije za akciju</h4><p>Izvršavanje pojednačnog koraka poziva se akcija koje je asocirana uz njega a karakteristika akcije definira se  kvalifikacijama akcije (<em>Action Qualifiers</em>). To su  slovčane oznake koje definiraju način aktiviranja i trajanja  asociranog programskog segmeta ili POU.</p><ul><li style="text-align: left;"><strong>N</strong> (<em>Non-Stored</em>)<br /> Akcija se izvršavao onoliko dugo koliko traje korak (<em>step</em>).<br /> <a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionN_web.png"><img class="aligncenter size-full wp-image-158" title="SFC_ActionN_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionN_web.png" alt="" height="177" width="480" /></a></li><li style="text-align: left;"><strong>S</strong> (<em>Set</em>)<br /> Akcija se pokreče početkom koraka koji je asociran sa <strong>S</strong> a prekida se početkom koraka koji je asociran s <strong>R</strong><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionN_V3.png">.<br /> </a><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionS_web.png"><img class="aligncenter size-full wp-image-164" title="SFC_ActionS_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionS_web.png" alt="" height="177" width="480" /></a></li><li style="text-align: left;"><strong>R </strong>(<em>Overiding Reset</em>)<br /> Akcije koje su pokrenute s <strong>S, SD, DS,</strong>  i<strong> SL</strong> prekidaju se početkom koraka asociranom s <strong>R.</strong></li><li style="text-align: left;"><strong>L </strong>(<em>Time Limited</em>)<br /> Akcija se pokreče početkom koraka asociranim  s <strong>L</strong> a trajanje je limitirano parametrom T čija vrijednost  mora biti manji od trajanja samog koraka.<br /> <a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionL_web.png"><img class="aligncenter size-full wp-image-167" title="SFC_ActionL_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionL_web.png" alt="" height="177" width="480" /></a></li><li style="text-align: left;"><strong>D </strong>(<em>Time Delayed</em>)<br /> Akcija se pokreče nakon isteka definiranog vremena T (odgoda uklapanja) a traje do kraja trajanja koraka.<br /> <a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionD_web.png"><img class="aligncenter size-full wp-image-168" title="SFC_ActionD_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionD_web.png" alt="" height="177" width="480" /></a></li><li style="text-align: left;"><strong>P </strong>(<em>Pulse</em>)<br /> Akcija traje samo jedan scan ciklus unutar trajanja koraka.<br /> <a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionP_web.png"><img class="aligncenter size-full wp-image-170" title="SFC_ActionP_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionP_web.png" alt="" height="177" width="480" /></a></li><li style="text-align: left;"><strong>SD </strong>(<em>Stored &amp; Time Delayed</em>)<br /> Akcija se pokreče nakon isteka vremena T od početka koraka s kojim je asocirana a traje do početka koraka asociranog  s <strong>R</strong><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionN_V3.png">.<br /> </a><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionSD_web.png"><img class="aligncenter size-full wp-image-173" title="SFC_ActionSD_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionSD_web.png" alt="" height="177" width="480" /></a></li><li style="text-align: left;"><strong>SL</strong>(<em>Stored &amp; Time Limited</em>)<br /> Akcija se pokreče početkom koraka, trajanje joj je definirano parametrom T koji može biti veći od trajanja koraka.  Akcija se može prekinuti početkom koraka koji je asociran s <strong>R</strong></p><h4><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionSL_web.png"><img class="aligncenter size-full wp-image-166" title="SFC_ActionSL_web" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_ActionSL_web.png" alt="" height="177" width="480" /></a></h4></li></ul><h4>Grananja tijeka</h4><p>Standardni tijek izvršavanja SFC programa je jednostruka petlja ali ona ne može zadovoljiti sve potrebe procesnih algoritama. Često nam je potrebno da se istovremeno izvršavaju nekoliko programskih akcija ili da se neke od njih uslovno pokreču.  U tim slučajevima koristimo grananje tijeka u SFC dijagramu a postoje dva osnovana tipa grananja: <strong><em></em></strong></p><ul><li><strong><em>Uslovno grananje</em></strong> kod kojega se prijelaz na slijedeći korak ostvaruje kada se ispune uslovi paralelno postavljenih prijelaza. Na slici  je jedan primjer uslovnog grananja kojega ću pokušati pojasniti. Nakon inicijalnog koraka <em>S0</em> i zadovoljenja uslova <em>Tr1</em> prelazi se na korak <em>S1</em>. Iz toga koraka je moguće prijeći na korake <em>S2</em> i <em>S3</em> i to na način da se ostvare uslovi <em>Tr2 ili Tr3</em>. Ovi uslovu su obično komplementarni odnosno možemo reči da je to programska struktura <em>IF THEN ELSE</em> . Dakle ako je uspunjen uslov <em>Tr2</em> prelazi se u granu <em>S2-S4</em> koja se potom izvršava. Ispunjenjem uslova <em>Tr6</em> ponovno se vračamo na glavni tijek. Ekvivalentna je priča i s granom <em>S2</em>. Postavlja se pitanje što će se dogoditi ako su nakon koraka <em>S1</em> oba uslova <em>Tr2 i Tr3</em> zadovoljena. U tom slučaju program se izvršava u obje grane ali je trajanje determinirano uslovima u grani dijagrama koja je <strong>NA LIJEVOJ</strong> strani.  U našem slučaju nakon koraka S1 izvršavati će  se koraci <em>S2-S4</em> te <em>S3</em> istovremeno ali u slučaju da se uslov <em>Tr5</em>  zadovolji  prije uslova <em>Tr6</em> program se neće prebaciti na glavni tijek. Isto tako kada se ostvare uslovi <em>Tr4</em> i <em>Tr6</em> bezuvjetno će se prekinut  izvršavanje koraka  <em> S3</em> i i izvršavanje će se vratiti na glavni tijek.</li></ul><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Divergence.png"><img class="aligncenter size-full wp-image-205" title="SFC_Divergence" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Divergence.png" alt="" height="444" width="397" /></a></p><ul><li><strong><em>Paralelno grananje</em></strong> kod kojega se bezuslovno ulazi u izvršavanje paralelnih grana dijagrama. U našem primjeru  nako zadovoljenja uslova <em>Tr2</em> prekida se izvršavanje koraka <em>S1</em> te se simultano započinje s izvršavanjem koraka <em>S2</em> i <em>S4</em> u lijevoj grani te koraka <em>S3</em> u desnoj grani. Kada obje grane dođu do kraja, u našem slučaju kada se izvršavanju koraci <em>S3</em> i <em>S4</em> ispituje se uslov <em>Tr4</em>. Kada se uslov zadovolji prekida se izvršavanje koraka <em>S3</em> i <em>S4</em>, započinje  izvršavanje koraka <em>S5</em> i program se vrača u glavni tijek.  <a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Divergence.png"><br /> </a></li></ul><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Paralele.png"><img class="aligncenter size-full wp-image-195" title="SFC_Paralele" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Paralele.png" alt="" height="416" width="404" /></a></p><p style="text-align: left;">Koristeći se ovdje navedenim pravilima i njihovim kombiniranjem možemo napraviti vrlo efikasni sekvencijalni dijagram  našega procesa. Zahvaljujući tome što koristimo grafičke elemente kojim definiramo  strukture našeg programa mi zapravo već u fazi programiranja procesnog algoritma gradimo rudimentarnu dokumentaciju koja nam olakšava testiranje programa u fazi puštanja u pogon . Isto tako dobro definiran dijagram omogućava efikasno razvijanje i nadogradnju našeg programa od strane drugih programera te razvoj programa u timovima.</p><p style="text-align: center;"><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Paralele.png"><br /> </a><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/SFC_Paralele.png"><br /> </a></p><p>&nbsp;</p> ]]></content:encoded> <wfw:commentRss>http://www.quercus-lab.com/iec61131-standard-i-sfc/feed/</wfw:commentRss> <slash:comments>0</slash:comments> </item> <item><title>Dobrodošli na naš blog</title><link>http://www.quercus-lab.com/uvodno/</link> <pubDate>Sun, 02 Oct 2011 11:20:20 +0000</pubDate> <dc:creator><![CDATA[quercus]]></dc:creator> <category><![CDATA[Razno]]></category><guid isPermaLink="false">http://www.quercus-lab.com/?p=1</guid> <description><![CDATA[&#160; &#160; Pozdrav svima! Otvaranje ovoga bloga je na tragu prijašnje web stranice istoga imena gdje smo predstavljali naše radove i sfere interesa. Nadamo se da će i ovaj blog biti koristan i zanimljiv.]]></description> <content:encoded><![CDATA[<p>&nbsp;</p><p><a href="http://www.quercus-lab.com/wp-content/uploads/2011/10/155c38853a79a01d3e7982ee80849b6c3.jpg"><img class="alignnone size-full wp-image-14" title="155c38853a79a01d3e7982ee80849b6c" src="http://www.quercus-lab.com/wp-content/uploads/2011/10/155c38853a79a01d3e7982ee80849b6c3.jpg" alt="" width="493" height="301" /></a></p><p>&nbsp;</p><p>Pozdrav svima!</p><p>Otvaranje ovoga bloga je na tragu <a title="Stara stranica" href="http://www.bug.hr/weboteka/ostalo/quercus-lab/1239.aspx" target="_blank">prijašnje web stranice istoga imena </a>gdje smo predstavljali naše radove i sfere interesa.</p><p>Nadamo se da će i ovaj blog biti koristan i zanimljiv.</p> ]]></content:encoded> </item> </channel> </rss>